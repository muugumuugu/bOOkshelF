
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-six.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-sixli1.html" >next</A>] [<A 
 HREF="theory-bk-sixse3.html" >prev</A>] [<A 
 HREF="theory-bk-sixse3.html#tailtheory-bk-sixse3.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-sixse4.html">tail</A>] [<A 
 HREF="theory-bk-six.html#theory-bk-sixse4.html" >up</A>]
<H3>6.4 <A 
   NAME="70004-70006.4"> </A><A 
 HREF="theory-bk.html#Q2-70004-7"  NAME="Q1-70004-7">Probabilistic Polynomial Time</A></H3>
   <P >
      <A 
 HREF="#Q1-70004-8"  NAME="Q2-70004-8">Probabilistic Time Complexity</A>
<BR>         <A 
 HREF="#Q1-70004-9"  NAME="Q2-70004-9">Probabilistic Complexity Classes</A>
<BR>         <A 
 HREF="#Q1-70004-10"  NAME="Q2-70004-10">Relationships between Probabilistic and Nonprobabilistic Complexity Classes</A>
   <P >As in the case of deterministic and nondeterministic Turing transducers, each move of
a probabilistic Turing transducer is assumed to take one unit of time. The <I>time</I><A NAME="70004-7001"> </A>
that a computation takes is assumed to be equal to the number of moves made
during the computation. The <I>space</I><A NAME="70004-7002"> </A> the computation takes is assumed to equal the
number of locations visited in the auxiliary work tape, which has the maximal such
number.
   <P ><EM><A 
   NAME="70004-8000"> </A><A 
 HREF="#Q2-70004-8"  NAME="Q1-70004-8">Probabilistic Time Complexity</A></EM>
   <P >A probabilistic Turing transducer M is said to be T(n) <I>time-bounded<A NAME="70004-8001"> </A></I>, or of <I>time
complexity</I> T(n), if M halts within T(n) time in each computation on each input of length
n. If T(n) is a polynomial, then M is also said to be <I>polynomially<A NAME="70004-8002"> </A> time-bounded</I>, or to
have <I>polynomial time complexity</I>.
   <P >M is said to be T(n) <I><A NAME="70004-8003"> </A> expected time-bounded</I>, or of <I>expected time complexity T(n)</I>, if
for each input x of M the function T(n) satisfies
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-six155x.gif" ALT="          ¥ (                                  )
T(|x| ) ³ å     Probability thatM  on inputx willhave   ·j
        j=0   acomputationthattakesexactly jmoves"></PRE></CENTER>
   <P >If T(n) is a polynomial, then M is said to be <I>polynomially<A NAME="70004-8004"> </A> expected time-bounded</I>, or
of <I>polynomially expected time complexity</I>.
   <P >Arguments similar to those given for Church's Thesis in Section 4.1, and for
the sequential computation thesis in Section 5.1, also apply for the following
thesis.
   <P ><STRONG>The Probabilistic<A NAME="70004-8005"> </A> Computation Thesis </STRONG> <A 
   NAME="70004-8006t"> </A> 
A function that is computable mechanically with the aid of probabilistic choices can also
be computed by a probabilistic Turing transducer of polynomially related time complexity
and polynomially related, expected time complexity.
   <P ><EM><A 
   NAME="70004-9000"> </A><A 
 HREF="#Q2-70004-9"  NAME="Q1-70004-9">Probabilistic Complexity Classes</A></EM>
   <P >The tractability of problems with respect to probabilistic time is determined by the
existence of bounded-error probabilistic Turing transducers of polynomial time
complexity for solving the problems. In light of this observation, the following classes of
language recognition problems are of interest here.
     <DL><DT><STRONG>
     </STRONG><DD 
><I>BPP</I> -- the<A NAME="70004-9001"> </A> class of membership problems for the languages in
     <P >{ L  |  L is a language accepted by a bounded-error probabilistic Turing
     machine of polynomial time complexity }.
     <DT><STRONG>
     </STRONG><DD 
><I>RP</I>   -- the<A NAME="70004-9002"> </A> class of membership problems for the languages in
     <P >{ L | L is a language accepted by a polynomially time-bounded, probabilistic Turing
     machine M, which satisfies the following two conditions for some constant
     <FONT FACE="SYMBOL">e</FONT> &lt; 1.
         <OL TYPE="a" 
>
         <LI><A 
   NAME="70004-9003xa"> </A>On input x from L, M has an accepting computation with probability
         1 - e(x) <FONT FACE="SYMBOL">³</FONT> 1 - <FONT FACE="SYMBOL">e</FONT>.
         <LI><A 
   NAME="70004-9004xb"> </A>On input x not from L, M has only nonaccepting computations.          }</OL>
     <DT><STRONG>
     </STRONG><DD 
><I>ZPP</I> -- the<A NAME="70004-9005"> </A> class of membership problems for the languages in
     <P >{ L | L is a language accepted by a probabilistic Turing machine, which has
     zero error probability and polynomially expected time complexity. }</DL>
   <P ><EM><A 
   NAME="70004-10000"> </A><A 
 HREF="#Q2-70004-10"  NAME="Q1-70004-10">Relationships between Probabilistic and Nonprobabilistic
<BR>Complexity Classes</A></EM>
   <P >The relationship between the different classes of problems, as well as their relationship
to the classes studied in Chapter 5, is illustrated in Figure <A 
 HREF="#70004-10001r6.4.1">6.4.1</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="70004-10001r6.4.1"> </A>
<A 
   NAME="70004-10001r6.4.1"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-six-6-4-1.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 6.4.1 </STRONG></NOBR></TD><TD  
>A hierarchy of some classes of problems.                                                                    </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>None of the inclusions is known to be proper. The relationship is proved below.
   <P ><STRONG>Theorem 6.4.1</STRONG> <A 
   NAME="70004-10002t6.4.1"> </A> 
<I>BPP</I> is included in <I>PSPACE</I>.<A NAME="70004-10003"> </A>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="70004-10004t"> </A> 
Consider any problem K in <I>BPP</I>. Let L denote the language that K induces. By the
definition of <I>BPP</I> there exists a bounded-error, polynomially time-bounded, probabilistic
Turing machine M<SUB>1</SUB> that accepts L. Let <FONT FACE="SYMBOL">e</FONT> &lt; 1/2 be a constant that bounds the error
probability of M<SUB>1</SUB>, and let p(n) be the time complexity of M<SUB>1</SUB>.
   <P >With no loss of generality it is assumed that M<SUB>1</SUB> has a constant k, such that in each
probabilistic move, M<SUB>1</SUB> has exactly k options. (Any probabilistic Turing machine can be
modified to have such a property, with k being the least common multiple of the number of
options in the different moves of the Turing machine.) In addition, it is assumed that M<SUB>1</SUB>
has some polynomial q(n), such that in each computation on each input x it makes exactly
q(|x|) probabilistic moves. Consequently, M<SUB>1</SUB> on each input x has exactly k<SUP>q(|x|)</SUP>
possible computations, with each computation having an equal probability of
occurring.
   <P >From M<SUB>1</SUB>, a deterministic Turing machine M<SUB>2</SUB> can be constructed to accept the
language L. M<SUB>2</SUB> relies on the following two properties of M<SUB>1</SUB>.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="70004-10005xa"> </A>If x is in L, then M<SUB>1</SUB> has at least probability 1-<FONT FACE="SYMBOL">e</FONT> &gt; 1/2 of having an accepting
     computation on input x.
     <LI><A 
   NAME="70004-10006xb"> </A>If x is not in L, then M<SUB>1</SUB> has at least probability 1 - <FONT FACE="SYMBOL">e</FONT> &gt; 1/2 of having a
     nonaccepting computation on input x.</OL>
On a given input x, M<SUB>2</SUB> determines which of the above properties holds, and accordingly
decides whether to accept or reject the input.
   <P >Given an input x, the Turing machine M<SUB>2</SUB> starts its computation by computing p(|x|).
Then one at a time, M<SUB>2</SUB> lists all the sequences of transition rules of M<SUB>1</SUB> whose lengths are
at most p(|x|). For each such sequence, M<SUB>2</SUB> checks whether the sequence corresponds to a
computation of M<SUB>1</SUB>. M<SUB>2</SUB> determines whether each computation of M<SUB>1</SUB> is accepting or
rejecting. In addition, M<SUB>2</SUB> counts the number m<SUB>a</SUB> of accepting computations, and the
number m<SUB>r</SUB> of nonaccepting computations.
   <P >M<SUB>2</SUB> accepts the input x if it determines that the probability m<SUB>a</SUB>/(m<SUB>a</SUB> + m<SUB>r</SUB>) of M<SUB>1</SUB>
accepting x is greater than 1/2, that is, if m<SUB>a</SUB> &gt; m<SUB>r</SUB>. M<SUB>2</SUB> rejects x if it determines that the
probability m<SUB>r</SUB>/(m<SUB>a</SUB> + m<SUB>r</SUB>) of M<SUB>1</SUB> rejecting x is greater than 1/2, that is, if m<SUB>r</SUB> &gt; m<SUB>a</SUB>. <IMG 
SRC="theory-bk-six40x.gif" ALT=" ***
" 
 >
   <P >
   <P >The nonprimality problem is an example of a problem in the class <I>RP</I> (see
Example <A 
 HREF="theory-bk-sixse2.html#70002-3001t6.2.1">6.2.1</A>). For <I>RP</I> the following result holds.
   <P ><STRONG>Theorem 6.4.2</STRONG> <A 
   NAME="70004-10007t6.4.2"> </A> 
<I>RP</I> is in <I>BPP</I> <FONT FACE="SYMBOL">Ç</FONT> <I>NP</I>.<A NAME="70004-10008"> </A>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="70004-10009t"> </A> 
Consider any problem K in <I>RP</I>. Let L be the language that K induces. By the definition of
<I>RP</I>, it follows that there exist a constant <FONT FACE="SYMBOL">e</FONT> &lt; 1, and a polynomially time-bounded Turing
machine M<SUB>1</SUB>, that satisfy the following conditions.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="70004-10010xa"> </A>If x is in L, then M<SUB>1</SUB> has a probability 1 - <FONT FACE="SYMBOL">e</FONT> &gt; 0 of having an accepting
     computation on x.
     <LI><A 
   NAME="70004-10011xb"> </A>If x is not in L, then M<SUB>1</SUB> has only nonaccepting computations on x.</OL>
L is accepted by a nondeterministic Turing machine M<SUB>2</SUB> similar to M<SUB>1</SUB> and of identical
time complexity. The only difference is that M<SUB>2</SUB> considers each probabilistic move of M<SUB>1</SUB>
as nondeterministic. Consequently, <I>RP</I> is in <I>NP</I>.
   <P >M<SUB>1</SUB> can also be simulated by a bounded-error probabilistic Turing machine M<SUB>3</SUB> of
similar time complexity. Specifically, let k be any constant such that <FONT FACE="SYMBOL">e</FONT><SUP>k</SUP> &lt; 1/2. Then M<SUB>3</SUB>
simulates k computations of M<SUB>1</SUB> on a given input x. M<SUB>3</SUB> accepts x if M<SUB>1</SUB> accepts x in any
of the simulated computations. Otherwise, M<SUB>3</SUB> rejects x. It follows that <I>RP</I> is also in <I>BPP</I>. <IMG 
SRC="theory-bk-six40x.gif" ALT="
*** " 
 >
   <P >
   <P >Finally, for <I>ZPP</I> the following result is shown.
   <P ><STRONG>Theorem 6.4.3</STRONG> <A 
   NAME="70004-10012t6.4.3"> </A> 
<I>ZPP</I> is contained in <I>RP</I>.<A NAME="70004-10013"> </A>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="70004-10014t"> </A> 
Consider any probabilistic Turing machine M<SUB>1</SUB> that has 0 error probability. Let <IMG 
SRC="theory-bk-six156x.gif" ALT="--
T">(n)
denote the expected time complexity of M<SUB>1</SUB>. Assume that <IMG 
SRC="theory-bk-six157x.gif" ALT="--
T">(n) is some polynomial in
n.
   <P >From M<SUB>1</SUB>, a probabilistic Turing machine M<SUB>2</SUB> of the following form can be
constructed. Given an input x, the probabilistic Turing machine M<SUB>2</SUB> starts its
computation by evaluating <IMG 
SRC="theory-bk-six158x.gif" ALT="--
T">(|x|). Then M<SUB>2</SUB> simulates c<IMG 
SRC="theory-bk-six159x.gif" ALT="--
T">(|x|) moves of M<SUB>1</SUB> on
input x for some constant c &gt; 1. M<SUB>2</SUB> halts in an accepting state if during the
simulation it reaches an accepting state of M<SUB>1</SUB>. Otherwise, M<SUB>2</SUB> halts in a nonaccepting
state.
   <P >By construction M<SUB>2</SUB> has no accepting computation on input x if x is not in L(M<SUB>1</SUB>). On
the other hand, if x is in L(M<SUB>1</SUB>), then M<SUB>2</SUB> halts in a nonaccepting state, with probability
equal to that of M<SUB>1</SUB> having an accepting computation that requires more than c<IMG 
SRC="theory-bk-six160x.gif" ALT="--
T">(|x|)
moves. That is, the error probability e(x) is equal to <FONT FACE="SYMBOL">å</FONT>
    <SUB> i=c<IMG 
SRC="theory-bk-six161x.gif" ALT="--
T">(|x|)+1</SUB><SUP><FONT FACE="SYMBOL">¥</FONT></SUP>p<SUB>i</SUB>, where p<SUB>i</SUB>
denotes the probability that, on x, M<SUB>1</SUB> will have a computation that takes exactly i
steps.
   <P >Now <CENTER>
<TABLE  
><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><IMG 
SRC="theory-bk-six162x.gif" ALT="--
T">(|x|)</TD>  <TD 
NOWRAP ALIGN="CENTER"  
> <FONT FACE="SYMBOL">³</FONT></TD>  <TD 
NOWRAP ALIGN="LEFT "  
><IMG 
SRC="theory-bk-six163x.gif" ALT="t">(x)</TD>                                                   <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>p<SUB>0</SUB> · 0 + p<SUB>1</SUB> · 1 + · · · + p<SUB>c<IMG 
SRC="theory-bk-six164x.gif" ALT="T-">(|x|)</SUB> · c<IMG 
SRC="theory-bk-six165x.gif" ALT="--
T">(|x|) + · · · </TD>                   <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> <FONT FACE="SYMBOL">³</FONT></TD>  <TD 
NOWRAP ALIGN="LEFT "  
>p<SUB>0</SUB> · 0 + p<SUB>1</SUB> · 1 + · · · + p<SUB>c<IMG 
SRC="theory-bk-six166x.gif" ALT="--
T">(|x|)</SUB> · c<IMG 
SRC="theory-bk-six167x.gif" ALT="T-">(|x|) + <IMG 
SRC="theory-bk-six168x.gif" ALT="(cT(|x| )+ 1)"ALIGN="MIDDLE" >·<FONT FACE="SYMBOL">å</FONT>
<SUB> i=c<IMG 
SRC="theory-bk-six169x.gif" ALT="--
T">(|x|)+1</SUB><SUP><FONT FACE="SYMBOL">¥</FONT></SUP>p<SUB>
i</SUB></TD><TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>p<SUB>0</SUB> · 0 + p<SUB>1</SUB> · 1 + · · · + p<SUB>c<IMG 
SRC="theory-bk-six170x.gif" ALT="--
T">(|x|)</SUB> · c<IMG 
SRC="theory-bk-six171x.gif" ALT="T-">(|x|) + (c<IMG 
SRC="theory-bk-six172x.gif" ALT="T-">(|x|) + 1)e(x)</TD>       <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
><IMG 
SRC="theory-bk-six173x.gif" ALT="(cT(|x| ) +1)"ALIGN="MIDDLE" > e(x) + · · ·</TD>                                   <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
</TR></TABLE>
</CENTER>Consequently, M<SUB>2</SUB> accepts x with probability <CENTER>
                   <TABLE  
><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
>1 - e(x)</TD>  <TD 
NOWRAP ALIGN="CENTER"  
> <FONT FACE="SYMBOL">³</FONT></TD>  <TD 
NOWRAP ALIGN="LEFT "  
>1 - <IMG 
SRC="theory-bk-six174x.gif" ALT="  T-(| x|)
----------
cT (| x|)+ 1"></TD>                   <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> <FONT FACE="SYMBOL">³</FONT></TD>  <TD 
NOWRAP ALIGN="LEFT "  
>1 - 1/c</TD>                          <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
</TR></TABLE>
</CENTER>                                                              <IMG 
SRC="theory-bk-six175x.gif" ALT="PICT" ><P >
   <P >
   <P >[<A 
 HREF="theory-bk-sixli1.html" >next</A>] [<A 
 HREF="theory-bk-sixse3.html" >prev</A>] [<A 
 HREF="theory-bk-sixse3.html#tailtheory-bk-sixse3.html" >prev-tail</A>] [<A 
 HREF="theory-bk-sixse4.html" >front</A>] [<A 
 HREF="theory-bk-six.html#theory-bk-sixse4.html" >up</A>] <A 
   NAME="tailtheory-bk-sixse4.html"> </A></BODY></HTML>