
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-three.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-threeli1.html" >next</A>] [<A 
 HREF="theory-bk-threese5.html" >prev</A>] [<A 
 HREF="theory-bk-threese5.html#tailtheory-bk-threese5.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-threese6.html">tail</A>] [<A 
 HREF="theory-bk-three.html#theory-bk-threese6.html" >up</A>]
<H3>3.6 <A 
   NAME="40006-290003.6"> </A><A 
 HREF="theory-bk.html#Q2-40006-29"  NAME="Q1-40006-29">Decidable Properties for Recursive Finite-Domain Programs</A></H3>
   <P >
<A NAME="40006-29001"> </A>
   <P >The first theorem of this section provides a generalization of the decidability of the
emptiness problem for finite-state automata. <A NAME="40006-29002"> </A>
   <P ><STRONG>Theorem 3.6.1</STRONG> <A 
   NAME="40006-29003t3.6.1"> </A> 
The emptiness problem is decidable for pushdown automata.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="40006-29004t"> </A> 
Consider any pushdown automaton M<SUB>1</SUB> = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">G</FONT>, <FONT FACE="SYMBOL">d</FONT><SUB>1</SUB>, q<SUB>0</SUB>, Z<SUB>0</SUB>, F&gt;. Let c be a new
symbol not in <FONT FACE="SYMBOL">S</FONT>. Let <FONT FACE="SYMBOL">d</FONT><SUB>2</SUB> be <FONT FACE="SYMBOL">d</FONT><SUB>1</SUB> with each transition rule of the form (q, <FONT FACE="SYMBOL">e</FONT>, <FONT FACE="SYMBOL">b</FONT>, p, <FONT FACE="SYMBOL">g</FONT>) being
replaced with a transition rule of the form (q, c, <FONT FACE="SYMBOL">b</FONT>, p, <FONT FACE="SYMBOL">g</FONT>). Let M<SUB>2</SUB> be the pushdown
automaton &lt;Q, <FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> {c}, <FONT FACE="SYMBOL">G</FONT>, <FONT FACE="SYMBOL">d</FONT><SUB>2</SUB>, q<SUB>0</SUB>, Z<SUB>0</SUB>, F&gt;.
   <P >Intuitively, we see that M<SUB>2</SUB> is the pushdown automaton M<SUB>1</SUB> modified to read the
symbol c whenever M<SUB>1</SUB> is to make a move that reads no input symbol. By construction,
M<SUB>1</SUB> can reach configuration (uqv, w) in t moves if and only if there exists u<SUB>c</SUB> such that
M<SUB>2</SUB> can reach configuration (u<SUB>c</SUB>qv, w) in t moves, where u<SUB>c</SUB> is a string obtained
from u by insertion of some c's and |u<SUB>c</SUB>| = t. Thus, T(M<SUB>1</SUB>) = Ø if and only if
T(M<SUB>2</SUB>) = Ø.
   <P >Denote m as the constant that the pumping lemma for context-free languages implies
for L(M<SUB>2</SUB>). The shortest string x in L(M<SUB>2</SUB>) cannot be longer than m. Otherwise, a
contradiction would arise because by the pumping lemma if x is in L(M<SUB>2</SUB>) and if its length
is at least m, then a shorter string is also in L(M<SUB>2</SUB>).
   <P >On input x the pushdown automaton M<SUB>2</SUB> can have at most |x| moves. Consequently,
the emptiness of L(M<SUB>2</SUB>) or, equivalently, of L(M<SUB>1</SUB>) can be checked by considering all the
possible execution sequences of M<SUB>2</SUB> or, equivalently, of M<SUB>1</SUB> that consist of no more than
m moves. <IMG 
SRC="theory-bk-three1x.gif" ALT=" *** " 
 >
   <P >
   <P >The decidability of the emptiness problem for pushdown automata can be used for
showing the decidability of some problems for finite-state<A NAME="40006-29005"> </A><A NAME="40006-29006"> </A> transducers. One such example
is the decidability of the equivalence<A NAME="40006-29007"> </A> problem for deterministic finite-state transducers. For
the general class of finite-state transducers as well as the class of pushdown automata the
problem is undecidable (Corollary <A 
 HREF="theory-bk-fourse7.html#50007-24001t4.7.1">4.7.1</A> and Corollary <A 
 HREF="theory-bk-fourse7.html#50007-24006t4.7.2">4.7.2</A>, respectively). On the other
hand, for deterministic pushdown automata and for deterministic pushdown transducers
the problem is open.
   <P ><STRONG>Corollary 3.6.1</STRONG> <A 
   NAME="40006-29008t3.6.1"> </A> 
The equivalence problem is decidable for deterministic finite-state transducers.<A NAME="40006-29009"> </A>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="40006-29010t"> </A> 
Consider any two deterministic finite-state transducers M<SUB>1</SUB> and M<SUB>2</SUB>. From M<SUB>1</SUB> and M<SUB>2</SUB> a
finite-state automaton M<SUB>3</SUB> can be constructed such that M<SUB>3</SUB> accepts the empty
set if and only if L(M<SUB>1</SUB>) = L(M<SUB>2</SUB>). The construction can be as in the proof of
Theorem <A 
 HREF="theory-bk-twose6.html#30006-22017t2.6.4">2.6.4</A>.
   <P >On the other hand, one can also construct from M<SUB>1</SUB> and M<SUB>2</SUB> a pushdown automaton
M<SUB>4</SUB> that accepts a given input if and only if both M<SUB>1</SUB> and M<SUB>2</SUB> accept it, while providing
different outputs. That is, M<SUB>4</SUB> accepts the empty set if and only if M<SUB>1</SUB> and M<SUB>2</SUB> agree in
their outputs on the inputs that they both accept.
   <P >A computation of M<SUB>4</SUB> on a given input consists of simulating in parallel, as in the
proof of Theorem <A 
 HREF="theory-bk-threese5.html#40005-24008t3.5.1">3.5.1</A>, the computations of M<SUB>1</SUB> and M<SUB>2</SUB> on such an input. The simulation
is in accordance with either of the following cases, where the choice is made
nondeterministically.
    <DL><DT><STRONG>
 <STRONG>Case 1</STRONG> </STRONG><DD 
>M<SUB>4</SUB> simulates accepting computations of M<SUB>1</SUB> and M<SUB>2</SUB> that provide outputs
    of different lengths. During the simulation, M<SUB>4</SUB> ignores the outputs of M<SUB>1</SUB> and
    M<SUB>2</SUB>. However, at each instant of the simulation, the pushdown store of M<SUB>4</SUB>
    holds the absolute value of the difference between the length of the outputs
    produced so far by M<SUB>1</SUB> and M<SUB>2</SUB>. M<SUB>4</SUB> accepts the input if and only if it reaches
    accepting  states  of  M<SUB>1</SUB>  and  M<SUB>2</SUB>  at  the  end  of  the  input,  with  a  nonempty
    pushdown store.
    <DT><STRONG>
 <STRONG>Case 2</STRONG> </STRONG><DD 
>M<SUB>4</SUB> simulates accepting computations of M<SUB>1</SUB> and M<SUB>2</SUB> that provide outputs
    differing in their <I>j</I>th symbol, for some j that is no greater than their lengths.
    The  simulation  is  similar  to  that  in  Case  1.  The  main  difference  is  that  M<SUB>4</SUB>
    records in the pushdown store the changes in the length of the output of M<SUB>i</SUB>
    only until it establishes (nondeterministically) that M<SUB>i</SUB> reached its <I>j</I>th output
    symbol,  i  =  1, 2.  In  addition,  M<SUB>4</SUB> records  in  its  finite-state  control  the  <I>j</I>th
    output symbols of M<SUB>1</SUB> and M<SUB>2</SUB>. Upon completing the simulation, M<SUB>4</SUB> accepts
    the input if and only if its pushdown is empty and the recorded symbols in the
    finite-state control are distinct.</DL>
Given M<SUB>3</SUB> and M<SUB>4</SUB>, a pushdown automaton M<SUB>5</SUB> can then be constructed to accept
L(M<SUB>3</SUB>) <FONT FACE="SYMBOL">È</FONT> L(M<SUB>4</SUB>). M<SUB>5</SUB> accepts the empty set if and only if M<SUB>1</SUB> and M<SUB>2</SUB> are equivalent. The
result thus follows from Theorem <A 
 HREF="#40006-29003t3.6.1">3.6.1</A>. <IMG 
SRC="theory-bk-three1x.gif" ALT=" *** " 
 >
   <P >
   <P >The uniform halting problem is undecidable for pushdown automata (Corollary <A 
 HREF="theory-bk-fourse7.html#50007-24010t4.7.3">4.7.3</A>).
However, the decidability of the emptiness problem for<A NAME="40006-29011"> </A> pushdown automata can be used to
show the decidability of the uniform halting problem for deterministic pushdown
automata.
   <P ><STRONG>Theorem 3.6.2</STRONG> <A 
   NAME="40006-29012t3.6.2"> </A> 
The uniform halting problem is decidable for deterministic pushdown automata.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="40006-29013t"> </A> 
Consider any deterministic pushdown automaton M<SUB>1</SUB>. From M<SUB>1</SUB> a deterministic pushdown
automaton M<SUB>2</SUB>, similar to that in the proof of Lemma <A 
 HREF="theory-bk-threese5.html#40005-24016t3.5.1">3.5.1</A>, can be constructed. The only
difference is that here M<SUB>2</SUB> accepts a given input if and only if it determines that M<SUB>1</SUB>
reaches a simple loop. By construction, M<SUB>2</SUB> accepts an empty set if and only if M<SUB>1</SUB> halts
on all inputs. <IMG 
SRC="theory-bk-three1x.gif" ALT=" *** " 
 >
   <P >
   <P >The proof of the last theorem fails for nondeterministic pushdown automata because
accepting computations of nondeterministic pushdown automata can include simple loops,
without being forced to enter an infinite loop.
   <P ><STRONG>Theorem 3.6.3</STRONG> <A 
   NAME="40006-29014t3.6.3"> </A> 
The halting problem is decidable for pushdown automata.<A NAME="40006-29015"> </A>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="40006-29016t"> </A> 
Consider any pair (M, x) of a pushdown automaton M and of an input x for M. From x,
a finite-state automaton M<SUB>x</SUB> can be constructed that accepts only the input x.
However, from M, a pushdown automaton M<SUB>1</SUB> can be constructed to accept
a given input if and only if M has a sequence of transition rules that leads M
to a simple loop on the input. The construction can be similar to the proof of
Theorem <A 
 HREF="#40006-29012t3.6.2">3.6.2</A>.
   <P >From M and M<SUB>x</SUB>, a pushdown automaton M<SUB>a,x</SUB> can be constructed that accepts the
intersection of L(M) with L(M<SUB>x</SUB>) (see Theorem <A 
 HREF="theory-bk-threese5.html#40005-24008t3.5.1">3.5.1</A>). By construction, M<SUB>a,x</SUB> accepts a
nonempty set if and only if M accepts x. By Theorem <A 
 HREF="#40006-29003t3.6.1">3.6.1</A> it can be determined if M<SUB>a,x</SUB>
accepts a nonempty set. If so, then M is determined to halt on input x. Otherwise, in a
similar way, a pushdown automaton M<SUB>1,x</SUB> can be constructed to accept the intersection of
L(M<SUB>1</SUB>) and L(M<SUB>x</SUB>). By construction, M<SUB>1,x</SUB> accepts the empty set if and only if M has
only halting computations on input x. The result then follows from Theorem <A 
 HREF="#40006-29003t3.6.1">3.6.1</A>. <A NAME="40006-29017"> </A><IMG 
SRC="theory-bk-three1x.gif" ALT=" ***
" 
 >
   <P >
<A NAME="40006-29018"> </A>
   <P >
   <P >[<A 
 HREF="theory-bk-threeli1.html" >next</A>] [<A 
 HREF="theory-bk-threese5.html" >prev</A>] [<A 
 HREF="theory-bk-threese5.html#tailtheory-bk-threese5.html" >prev-tail</A>] [<A 
 HREF="theory-bk-threese6.html" >front</A>] [<A 
 HREF="theory-bk-three.html#theory-bk-threese6.html" >up</A>] <A 
   NAME="tailtheory-bk-threese6.html"> </A></BODY></HTML>