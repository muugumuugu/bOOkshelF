<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-three.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-threese2.html" >next</A>] [<A 
 HREF="#tailtheory-bk-threese1.html">tail</A>] [<A 
 HREF="theory-bk-three.html#theory-bk-threese1.html" >up</A>]
<H3>3.1 <A 
   NAME="40001-20003.1"> </A><A 
 HREF="theory-bk.html#Q2-40001-2"  NAME="Q1-40001-2">Recursion</A></H3>
   <P >
<A NAME="40001-2001"> </A>
   <P >The task of programming is in many cases easier when recursion is allowed. However,
although recursion does not in general increase the set of functions that the programs
can compute, in the specific case of finite-domain programs such an increase is
achieved.
   <P >Here recursion is introduced to programs by
     <OL TYPE="a" 
>
     <LI><A 
   NAME="40001-2002xa"> </A>Pseudoinstructions  of  the  following  form.  These  are  used  for  defining
     procedures.  Each  list  of  formal  parameters  consists  of  variable  names  that
     are all distinct, and each procedure body consists of an arbitrary sequence of
     instructions.
<P >
         <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>procedure</B> &lt;procedure name&gt; (&lt;list of formal parameters&gt;)
    &lt;procedure body&gt;
<B>end</B>                                                                                             </PRE></TD></TR></TABLE>
     <LI><A 
   NAME="40001-2003xb"> </A>Call  instructions  of  the  following  form.  These  are  used  for  activating  the
     execution of procedures. Each list of actual parameters is equal in size to the
     corresponding list of formal parameters, and it consists of variable names that
     are all distinct.
<P >
         <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>call</B> &lt;procedure name&gt;(&lt;list of actual parameters&gt;) </PRE></TD></TR></TABLE>
     <LI><A 
   NAME="40001-2004xc"> </A>Return  instructions  of  the  following  form.  These  are  used  for  deactivating
     the execution of procedures. The instructions are restricted to appearing only
     inside procedure bodies.
<P >
         <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>return</B> </PRE></TD></TR></TABLE>
     </OL>
   <P >
Finite-domain programs that allow recursion are called <I>recursive<A NAME="40001-2005"> </A> finite-domain
programs</I>.
   <P >An execution of a call instruction activates the execution of the procedure that
is invoked. The activation consists of copying the values from the variables in
the list of actual parameters to the corresponding variables in the list of formal
parameters, and of transferring the control to the first instruction in the body of the
procedure.
   <P >An execution of a return instruction causes the deactivation of the last of those
activations of the procedures that are still in effect. The deactivation causes the transfer of
control to the instruction immediately following the call instruction that was responsible
for this last activation. Upon the transfer of control, the values from the variables in the
list of formal parameters are copied to the corresponding variables in the list of
actual parameters. In addition, the variables that do not appear in the list of actual
parameters are restored to their values just as before the call instruction was
executed.
   <P >All the variables of a program are assumed to be recognized throughout the full scope
of the program, and each of them is allowed to appear in an arbitrary number of lists of
formal and actual variables.
   <P >Any attempt to enter or leave a procedure without using a call instruction or a return
instruction, respectively, causes the program to abort execution in a rejecting
configuration.
   <P >In what follows, each call instruction and each return instruction is considered to be an
instruction segment.
   <P ><STRONG>Example 3.1.1</STRONG> <A 
   NAME="40001-2006t3.1.1"> </A> 
Let P be the recursive finite-domain program in Figure <A 
 HREF="#40001-2007r3.1.1">3.1.1</A>. The variables are assumed to
have the domain {0, 1}, with 0 as initial value. The program P accepts exactly those inputs
in which the number of 0's is equal to the number of 1's. On each such input the
program outputs those input values that are preceded by the same number of 0's as
1's.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="40001-2007r3.1.1"> </A>
                 <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>do</B>                                             /* I<SUB>1</SUB>  */
    <B>if</B> <I>eof</I> <B>then accept</B>                /* I<SUB>2</SUB>  */
    <B>read</B> <TT>x</TT>                                   /* I<SUB>3</SUB>  */
    <B>write</B> <TT>x</TT>                                  /* I<SUB>4</SUB>  */
    <B>call</B> RP(<TT>x</TT>)                             /* I<SUB>5</SUB>  */
<B>until</B> false                       /* I<SUB>6</SUB>  */
<B>procedure</B> RP(<TT>y</TT>)
    <B>do</B>                                         /* I<SUB>7</SUB>  */
        <B>read</B> <TT>z</TT>                               /* I<SUB>8</SUB>  */
        <B>if</B> <TT>z</TT><IMG 
SRC="theory-bk-three0x.gif" ALT="/="ALIGN="MIDDLE" > <TT>y</TT> <B>then</B>                    /* I<SUB>9</SUB>  */
            <B>return</B>                           /* I<SUB>10</SUB> */
        <B>call</B> RP(<TT>z</TT>)                         /* I<SUB>11</SUB> */
    <B>until</B> false                    /* I<SUB>12</SUB> */
<B>end</B>                                                         </PRE></TD></TR></TABLE>
<A 
   NAME="40001-2007r3.1.1"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 3.1.1 </STRONG></NOBR></TD><TD  
>A recursive finite-domain program.                                                                             </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >On input 00111001 the program starts by reading the first input value 0 in I<SUB>3</SUB>, writing 0
in I<SUB>4</SUB>, and transferring the control to RP in I<SUB>5</SUB>. Upon entering RP <TT>x</TT> = <TT>y</TT> = <TT>z</TT> = 0. In RP the
program uses instruction segment I<SUB>8</SUB> to read the second input value 0, and then it calls RP
recursively in I<SUB>11</SUB>.
   <P >The embedded activation of RP reads the first 1 in the input and then executes the
return instruction, to resume in I<SUB>12</SUB> with <TT>x</TT> = <TT>y</TT> = <TT>z</TT> = 0 the execution of the first
activation of RP. The procedure continues by reading the second 1 of the input
into <TT>z</TT>, and then returns to resume the execution of the main program in I<SUB>6</SUB> with
<TT>x</TT> = <TT>y</TT> = <TT>z</TT> = 0. The main program reads 1 into <TT>x</TT>, prints out that value, and invokes
RP.
   <P >Upon entering RP <TT>x</TT> = <TT>y</TT> = 1 and <TT>z</TT> = 0. The procedure reads 0 and then returns the
control to the main program. The main program reads into <TT>x</TT> the last 0 of the
input, prints the value out, and calls RP again. RP reads the last input value and
returns the control to the main program, where the computation is terminated at
I<SUB>2</SUB>.
   <P >The table in Figure <A 
 HREF="#40001-2008r3.1.2">3.1.2</A> shows the flow of data upon the activation and deactivation of
RP. <IMG 
SRC="theory-bk-three1x.gif" ALT=" *** ">
   <P >
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="40001-2008r3.1.2"> </A><A 
   NAME="40001-2009r3.1.3"> </A>
<A 
   NAME="40001-2008r3.1.2"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-three-3-1-2.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 3.1.2 </STRONG></NOBR></TD><TD  
>Flow of data in the program of Figure <A 
 HREF="#40001-2007r3.1.1">3.1.1</A> on input 00111001.                                 </TD></TR></TABLE></CENTER>
               <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>call</B> RP(<TT>parity</TT>)
<B>if</B> <TT>parity</TT> = 0 <B>then</B>
    <B>if</B> <I>eof</I> <B>then accept</B>
<B>reject</B>
<B>procedure</B> RP(<TT>parity</TT>)
    <B>do</B>        /* Process the next symbol in w. */
        <B>read</B> <TT>x</TT>
        <B>write</B> <TT>x</TT>
        <TT>parity</TT> := 1 - <TT>parity</TT>
        <B>call</B> RP(<TT>parity</TT>)
    <B>or</B>                 /* Leave w and go to w<SUP>rev</SUP>. */
        <B>return</B>
    <B>until</B> true
   /* Process the next symbol in w<SUP>rev</SUP>. */
    <B>read</B> y
   <B>if</B> <TT>y</TT><IMG 
SRC="theory-bk-three2x.gif" ALT="/="ALIGN="MIDDLE" > <TT>x</TT> <B>then</B> <B>reject</B>
    <B>return</B>
<B>end</B>                                                                  </PRE></TD></TR></TABLE>
<A 
   NAME="40001-2009r3.1.3"> </A>
    <TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 3.1.3 </STRONG></NOBR></TD><TD  
>A recursive finite-domain program.                                                                             </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >The definition given here for recursion is not standard, but can be shown to be
equivalent to standard definitions. The sole motivation for choosing the nonstandard
definition is because it simplifies the notion of states of recursive programs. The
convention that the variables of a program are recognizable throughout the full scope of
the program is introduced to allow uniformity in the definition of states. The convention --
that upon the execution of a return instruction the variables that do not appear in the list of
actual parameters are restored to their values just before the execution of the
corresponding call instructions -- is introduced to show a resemblance to the notion of
local variables in procedures.<A NAME="40001-2010"> </A>
   <P ><STRONG>Example 3.1.2</STRONG> <A 
   NAME="40001-2011t3.1.2"> </A> 
The recursive finite-domain program in Figure <A 
 HREF="#40001-2009r3.1.3">3.1.3</A> computes the relation { (ww<SUP>rev</SUP>, w) | w is
a string of even length in {0, 1}* }. The domain of the variables is assumed to equal
{0, 1}, with 0 as initial value. On input 00111100 the program has a unique computation
that gives the output 0011. The program makes five calls to the procedure RP
while reading 0011. Then it proceeds with five returns while reading 1100. <IMG 
SRC="theory-bk-three1x.gif" ALT=" ***
" 
 >
   <P >
   <P >It turns out that an approach similar to the one used for studying finite-memory
programs can also be used for studying recursive finite-domain programs. The main
difference between the two cases is in the complexity of the argumentation.
   <P >Moreover, as in the case of finite-memory programs, it should be emphasized here that
recursive finite-domain programs are important not only as a vehicle for investigating the
general class of programs but also on their own merits. For instance, in many compilers the
syntax analyzers are basically designed as recursive finite-domain programs. (The central
task of a syntax analyzer is to group together, according to some grammatical
rules, the tokens in the program that is compiled. Such a grouping enables the
compiler to detect the structure of the program, and therefore to generate the object
code.)<A NAME="40001-2012"> </A>
   <P >
   <P >[<A 
 HREF="theory-bk-threese2.html" >next</A>] [<A 
 HREF="theory-bk-threese1.html" >front</A>] [<A 
 HREF="theory-bk-three.html#theory-bk-threese1.html" >up</A>] <A 
   NAME="tailtheory-bk-threese1.html"> </A></BODY></HTML>