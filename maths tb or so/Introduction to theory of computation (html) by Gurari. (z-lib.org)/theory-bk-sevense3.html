
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-seven.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-sevense4.html" >next</A>] [<A 
 HREF="theory-bk-sevense2.html" >prev</A>] [<A 
 HREF="theory-bk-sevense2.html#tailtheory-bk-sevense2.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-sevense3.html">tail</A>] [<A 
 HREF="theory-bk-seven.html#theory-bk-sevense3.html" >up</A>]
<H3>7.3 <A 
   NAME="80003-40007.3"> </A><A 
 HREF="theory-bk.html#Q2-80003-4"  NAME="Q1-80003-4">Circuits</A></H3>
   <P >
      <A 
 HREF="#Q1-80003-5"  NAME="Q2-80003-5">Families of Circuits</A>
<BR>         <A 
 HREF="#Q1-80003-6"  NAME="Q2-80003-6">Representation of Circuits</A>
   <P >Many abstract models of parallel machines have been offered in the literature, besides
those of PRAM's. However, unlike the case for the abstract models of sequential
machines, there is no obvious way for relating the different abstract models of parallel
machines. Therefore, the lowest common denominator of such models, that is, their
hardware representations, seems a natural choice for analyzing the models for the
resources that they require.
   <P >Here the representations are considered in terms of undirected acyclic graphs, called
<I>combinatorial<A NAME="80003-4001"> </A> Boolean circuits</I> or simply <I>circuits</I>. Each node in a circuit is assumed to
have an indegree no greater than 2, and an outdegree of unbounded value. Each node of
indegree 0 is labeled either with a variable name, with the constant 0, or with
the constant 1. Each node of indegree 1 is labeled with the Boolean function
¬. Each node of indegree 2 is labeled either with the Boolean functions <FONT FACE="SYMBOL">Ù</FONT> or
<FONT FACE="SYMBOL">Ú</FONT>.
   <P >Each node of indegree greater than 0 is called a <I>gate</I>.<A NAME="80003-4002"> </A> A gate is said to be a <I>NOT<A NAME="80003-4003"> </A> gate</I> if
it is labeled with ¬, an <I>AND<A NAME="80003-4004"> </A> gate</I> if labeled with <FONT FACE="SYMBOL">Ù</FONT>, and an <I>OR<A NAME="80003-4005"> </A> gate</I> if labeled with <FONT FACE="SYMBOL">Ú</FONT>. Nodes
labeled with variable names are called <I>input<A NAME="80003-4006"> </A> nodes</I>. Nodes of outdegree 0 are called <I>output<A NAME="80003-4007"> </A>
nodes</I>. A node labeled with 0 is called a <I>constant node 0</I>.<A NAME="80003-4008"> </A> A node labeled with 1 is called a
<I>constant node 1</I>.
   <P >A circuit c that has n input nodes and m output nodes <I>computes<A NAME="80003-4009"> </A> a function</I>
f: {0, 1}<SUP>n</SUP> <FONT FACE="SYMBOL">®</FONT> {0, 1}<SUP>m</SUP> in the obvious way.
   <P ><STRONG>Example 7.3.1</STRONG> <A 
   NAME="80003-4010t7.3.1"> </A> 
The circuit in Figure <A 
 HREF="#80003-4011r7.3.1">7.3.1</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="80003-4011r7.3.1"> </A>
<A 
   NAME="80003-4011r7.3.1"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-seven-7-3-1.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 7.3.1 </STRONG></NOBR></TD><TD  
>Parity checker.                                                                                                              </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>has 7 × 4 + 8 + 1 = 37 nodes, of which 8 are input nodes and 1 is an output
node.
   <P >The circuit computes the parity function for n = 8 input values. The circuit provides
the output of 0 for the case where a<SUB>1</SUB> · · · a<SUB>8</SUB> has an odd number of 1's. The circuit
provides the output of 1 for the case where a<SUB>1</SUB> · · · a<SUB>8</SUB> has an even number of
1's.
   <P >The circuit's strategy relies on the following two observations.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="80003-4012xa"> </A>The parity function does not change its value when a 0 is removed from its
     input string.
     <LI><A 
   NAME="80003-4013xb"> </A>The parity function does not change its value if a pair of 1's is replaced with
     a 0 in its input string.</OL>
Each group XOR<A NAME="80003-4014"> </A> of gates outputs 1 if its input values are not equal, and 0 if its input values
are equal. Each level of XOR's in the circuit reduces the size of the given input by half. <IMG 
SRC="theory-bk-seven15x.gif" ALT=" ***
" 
 >
   <P >
   <P ><STRONG>Example 7.3.2</STRONG> <A 
   NAME="80003-4015t7.3.2"> </A> 
The circuit in Figure <A 
 HREF="#80003-4016r7.3.2">7.3.2</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="80003-4016r7.3.2"> </A>
<A 
   NAME="80003-4016r7.3.2"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-seven-7-3-2.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 7.3.2 </STRONG></NOBR></TD><TD  
>Adder.                                                                                                                           </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>is an adder that computes the sum d = a + b.  d<SUB>0</SUB> · · · d<SUB>n/2</SUB>, a<SUB>1</SUB> · · · a<SUB>n/2</SUB>, and b<SUB>1</SUB> · · · b<SUB>n/2</SUB> are
assumed to be the binary representations of d, a, and b, respectively. Each LOCAL ADDER in
the circuit has an input that consists of two corresponding bits of a and b, as well as a carry
from the previous LOCAL ADDER. The output of each LOCAL ADDER is the corresponding
bit in d, as well as a new carry to be passed on to the next LOCAL ADDER. <IMG 
SRC="theory-bk-seven15x.gif" ALT=" ***
" 
 >
   <P >
   <P >The <I>size</I><A NAME="80003-4017"> </A> of a circuit is the number of gates in it. The <I>depth</I><A NAME="80003-4018"> </A> of a circuit is the number of
gates in the longest path from an input node to an output node.
   <P ><STRONG>Example 7.3.3</STRONG> <A 
   NAME="80003-4019t7.3.3"> </A> 
In the circuit of Figure <A 
 HREF="#80003-4011r7.3.1">7.3.1</A> each XOR has size 4 and depth 3. The whole circuit has size 29
and depth 10.
   <P >In the circuit of Figure <A 
 HREF="#80003-4016r7.3.2">7.3.2</A> each LOCAL ADDER has size 11 and depth 6. The whole
circuit has size 11n/2 and depth 5 + 2(n/2 - 2) + 3 = n + 4. <IMG 
SRC="theory-bk-seven15x.gif" ALT=" *** " 
 >
   <P >
   <P ><EM><A 
   NAME="80003-5000"> </A><A 
 HREF="#Q2-80003-5"  NAME="Q1-80003-5">Families of Circuits</A></EM>
   <P >C = (c<SUB>0</SUB>, c<SUB>1</SUB>, c<SUB>2</SUB>,<FONT FACE="SYMBOL"> ¼</FONT> ) is said to be a <I>family<A NAME="80003-5001"> </A> of circuits</I> if c<SUB>n</SUB> is a circuit with n input nodes
for each n <FONT FACE="SYMBOL">³</FONT> 0. A family C = (c<SUB>0</SUB>, c<SUB>1</SUB>, c<SUB>2</SUB>,<FONT FACE="SYMBOL"> ¼</FONT> ) of circuits is said to have <I>size<A NAME="80003-5002"> </A> complexity</I> Z(n)
if Z(n) <FONT FACE="SYMBOL">³</FONT> (size of c<SUB>n</SUB>) for all n <FONT FACE="SYMBOL">³</FONT> 0. The family is said to have <I>depth<A NAME="80003-5003"> </A> complexity</I> D(n) if
D(n) <FONT FACE="SYMBOL">³</FONT> (depth of c<SUB>n</SUB>) for all n <FONT FACE="SYMBOL">³</FONT> 0.
   <P >A family C = (c<SUB>0</SUB>, c<SUB>1</SUB>, c<SUB>2</SUB>,<FONT FACE="SYMBOL"> ¼</FONT> ) of circuits is said to <I>compute<A NAME="80003-5004"> </A></I> a given function
f: {0, 1}* <FONT FACE="SYMBOL">®</FONT> {0, 1}* if for each n <FONT FACE="SYMBOL">³</FONT> 0 the circuit c<SUB>n</SUB> computes the function
f<SUB>n</SUB>: {0, 1}<SUP>n</SUP> <FONT FACE="SYMBOL">®</FONT> {0, 1}<SUP>k</SUP> for some k <FONT FACE="SYMBOL">³</FONT> 0 that depends on n. f<SUB>n</SUB> is assumed to be a function
that satisfies f<SUB>n</SUB>(x) = f(x) for each x in {0, 1}<SUP>n</SUP>.
   <P >A function f is said to be of <I>size<A NAME="80003-5005"> </A> complexity</I> Z(n) if it is computable by a family of
circuits of size complexity Z(n). The function f is said to have <I>depth<A NAME="80003-5006"> </A> complexity</I> D(n) if
it is computable by a family of circuits with depth complexity D(n).
   <P >A family C = (c<SUB>0</SUB>, c<SUB>1</SUB>, c<SUB>2</SUB>,<FONT FACE="SYMBOL"> ¼</FONT> ) of circuits is said to <I>decide<A NAME="80003-5007"> </A> a language</I> L in {0, 1}* if the
characteristic function of L is computable by C. (f is the characteristic function of L if
f(x) = 1 for each x in L, and f(x) = 0 for each x not in L.) The size and depth
complexities of a language are the size and depth complexities of its characteristic
function.
   <P ><STRONG>Example 7.3.4</STRONG> <A 
   NAME="80003-5008t7.3.4"> </A> 
The language { a<SUB>1</SUB> · · · a<SUB>n</SUB>  | a<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , a<SUB>n</SUB> are in {0, 1}, and a<SUB>1</SUB> · · · a<SUB>n</SUB> has an even number of 1's }
is decidable by a family of circuits similar to the circuit in Figure <A 
 HREF="#80003-4011r7.3.1">7.3.1</A>. The language has
depth complexity O(log n), and size complexity O(n/2 + n/4 + · · · + 1) = O(n). <IMG 
SRC="theory-bk-seven15x.gif" ALT=" ***
" 
 >
   <P >
   <P ><EM><A 
   NAME="80003-6000"> </A><A 
 HREF="#Q2-80003-6"  NAME="Q1-80003-6">Representation of Circuits</A></EM>
<A NAME="80003-6001"> </A>
   <P >In what follows, we will assume that each circuit c has a representation of the
following form. Associate the number 0 with each constant node 0 in c, the number 1 with
each constant node 1 in c, and the numbers 2, <FONT FACE="SYMBOL">¼</FONT> , n + 1 with the n input nodes of c. Associate
consecutive numbers starting at n + 2, with each of c's gates. Then a representation of c is
a string of the form E(u<SUB>1</SUB>) · · · E(u<SUB>m</SUB>)F(v<SUB>1</SUB>) · · · F(v<SUB>k</SUB>).
   <P >u<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , u<SUB>m</SUB> are the gates of c, and v<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , v<SUB>k</SUB> are the output nodes. E(u) is equal to
(g, t, g<SUB>L</SUB>, g<SUB>R</SUB>), where g is the number assigned to gate u, t is the type of u in {¬, <FONT FACE="SYMBOL">Ú</FONT>, <FONT FACE="SYMBOL">Ù</FONT>}, and
g<SUB>L</SUB> and g<SUB>R</SUB> are the numbers assigned to the immediate predecessors of u. In particular,
g<SUB>L</SUB> = g<SUB>R</SUB> when t = ¬. F(v) is equal to (g), where g is the number assigned to gate
v.
   <P ><STRONG>Example 7.3.5</STRONG> <A 
   NAME="80003-6002t7.3.5"> </A> 
Figure <A 
 HREF="#80003-6003r7.3.3">7.3.3</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="80003-6003r7.3.3"> </A>
<A 
   NAME="80003-6003r7.3.3"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-seven-7-3-3.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 7.3.3 </STRONG></NOBR></TD><TD  
>A circuit with enumerated nodes.                                                                                </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>provides a circuit whose nodes are enumerated. The circuit has the following
representation.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-seven36x.gif" ALT=" (4,¬,2,2)(5,Ù ,1,4)(6,Ù ,1,3)(7,Ù ,2,1)(8,Ù,3,1)(9,Ù,5,6)(10,Ù,7,8)(11,Ú,9,10)(11)"></PRE></CENTER>
   <P >
<A NAME="80003-6004"> </A>
   <P >
   <P >[<A 
 HREF="theory-bk-sevense4.html" >next</A>] [<A 
 HREF="theory-bk-sevense2.html" >prev</A>] [<A 
 HREF="theory-bk-sevense2.html#tailtheory-bk-sevense2.html" >prev-tail</A>] [<A 
 HREF="theory-bk-sevense3.html" >front</A>] [<A 
 HREF="theory-bk-seven.html#theory-bk-sevense3.html" >up</A>] <A 
   NAME="tailtheory-bk-sevense3.html"> </A></BODY></HTML>