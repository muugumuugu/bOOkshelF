
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-seven.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-sevenli1.html" >next</A>] [<A 
 HREF="theory-bk-sevense5.html" >prev</A>] [<A 
 HREF="theory-bk-sevense5.html#tailtheory-bk-sevense5.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-sevense6.html">tail</A>] [<A 
 HREF="theory-bk-seven.html#theory-bk-sevense6.html" >up</A>]
<H3>7.6 <A 
   NAME="80006-200007.6"> </A><A 
 HREF="theory-bk.html#Q2-80006-20"  NAME="Q1-80006-20">Uniform Families of Circuits and PRAM's</A></H3>
   <P >
      <A 
 HREF="#Q1-80006-21"  NAME="Q2-80006-21">From PRAM's to Uniform Families of Circuits</A>
<BR>         <A 
 HREF="#Q1-80006-22"  NAME="Q2-80006-22">The Structure of c<SUB>n</SUB></A>
<BR>         <A 
 HREF="#Q1-80006-23"  NAME="Q2-80006-23">The Complexity of c<SUB>n</SUB></A>
<BR>         <A 
 HREF="#Q1-80006-24"  NAME="Q2-80006-24">From Uniform Families of Circuits to PRAM's</A>
<BR>         <A 
 HREF="#Q1-80006-25"  NAME="Q2-80006-25">The Simulation of Gate g<SUB>i</SUB> by Processor M<SUB>i</SUB></A>
<BR>         <A 
 HREF="#Q1-80006-26"  NAME="Q2-80006-26">The Identification of Gate g<SUB>i</SUB> by processor M<SUB>i</SUB></A>
<A NAME="80006-20001"> </A>
   <P >This section shows that uniform families of circuits and PRAM's are polynomially
related in the resources they require. As a corollary, <I>U_FNC</I><A NAME="80006-20002"> </A> is exactly the class of
problems that can be solved by the PRAM's that have polynomial space complexity and
polylog time complexity.
   <P ><STRONG>Notation </STRONG> <A 
   NAME="80006-20003t7.6"> </A> 
In what follows, <I>PROCESSORS_TIME _F</I> (Z(n), T(n)) denotes the set of functions that
can be computed by the PRAM's having both O(Z(n)) size complexity and O(T(n)) time
complexity (under the logarithmic cost criterion).
   <P ><EM><A 
   NAME="80006-21000"> </A><A 
 HREF="#Q2-80006-21"  NAME="Q1-80006-21">From PRAM's to Uniform Families of Circuits</A></EM>
   <P >The proof of the following theorem consists of showing how the hardware of any given
PRAM can be unrolled to obtain a corresponding uniform family of circuits. The
degenerated case in which PRAM's are restricted to being RAM's has been considered in
Lemma <A 
 HREF="theory-bk-sevense5.html#80005-12001t7.5.1">7.5.1</A>.
   <P ><STRONG>Theorem 7.6.1</STRONG> <A 
   NAME="80006-21001t7.6.1"> </A> 
If log T(n) and log Z(n) are fully<A NAME="80006-21002"> </A> space-constructible, log Z(n) <FONT FACE="SYMBOL">£</FONT> T(n), and
n <FONT FACE="SYMBOL">£</FONT> O<IMG 
SRC="theory-bk-seven62x.gif" ALT="(Z(n)T (n))"ALIGN="MIDDLE" >, then
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-seven63x.gif" ALT=" PROCESSORS_TIME  _FÈ (Z(n),T (n))  Í
                     U_SIZE_DEPTH  _F((Z(n)T(n))d,T d(n)).
                 d³0"></PRE></CENTER>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="80006-21003t"> </A> 
Consider any PRAM <IMG 
SRC="theory-bk-seven64x.gif" ALT="^M"> = &lt;M, <TT>X</TT>, <TT>Y</TT>, <TT>A</TT>&gt; of size complexity Z(n) and time complexity
T(n). By Theorem <A 
 HREF="theory-bk-sevense2.html#80002-3022t7.2.1">7.2.1</A> it can be assumed that <IMG 
SRC="theory-bk-seven65x.gif" ALT="^M"> is a CREW PRAM. Consider any n and
let m = Z(n) and t = T(n). The computations of <IMG 
SRC="theory-bk-seven66x.gif" ALT="^M"> on inputs of length n can be
simulated by the circuit c<SUB>n</SUB> of Figure <A 
 HREF="#80006-21004r7.6.1">7.6.1</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="80006-21004r7.6.1"> </A>
<A 
   NAME="80006-21004r7.6.1"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-seven-7-6-1.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 7.6.1 </STRONG></NOBR></TD><TD  
>A circuit for simulating a computation of a PRAM.                                                    </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P ><EM><A 
   NAME="80006-22000"> </A><A 
 HREF="#Q2-80006-22"  NAME="Q1-80006-22">The Structure of c<SUB>n</SUB></A></EM>
   <P >The circuit c<SUB>n</SUB> has an underlying structure similar to the circuit c<SUB>n</SUB> in the proof of
Lemma <A 
 HREF="theory-bk-sevense5.html#80005-12001t7.5.1">7.5.1</A> (see Figure <A 
 HREF="theory-bk-sevense5.html#80005-14001r7.5.1">7.5.1</A>). It consists of t + 2 subcircuits, namely, IN, STEP<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , STEP<SUB>t</SUB>,
and OUT. IN considers a given input of length n as an encoding of some input (v<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, v<SUB>N </SUB>) of
<IMG 
SRC="theory-bk-seven67x.gif" ALT="^M"> , and determines the initial configuration of <IMG 
SRC="theory-bk-seven68x.gif" ALT="^M">. STEP<SUB>i</SUB> determines the configuration
that <IMG 
SRC="theory-bk-seven69x.gif" ALT="^M"> reaches after its <I>i</I>th step. OUT  extracts the output of <IMG 
SRC="theory-bk-seven70x.gif" ALT="^M"> from the output of
STEP<SUB>
t</SUB>.
   <P >Each configuration of <IMG 
SRC="theory-bk-seven71x.gif" ALT="^M"> is assumed to have the form (i<SUB>1</SUB>, <TT>X</TT>(i<SUB>1</SUB>), i<SUB>2</SUB>, <TT>X</TT>(i<SUB>2</SUB>),<FONT FACE="SYMBOL"> ¼</FONT> ;
<IMG 
SRC="theory-bk-seven72x.gif" ALT="^i"><SUB>
1</SUB>, <TT>Y</TT>(<IMG 
SRC="theory-bk-seven73x.gif" ALT="^i"><SUB>1</SUB>), <IMG 
SRC="theory-bk-seven74x.gif" ALT="^i"><SUB>2</SUB>, <TT>Y</TT>(<IMG 
SRC="theory-bk-seven75x.gif" ALT="^i"><SUB>2</SUB>),<FONT FACE="SYMBOL"> ¼</FONT> ; <IMG 
SRC="theory-bk-seven76x.gif" ALT="i" ><SUB>1</SUB>, <TT>A</TT>(<IMG 
SRC="theory-bk-seven77x.gif" ALT="i" ><SUB>1</SUB>), <IMG 
SRC="theory-bk-seven78x.gif" ALT="i" ><SUB>2</SUB>, <TT>A</TT>(<IMG 
SRC="theory-bk-seven79x.gif" ALT="i" ><SUB>2</SUB>),<FONT FACE="SYMBOL"> ¼</FONT> ; <IMG 
SRC="theory-bk-seven80x.gif" ALT="~i"><SUB>1</SUB>, <TT>V</TT><SUB>1</SUB>(<IMG 
SRC="theory-bk-seven81x.gif" ALT="~i"><SUB>1</SUB>), <IMG 
SRC="theory-bk-seven82x.gif" ALT="~i"><SUB>2</SUB>, <TT>V</TT><SUB>1</SUB>(<IMG 
SRC="theory-bk-seven83x.gif" ALT="~i"><SUB>2</SUB>),<FONT FACE="SYMBOL"> ¼</FONT> ; <FONT FACE="SYMBOL">¼</FONT> ; <IMG 
SRC="theory-bk-seven84x.gif" ALT="`i"><SUB>1</SUB>,
<TT>V</TT><SUB>
m</SUB>(<IMG 
SRC="theory-bk-seven85x.gif" ALT="`i"><SUB>1</SUB>), <IMG 
SRC="theory-bk-seven86x.gif" ALT="`i"><SUB>2</SUB>, <TT>V</TT><SUB>m</SUB>(<IMG 
SRC="theory-bk-seven87x.gif" ALT="`i"><SUB>2</SUB>),<FONT FACE="SYMBOL"> ¼</FONT> ), where <TT>V</TT><SUB>i</SUB>(j) is assumed to be the value of the <I>j</I>th local variable of
processor M<SUB>i</SUB>.
   <P >STEP<SUB>i</SUB> consists of three layers, namely, READ, SIMULATE, and WRITE. The READ
layer simulates the reading, from the input cells and shared memory cells, that
takes place during the <I>i</I>th step of the simulated computation. The SIMULATE layer
simulates the internal computation that takes place during the <I>i</I>th step by the
processors M<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , M<SUB>m</SUB>. The WRITE layer simulates the writing, to the output cells
and shared memory cells, that takes place during the <I>i</I>th step of the simulated
computation.
   <P >With no loss of generality, it is assumed that in each step processor M<SUB>i</SUB> reads from the
input cell <TT>X</TT>(<TT>V</TT><SUB>i</SUB>(1)) into <TT>V</TT><SUB>i</SUB>(1), and from the shared memory cell <TT>A</TT>(<TT>V</TT><SUB>i</SUB>(2)) into <TT>V</TT><SUB>i</SUB>(2).
Similarly, it is assumed that in each step M<SUB>i</SUB> writes the value of <TT>V</TT><SUB>i</SUB>(3) into the output cell
<TT>Y</TT>(<TT>V</TT><SUB>i</SUB>(4)), and the value of <TT>V</TT><SUB>i</SUB>(5) into <TT>A</TT>(<TT>V</TT><SUB>i</SUB>(6)).
   <P >SIMULATE contains a subcircuit SIM _RAM for each of the processors M<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , M<SUB>m</SUB>. The
internal computation of processor M<SUB>j</SUB> is simulated by a SIM _RAM whose input is
(i<SUB>1</SUB>, <TT>V</TT><SUB>j</SUB>(i<SUB>1</SUB>), i<SUB>2</SUB>, <TT>V</TT><SUB>j</SUB>(i<SUB>2</SUB>),<FONT FACE="SYMBOL"> ¼</FONT>). With no loss of generality it is assumed that the index j of M<SUB>j</SUB> is
stored in <TT>V</TT><SUB>j</SUB>(7).
   <P ><EM><A 
   NAME="80006-23000"> </A><A 
 HREF="#Q2-80006-23"  NAME="Q1-80006-23">The Complexity of c<SUB>n</SUB></A></EM>
   <P >The circuits IN, READ, WRITE, and OUT  can each simulate an O(log (nZ(n)T(n)))
space-bounded, deterministic Turing transducer that carries out the desired task. The
simulations can be as in the proof of Lemma <A 
 HREF="theory-bk-sevense5.html#80005-19002t7.5.3">7.5.3</A>. Hence, each of these circuits has
size no greater than (nZ(n)T(n))<SUP>O(1)</SUP> <FONT FACE="SYMBOL">£</FONT> (Z(n)T(n))<SUP>O(1)</SUP> and depth no greater
than (log (nZ(n)T(n)))<SUP>O(1)</SUP> <FONT FACE="SYMBOL">£</FONT> T<SUP>O(1)</SUP>(n). SIM _RAM can simulate a processor M<SUB>i</SUB>
indirectly as in the proof of Lemma <A 
 HREF="theory-bk-sevense5.html#80005-12001t7.5.1">7.5.1</A>, through a deterministic Turing transducer
equivalent to M<SUB>i</SUB>. Hence, each SIM _RAM has size no greater than T<SUP>O(1)</SUP>(n). <IMG 
SRC="theory-bk-seven15x.gif" ALT=" ***
" 
 >
   <P >
   <P ><EM><A 
   NAME="80006-24000"> </A><A 
 HREF="#Q2-80006-24"  NAME="Q1-80006-24">From Uniform Families of Circuits to PRAM's</A></EM>
   <P >The previous theorem considered the simulation of PRAM's by uniform families of
circuits. The next theorem considers simulations in the other direction.
   <P ><STRONG>Theorem 7.6.2</STRONG> <A 
   NAME="80006-24001t7.6.2"> </A> 
<A NAME="80006-24002"> </A>
<CENTER>
<PRE><IMG 
SRC="theory-bk-seven88x.gif" ALT=" U_SIZE_DEPTH  _F(Z(n),D(n))  Í
             È                        d          d
                PROCESSORS_TIME  _F (Z (n),D(n)log Z(n)).
             d&gt;0"></PRE></CENTER>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="80006-24003t"> </A> 
Consider any uniform family C = (c<SUB>0</SUB>, c<SUB>1</SUB>, c<SUB>2</SUB>,<FONT FACE="SYMBOL"> ¼</FONT> ) of circuits with size complexity Z(N) and
depth complexity D(n). Let T = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">G</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, B, F&gt; be an S(n) = O(log Z(n))
space-bounded, deterministic Turing transducer that computes { (1<SUP>n</SUP>, c<SUB>n</SUB>) | n <FONT FACE="SYMBOL">³</FONT> 0 }. From
T a CREW PRAM <IMG 
SRC="theory-bk-seven89x.gif" ALT="^M"> = &lt;M, <TT>X</TT>, <TT>Y</TT>, <TT>A</TT>&gt; of size complexity Z<SUP>O(1)</SUP>(n) and time complexity
D(n)log <SUP>O(1)</SUP>Z(n) can be constructed to simulate the computations of C in a
straightforward manner.
   <P ><EM><A 
   NAME="80006-25000"> </A><A 
 HREF="#Q2-80006-25"  NAME="Q1-80006-25">The Simulation of Gate g<SUB>i</SUB> by Processor M<SUB>i</SUB></A></EM>
   <P >Specifically, for each gate g<SUB>i</SUB> in c<SUB>n</SUB>, the PRAM <IMG 
SRC="theory-bk-seven90x.gif" ALT="^M"> employs a corresponding processor
M<SUB>
i</SUB> and a corresponding shared memory cell <TT>A</TT>(i). The processor M<SUB>i</SUB> is used for simulating
the operation of g<SUB>i</SUB>, and the cell <TT>A</TT>(i) is used for recording the outcome of the
simulation.
   <P >At the start of each simulation, M<SUB>i</SUB> initializes the value of <TT>A</TT>(i) to 2, as an indication
that the output of g<SUB>i</SUB> is not available yet. Then M<SUB>i</SUB> waits until its operands become available,
that is, until its operands reach values that differ from 2. M<SUB>i</SUB> has the input cell <TT>X</TT>(j) as an
operand if g<SUB>i</SUB> gets an input from the <I>j</I>th input node <TT>x</TT><SUB>j</SUB>. M<SUB>i</SUB> has the shared memory cell
<TT>A</TT>(j) as an operand if g<SUB>i</SUB> gets an input from the <I>j</I>th gate g<SUB>j</SUB>. When its operands
become available, M<SUB>i</SUB> performs on them the same operation as does g<SUB>i</SUB>. M<SUB>i</SUB> stores the
result in <TT>Y</TT>(j), if g<SUB>i</SUB> is the <I>j</I>th output node of c<SUB>n</SUB>. Otherwise, M<SUB>i</SUB> stores the result in
<TT>A</TT>(i).
   <P ><EM><A 
   NAME="80006-26000"> </A><A 
 HREF="#Q2-80006-26"  NAME="Q1-80006-26">The Identification of Gate g<SUB>i</SUB> by processor M<SUB>i</SUB></A></EM>
   <P >Before the start of a simulation of c<SUB>n</SUB> the PRAM <IMG 
SRC="theory-bk-seven91x.gif" ALT="^M"> determines for each gate g<SUB>i</SUB> in c<SUB>i</SUB>,
what the type t is in {¬, <FONT FACE="SYMBOL">Ú</FONT>, <FONT FACE="SYMBOL">Ù</FONT>} of g<SUB>i</SUB>, and which are the predecessors g<SUB>L</SUB> and g<SUB>R</SUB> of g<SUB>i</SUB>. <IMG 
SRC="theory-bk-seven92x.gif" ALT="^M">
does so by determining in parallel the output of T on input 1<SUP>n</SUP>, and communicating each
substring of the form (g<SUB>i</SUB>) and each substring of the form (g<SUB>i</SUB>, t, g<SUB>L</SUB>, g<SUB>R</SUB>) in the output to the
corresponding processor M<SUB>i</SUB>.
   <P ><IMG 
SRC="theory-bk-seven93x.gif" ALT="^M"> determines the output of T by employing a group B<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , B<SUB>O(Z(n)log Z(n))</SUB> of
processors. The task of processor B<SUB>j</SUB> is to determine the <I>j</I>th symbol in the output of
T.
   <P >B<SUB>j</SUB>, in turn, employs a processor B<SUB>ja</SUB> for each symbol a in the output alphabet <FONT FACE="SYMBOL">D</FONT> of T.
The task of B<SUB>ja</SUB> is to notify B<SUB>j</SUB> whether the <I>j</I>th symbol in the output of T is the symbol a.
B<SUB>
ja</SUB> does so by simulating a log Z(n) space-bounded Turing machine M<SUB>T </SUB> that accepts the
language  { 1<SUP>n</SUP> | a is the <I>j</I>th symbol in the output of T }. The simulation is performed in
parallel by a group of processors that uses an approach similar to that described in the
proof of Lemma <A 
 HREF="theory-bk-sevense5.html#80005-19002t7.5.3">7.5.3</A>.
   <P >Once the output of T is determined, each processor B<SUB>j</SUB> that holds the symbol &#34;(&#34;
communicates the string &#34;(g<SUB>i</SUB> · · · )&#34; that is held by B<SUB>j</SUB>, <FONT FACE="SYMBOL">¼</FONT> , B<SUB>j+|(g<SUB>i</SUB>··· )|-1</SUB> to the corresponding
processor M<SUB>i</SUB> of <IMG 
SRC="theory-bk-seven94x.gif" ALT="^M">.
   <P >Finally, each processor M<SUB>i</SUB> that has been communicated to with a string of the form
(g<SUB>i</SUB>, t, g<SUB>L</SUB>, g<SUB>R</SUB>) communicates with its predecessors to determine the input nodes of c<SUB>n</SUB>. <IMG 
SRC="theory-bk-seven15x.gif" ALT=" ***
" 
 >
   <P >
   <P >
   <P >[<A 
 HREF="theory-bk-sevenli1.html" >next</A>] [<A 
 HREF="theory-bk-sevense5.html" >prev</A>] [<A 
 HREF="theory-bk-sevense5.html#tailtheory-bk-sevense5.html" >prev-tail</A>] [<A 
 HREF="theory-bk-sevense6.html" >front</A>] [<A 
 HREF="theory-bk-seven.html#theory-bk-sevense6.html" >up</A>] <A 
   NAME="tailtheory-bk-sevense6.html"> </A></BODY></HTML>