
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-two.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-twose3.html" >next</A>] [<A 
 HREF="theory-bk-twose1.html" >prev</A>] [<A 
 HREF="theory-bk-twose1.html#tailtheory-bk-twose1.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-twose2.html">tail</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose2.html" >up</A>]
<H3>2.2 <A 
   NAME="30002-30002.2"> </A><A 
 HREF="theory-bk.html#Q2-30002-3"  NAME="Q1-30002-3">Finite-State Transducers</A></H3>
   <P >
      <A 
 HREF="#Q1-30002-4"  NAME="Q2-30002-4">Abstracted Finite-Memory Programs</A>
<BR>         <A 
 HREF="#Q1-30002-5"  NAME="Q2-30002-5">Finite-State Transducers</A>
<BR>         <A 
 HREF="#Q1-30002-6"  NAME="Q2-30002-6">Configurations and Moves of Finite-State Transducers</A>
<BR>         <A 
 HREF="#Q1-30002-7"  NAME="Q2-30002-7">Determinism and Nondeterminism in Finite-State Transducers</A>
<BR>         <A 
 HREF="#Q1-30002-8"  NAME="Q2-30002-8">Computations of Finite-State Transducers</A>
<BR>         <A 
 HREF="#Q1-30002-9"  NAME="Q2-30002-9">Relations and Languages of Finite-State Transducers</A>
<BR>         <A 
 HREF="#Q1-30002-10"  NAME="Q2-30002-10">From Finite-State Transducers to Finite-Memory Programs</A>
   <P >Central to the investigation of finite-memory programs is the observation
that the set of all the states reachable in the computations of each such program
is finite. As a result, the computations of each finite-memory program can be
characterized by a finite set of states and a finite set of rules for transitions between those
states.
   <P ><EM><A 
   NAME="30002-4000"> </A><A 
 HREF="#Q2-30002-4"  NAME="Q1-30002-4">Abstracted Finite-Memory Programs</A></EM>
   <P >Specifically, let P be a finite-memory program with m variables <TT>x</TT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <TT>x</TT><SUB>m</SUB>,
and k instruction segments I<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , I<SUB>k</SUB>. Denote the initial value of the variables of P
with <IMG
SRC="cmsy10-c.gif" ALT=" o. ">.
   <P >Each <I>state</I><A NAME="30002-4001"> </A> of P is an (m + 1)-tuple [i, v<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, v<SUB>m</SUB>], where i is an integer between 1 and k,
and v<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , v<SUB>m</SUB> are values from the domain of the variables. Intuitively, a state [i, v<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, v<SUB>m</SUB>]
indicates that the program reached instruction segment I<SUB>i</SUB> with values v<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , v<SUB>m</SUB> in the
variables <TT>x</TT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <TT>x</TT><SUB>m</SUB>, respectively.
   <P ><STRONG>Example 2.2.1</STRONG> <A 
   NAME="30002-4002t2.2.1"> </A> 
Let P be the program in Figure <A 
 HREF="#30002-4003r2.2.1">2.2.1</A>. The domain of the variables is assumed to equal
{0, 1}, and the initial value is assumed to be 0. Let [i, x, y] denote the state of P that
corresponds to the <I>i</I>th instruction segment I<SUB>i</SUB>, the value x in <TT>x</TT>, and the value y in
<TT>y</TT>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-4003r2.2.1"> </A>
                 <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>x</TT> := ?                             /* I<SUB>1</SUB>  */
<B>write</B> <TT>x</TT>                                      /* I<SUB>2</SUB>  */
<B>do</B>                                             /* I<SUB>3</SUB>  */
    <B>do</B>                                         /* I<SUB>4</SUB>  */
        <B>read</B> <TT>y</TT>                               /* I<SUB>5</SUB>  */
    <B>until</B> <TT>x</TT> = <TT>y</TT>                           /* I<SUB>6</SUB>  */
    <B>if</B> <I>eof</I> <B>then accept</B>                /* I<SUB>7</SUB>  */
    <B>do</B>                                         /* I<SUB>8</SUB>  */
        <TT>x</TT> := <TT>x</TT> - 1                  /* I<SUB>9</SUB>  */
    <B>or</B>
        <TT>y</TT> := <TT>y</TT> + 1                  /* I<SUB>10</SUB> */
    <B>until</B> <TT>x</TT><IMG 
SRC="theory-bk-two4x.gif" ALT="/="ALIGN="MIDDLE" > <TT>y</TT>                           /* I<SUB>11</SUB> */
<B>until</B> false                       /* I<SUB>12</SUB> */ </PRE></TD></TR></TABLE>
<A 
   NAME="30002-4003r2.2.1"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.1 </STRONG></NOBR></TD><TD  
>A finite-memory program with {0, 1} as the domain of the variables.                        </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >The state [1, 0, 0] indicates that the program reached the first instruction segment with
the value 0 in <TT>x</TT> and <TT>y</TT>. The state [5, 1, 0] indicates that the program reached the fifth
instruction segment with the value 1 in <TT>x</TT> and the value 0 in <TT>y</TT>.
   <P >From state [5, 1, 0] the program can reach either state [6, 1, 0] or state [6, 1, 1]. In the
transition from state [5, 1, 0] to state [6, 1, 0] the program reads the value 0 and writes
nothing. In the transition from state [5, 1, 0] to state [6, 1, 1] the program reads the value 1
and writes nothing. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >The computational behavior of P can be abstracted by a formal system
&lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt;, which is defined through the algorithm below. In the formal
system
     <DL><DT><STRONG>
Q </STRONG><DD 
>represents the set of states that P can reach.
     <DT><STRONG>
<FONT FACE="SYMBOL">d</FONT> </STRONG><DD 
>represents the set of transitions that P can take between its states.
     <DT><STRONG>
<FONT FACE="SYMBOL">S</FONT> </STRONG><DD 
>represents the set of input values that P can read.
     <DT><STRONG>
<FONT FACE="SYMBOL">D</FONT> </STRONG><DD 
>represents the set of output values that P can write.
     <DT><STRONG>
q<SUB>0</SUB> </STRONG><DD 
>represents the initial state of P.
     <DT><STRONG>
F </STRONG><DD 
>represents the set of accepting states that P can reach.</DL>
The algorithm determines the sets Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, and F by conducting a search for the
elements of the sets.
    <DL><DT><STRONG>
 <STRONG>Step 1</STRONG> </STRONG><DD 
>Initiate Q to the set containing just q<SUB>0</SUB> = [1, <IMG
SRC="cmsy10-c.gif" ALT=" o. ">,<FONT FACE="SYMBOL"> ¼</FONT>, <IMG
SRC="cmsy10-c.gif" ALT=" o. ">], and <FONT FACE="SYMBOL">d</FONT> to be an empty
    set. q<SUB>0</SUB> is called the <I>initial<A NAME="30002-4004"> </A> state</I> of P, and <FONT FACE="SYMBOL">d</FONT> is called the <I>transition<A NAME="30002-4005"> </A> table</I> of P.
    <DT><STRONG>
 <STRONG>Step 2</STRONG> </STRONG><DD 
>Add the state p = [j, u<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, u<SUB>m</SUB>] of P to Q, if for some state q = [i, v<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, v<SUB>m</SUB>]
    in Q the following condition holds: P can, by executing I<SUB>i</SUB> with values v<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , v<SUB>m</SUB>
    in its variables, reach I<SUB>j</SUB> with u<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , u<SUB>m</SUB> in its variables, respectively.
    <DT><STRONG>
 <STRONG>Step 3</STRONG> </STRONG><DD 
>Add (q, <FONT FACE="SYMBOL">a</FONT>, (p, <FONT FACE="SYMBOL">r</FONT>)) to <FONT FACE="SYMBOL">d</FONT>, if P, by executing a single instruction segment, can
    go from state q in Q to state p in Q while reading <FONT FACE="SYMBOL">a</FONT> and writing <FONT FACE="SYMBOL">r</FONT>. For notational
    convenience, in what follows (q, <FONT FACE="SYMBOL">a</FONT>, (p, <FONT FACE="SYMBOL">r</FONT>)) will be written as (q, <FONT FACE="SYMBOL">a</FONT>, p, <FONT FACE="SYMBOL">r</FONT>). Each
    tuple in <FONT FACE="SYMBOL">d</FONT> is called a <I>transition<A NAME="30002-4006"> </A> rule</I> of P.
    <DT><STRONG>
 <STRONG>Step 4</STRONG> </STRONG><DD 
>Repeat Steps 2 and 3 as long as more states can be added to Q or more
    transition rules can be added to <FONT FACE="SYMBOL">d</FONT>.
    <DT><STRONG>
 <STRONG>Step 5</STRONG> </STRONG><DD 
>Initialize <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, and F to be empty sets.
    <DT><STRONG>
 <STRONG>Step 6</STRONG> </STRONG><DD 
>If (q, <FONT FACE="SYMBOL">a</FONT>, p, <FONT FACE="SYMBOL">r</FONT>) is a transition rule in <FONT FACE="SYMBOL">d</FONT> and <FONT FACE="SYMBOL">a</FONT><IMG 
SRC="theory-bk-two5x.gif" ALT="/="ALIGN="MIDDLE" > <FONT FACE="SYMBOL">e</FONT> then add <FONT FACE="SYMBOL">a</FONT> to <FONT FACE="SYMBOL">S</FONT>. Similarly,
    if (q, <FONT FACE="SYMBOL">a</FONT>, p, <FONT FACE="SYMBOL">r</FONT>) is a transition rule in <FONT FACE="SYMBOL">d</FONT> and <FONT FACE="SYMBOL">r</FONT><IMG 
SRC="theory-bk-two6x.gif" ALT="/="ALIGN="MIDDLE" > <FONT FACE="SYMBOL">e</FONT>, then add <FONT FACE="SYMBOL">r</FONT> to <FONT FACE="SYMBOL">D</FONT>. Each <FONT FACE="SYMBOL">a</FONT> in <FONT FACE="SYMBOL">S</FONT> is
    called an <I>input<A NAME="30002-4007"> </A> symbol</I> of P, and <FONT FACE="SYMBOL">S</FONT> is called the <I>input alphabet</I> of P. Similarly,
    each <FONT FACE="SYMBOL">r</FONT> in <FONT FACE="SYMBOL">D</FONT> is called an <I>output<A NAME="30002-4008"> </A> symbol</I> of P, and <FONT FACE="SYMBOL">D</FONT> is called the <I>output alphabet</I>
    of P.
    <DT><STRONG>
 <STRONG>Step 7</STRONG> </STRONG><DD 
>Insert to F each state [i, v<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, v<SUB>m</SUB>] in Q for which I<SUB>i</SUB> is a conditional accept
    instruction. The states in F are called the <I>accepting</I><A NAME="30002-4009"> </A>, or the <I>final</I><A NAME="30002-4010"> </A>, states of P.</DL>
By definition <FONT FACE="SYMBOL">d</FONT> is a relation from Q × (<FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> {<FONT FACE="SYMBOL">e</FONT>}) to Q × (<FONT FACE="SYMBOL">D</FONT> <FONT FACE="SYMBOL">È</FONT> {<FONT FACE="SYMBOL">e</FONT>}). Moreover, the
sets Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, and F are all finite because the number of instruction segments
in P, the number of variables in P, and the domain of the variables of P are all
finite.
   <P ><STRONG>Example 2.2.2</STRONG> <A 
   NAME="30002-4011t2.2.2"> </A> 
Assume the notations of Example <A 
 HREF="#30002-4002t2.2.1">2.2.1</A>. The initial state of the program P is [1, 0, 0]. By
executing the first instruction, the program can move from state [1, 0, 0] and either enter
the state [2, 0, 0] or the state [2, 1, 0]. In both cases, no input symbol is read and no
output symbol is written during the transition between the states. Hence, the
transition table <FONT FACE="SYMBOL">d</FONT> for P contains the transition rules ([1, 0, 0], <FONT FACE="SYMBOL">e</FONT>, [2, 0, 0], <FONT FACE="SYMBOL">e</FONT>) and
([1, 0, 0], <FONT FACE="SYMBOL">e</FONT>, [2, 1, 0], <FONT FACE="SYMBOL">e</FONT>).
   <P >Similarly, by executing its second instruction, the program P must move from state
[2, 1, 0] and enter state [3, 1, 0] while reading nothing and writing 1. Hence, <FONT FACE="SYMBOL">d</FONT> contains also
the transition rule ([2, 1, 0], <FONT FACE="SYMBOL">e</FONT>, [3, 1, 0], 1).
   <P >The number of states in Q is no greater than 12 × 2 × 2. {0, 1} is the input and the
output alphabet for the program P. {[7, 0, 0], [7, 1, 1]} is the set of accepting states for P. <IMG 
SRC="theory-bk-two2x.gif" ALT="
*** " 
 >
   <P >
   <P ><EM><A 
   NAME="30002-5000"> </A><A 
 HREF="#Q2-30002-5"  NAME="Q1-30002-5">Finite-State Transducers</A></EM>
   <P >In general, a formal system M consisting of a six-tuple &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt; is called a
<I>finite-state<A NAME="30002-5001"> </A> transducer</I> if it satisfies the following conditions.
     <DL><DT><STRONG>
Q </STRONG><DD 
>is a finite set, whose members are called the <I>states</I> of M.
     <DT><STRONG>
<FONT FACE="SYMBOL">S</FONT> </STRONG><DD 
>is an alphabet, called the <I>input alphabet</I> of M. Each symbol in <FONT FACE="SYMBOL">S</FONT> is called an
     <I>input<A NAME="30002-5002"> </A> symbol</I> of M.
     <DT><STRONG>
<FONT FACE="SYMBOL">D</FONT> </STRONG><DD 
>is an alphabet, called the <I>output alphabet</I> of M. Each symbol in <FONT FACE="SYMBOL">D</FONT> is called an
     <I>output<A NAME="30002-5003"> </A> symbol</I> of M.
     <DT><STRONG>
<FONT FACE="SYMBOL">d</FONT> </STRONG><DD 
>is a relation from Q × (<FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> {<FONT FACE="SYMBOL">e</FONT>})   to   Q × (<FONT FACE="SYMBOL">D</FONT> <FONT FACE="SYMBOL">È</FONT> {<FONT FACE="SYMBOL">e</FONT>}), called the <I>transition<A NAME="30002-5004"> </A> table</I> of
     M. Each tuple (q, <FONT FACE="SYMBOL">a</FONT>, (p, <FONT FACE="SYMBOL">r</FONT>)), or simply (q, <FONT FACE="SYMBOL">a</FONT>, p, <FONT FACE="SYMBOL">r</FONT>), in <FONT FACE="SYMBOL">d</FONT> is called a <I>transition
     rule</I> of M.
     <DT><STRONG>
q<SUB>0</SUB> </STRONG><DD 
>is a state in Q, called the <I>initial<A NAME="30002-5005"> </A> state</I> of M.
     <DT><STRONG>
F </STRONG><DD 
>is a subset of Q, whose states are called the <I>accepting</I><A NAME="30002-5006"> </A>, or the <I>final</I><A NAME="30002-5007"> </A>, states of M.<A NAME="30002-5008"> </A></DL>
<STRONG>Example 2.2.3</STRONG> <A 
   NAME="30002-5009t2.2.3"> </A> 
The tuple M = &lt;{q<SUB>0</SUB>, q<SUB>1</SUB>}, {a, b}, {1}, {(q<SUB>0</SUB>, a, q<SUB>1</SUB>, 1), (q<SUB>0</SUB>, b, q<SUB>1</SUB>, <FONT FACE="SYMBOL">e</FONT>), (q<SUB>1</SUB>, b, q<SUB>1</SUB>, 1), (q<SUB>1</SUB>, a, q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>)}, q<SUB>0</SUB>, {q<SUB>0</SUB>}&gt;
is a finite-state transducer. The finite-state transducer has the states q<SUB>0</SUB> and q<SUB>1</SUB>. The input
alphabet of M consists of two symbols a and b. The output alphabet of M consists of a
single symbol 1. The finite-state transducer M has four transition rules. q<SUB>0</SUB> is the initial
state of M, and the only accepting state of M.
   <P >The transition rule (q<SUB>0</SUB>, a, q<SUB>1</SUB>, 1) of M uses the input symbol a and the output symbol 1.
The transition rule (q<SUB>1</SUB>, a, q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>) of M uses the input symbol a and no output symbol.<A NAME="30002-5010"> </A> <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P >Each finite-state transducer &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt; can be graphically represented by a
<I>transition<A NAME="30002-5011"> </A> diagram</I> of the following form. For each state in Q the transition diagram has a
corresponding node, which is shown by a circle. The initial state is identified by an arrow
from nowhere that points to the corresponding node. Each accepting state is identified by a
double circle. Each transition rule (q, <FONT FACE="SYMBOL">a</FONT>, p, <FONT FACE="SYMBOL">r</FONT>) in <FONT FACE="SYMBOL">d</FONT> is represented by an edge labeled with
<FONT FACE="SYMBOL">a</FONT>/<FONT FACE="SYMBOL">r</FONT>, from the node labeled by state q to the node labeled by state p. For notational
convenience edges that agree in their origin and destination are merged, and their labels
are separated by commas.
   <P ><STRONG>Example 2.2.4</STRONG> <A 
   NAME="30002-5012t2.2.4"> </A> 
The transition diagram in Figure <A 
 HREF="#30002-5013r2.2.2">2.2.2</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-5013r2.2.2"> </A>
<A 
   NAME="30002-5013r2.2.2"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-2-2.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.2 </STRONG></NOBR></TD><TD  
>Transition diagram of a finite-state transducer.                                                            </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>represents the finite-state transducer M of Example <A 
 HREF="#30002-5009t2.2.3">2.2.3</A>. The label a/1 on the edge from
state q<SUB>0</SUB> to state q<SUB>1</SUB> in the transition diagram corresponds to the transition rule (q<SUB>0</SUB>, a, q<SUB>1</SUB>, 1)
of M. The label b/<FONT FACE="SYMBOL">e</FONT> on the edge from state q<SUB>0</SUB> to state q<SUB>1</SUB> corresponds to the transition rule
(q<SUB>0</SUB>, b, q<SUB>1</SUB>, <FONT FACE="SYMBOL">e</FONT>). The label b/1 on the edge from state q<SUB>1</SUB> to itself corresponds to the transition
rule (q<SUB>1</SUB>, b, q<SUB>1</SUB>, 1). <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P ><STRONG>Example 2.2.5</STRONG> <A 
   NAME="30002-5014t2.2.5"> </A> 
The transition diagram in Figure <A 
 HREF="#30002-5015r2.2.3">2.2.3</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-5015r2.2.3"> </A>
<A 
   NAME="30002-5015r2.2.3"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-2-3.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.3 </STRONG></NOBR></TD><TD  
>Transition diagram for the program of Figure <A 
 HREF="#30002-4003r2.2.1">2.2.1</A>.                                                    </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>represents the finite-state transducer that characterizes the program of Example <A 
 HREF="#30002-4002t2.2.1">2.2.1</A>. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P ><EM><A 
   NAME="30002-6000"> </A><A 
 HREF="#Q2-30002-6"  NAME="Q1-30002-6">Configurations and Moves of Finite-State Transducers</A></EM>
   <P >Intuitively, a finite-state transducer M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt; can be viewed as an
abstract computing machine. The computing machine consists of a <I>finite-state<A NAME="30002-6001"> </A> control</I>, an
<I>input<A NAME="30002-6002"> </A> tape</I>, a read-only <I>input<A NAME="30002-6003"> </A> head</I>, an <I>output<A NAME="30002-6004"> </A> tape</I>, and a write-only <I>output<A NAME="30002-6005"> </A> head</I> (see
Figure <A 
 HREF="#30002-6006r2.2.4">2.2.4</A>).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-6006r2.2.4"> </A>
<A 
   NAME="30002-6006r2.2.4"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-2-4.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.4 </STRONG></NOBR></TD><TD  
>A view of a finite-state transducer as an abstract computing machine.                       </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Each tape is divided into cells, which can each hold exactly one symbol.
   <P >The input tape is used for holding the input uv of M. The input head is used for
accessing the input tape. The output tape is used for holding the output w of M, and the
output head is used for accessing the output tape. The finite-state control is used for
recording the state of M.
   <P >On each input a<SUB>1</SUB> · · · a<SUB>n</SUB> from <FONT FACE="SYMBOL">S</FONT>*, the computing machine M has some set of possible
configurations. Each <I>configuration</I><A NAME="30002-6007"> </A>, or <I>instantaneous<A NAME="30002-6008"> </A> description</I>, of M is a pair (uqv, w),
where q is a state in Q, uv = a<SUB>1</SUB> · · · a<SUB>n</SUB>, and w is a string in <FONT FACE="SYMBOL">D</FONT>*. Intuitively, a
configuration (uqv, w) says that M on input uv reached state q after reading u and
writing w. With no loss of generality it is assumed that Q and <FONT FACE="SYMBOL">S</FONT> are mutually
disjoint.
   <P ><STRONG>Example 2.2.6</STRONG> <A 
   NAME="30002-6009t2.2.6"> </A> 
Let M be the finite-state transducer of Example <A 
 HREF="#30002-5009t2.2.3">2.2.3</A> (see Figure <A 
 HREF="#30002-5013r2.2.2">2.2.2</A>). The configuration
(aabq<SUB>1</SUB>ba, 1) of M says that M reached the state q<SUB>1</SUB> after reading u = aab from the input
tape and writing w = 1 into the output tape. In addition, the configuration says that v = ba
is the remainder of the input (see Figure <A 
 HREF="#30002-6010r2.2.5">2.2.5</A>(a)).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-6010r2.2.5"> </A>
<A 
   NAME="30002-6010r2.2.5"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-2-5.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.5 </STRONG></NOBR></TD><TD  
>Configurations of the finite-state transducer of Figure <A 
 HREF="#30002-5013r2.2.2">2.2.2</A>.                                       </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >The configuration (q<SUB>0</SUB>aabba, <FONT FACE="SYMBOL">e</FONT>) of M says that M reached the state q<SUB>0</SUB> after reading
nothing (i.e., u = <FONT FACE="SYMBOL">e</FONT>) from the input tape and writing nothing (i.e., w = <FONT FACE="SYMBOL">e</FONT>) into the output
tape. In addition, the configuration says that v = aabba is the input to be consumed (see
Figure <A 
 HREF="#30002-6010r2.2.5">2.2.5</A>(b)).
   <P >The configuration (aabbaq<SUB>0</SUB>, 1) of M says that M reached state q<SUB>0</SUB> after reading all the
input (i.e., v = <FONT FACE="SYMBOL">e</FONT>) and writing w = 11. In addition, the configuration says that the input
that has been read is u = aabba. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >A configuration (uqv, w) of M is said to be an <I>initial<A NAME="30002-6011"> </A> configuration</I> if q = q<SUB>0</SUB> and
u = w = <FONT FACE="SYMBOL">e</FONT>. An initial configuration says that the input head is placed at the start (leftmost
position) of the input, the output tape is empty, and the finite-state control is set to the
initial state.
   <P >A configuration (uqv, w) of M is said to be an <I>accepting<A NAME="30002-6012"> </A> configuration</I> if v = <FONT FACE="SYMBOL">e</FONT> and q
is an accepting state in F. An accepting configuration says that M reached an accepting
state after reading all the input.<A NAME="30002-6013"> </A>
   <P ><STRONG>Example 2.2.7</STRONG> <A 
   NAME="30002-6014t2.2.7"> </A> 
The finite-state transducer M of Example <A 
 HREF="#30002-5009t2.2.3">2.2.3</A> (see Figure <A 
 HREF="#30002-5013r2.2.2">2.2.2</A>) has the initial
configuration (q<SUB>0</SUB>aabba, <FONT FACE="SYMBOL">e</FONT>), and the accepting configuration (aabbaq<SUB>0</SUB>, 11) on input aabba
(see Figure <A 
 HREF="#30002-6010r2.2.5">2.2.5</A>(a) and Figure <A 
 HREF="#30002-6010r2.2.5">2.2.5</A>(b), respectively).
   <P >(aabbaq<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>) and (aabbaq<SUB>0</SUB>, 111) are also accepting configurations of M on input
aabba. On the other hand, (q<SUB>0</SUB>aabba, <FONT FACE="SYMBOL">e</FONT>) is the only initial configuration of M on input
aabba. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >The transition<A NAME="30002-6015"> </A> rules of M are used for defining the possible moves of M. Each move
uses some transition rule. A <I>move</I><A NAME="30002-6016"> </A> on transition rule (q, <FONT FACE="SYMBOL">a</FONT>, p, <FONT FACE="SYMBOL">r</FONT>) consists of changing the
state of the finite-state control from q to p, of reading <FONT FACE="SYMBOL">a</FONT> from the input tape, of writing <FONT FACE="SYMBOL">r</FONT> to
the output tape, and of moving the input and the output heads, |<FONT FACE="SYMBOL">a</FONT>| and |<FONT FACE="SYMBOL">r</FONT>| positions to the
right, respectively.
   <P >A move of M from configuration C<SUB>1</SUB> to configuration C<SUB>2</SUB> is denoted C<SUB>1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "><SUB> M </SUB>C<SUB>2</SUB>, or
simply C<SUB>1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "> C<SUB>2</SUB> if M is understood. A sequence of zero or more moves of M from
configuration C<SUB>1</SUB> to configuration C<SUB>2</SUB> is denoted C<SUB>1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "><SUB> M </SUB>* C<SUB>2</SUB>, or simply C<SUB>1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- ">* C<SUB>2</SUB>, if M is
understood.
   <P ><STRONG>Example 2.2.8</STRONG> <A 
   NAME="30002-6017t2.2.8"> </A> 
Let M be the finite-state transducer of Example <A 
 HREF="#30002-5009t2.2.3">2.2.3</A> (see Figure <A 
 HREF="#30002-5013r2.2.2">2.2.2</A>). On input aabba,
M can have the following sequence (q<SUB>0</SUB>aabba, <FONT FACE="SYMBOL">e</FONT>) <IMG
SRC="cmsy10-60.gif" ALT=" |- ">* (aabbaq<SUB>0</SUB>, 11) of moves between
configurations (see Figure <A 
 HREF="#30002-6018r2.2.6">2.2.6</A>):
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-6018r2.2.6"> </A>
<A 
   NAME="30002-6018r2.2.6"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-2-6.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.6 </STRONG></NOBR></TD><TD  
>Sequence of moves between configurations of a finite-state transducer.                     </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>(q<SUB>0</SUB>aabba, <FONT FACE="SYMBOL">e</FONT>) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aq<SUB>1</SUB>abba, 1) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aaq<SUB>0</SUB>bba, 1) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aabq<SUB>1</SUB>ba, 1) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aabbq<SUB>1</SUB>a, 11) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aabbaq<SUB>0</SUB>, 11).
   <P >The sequence consists of five moves. It starts with a move (q<SUB>0</SUB>aabba, <FONT FACE="SYMBOL">e</FONT>) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aq<SUB>1</SUB>abba, 1)
on the first transition rule (q<SUB>0</SUB>, a, q<SUB>1</SUB>, 1) of M. During the move, M makes a transition from
state q<SUB>0</SUB> to state q<SUB>1</SUB> while reading a and writing 1.
   <P >The second move (aq<SUB>1</SUB>abba, 1) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aaq<SUB>0</SUB>bba, 1) is on the fourth transition rule
(q<SUB>1</SUB>, a, q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>) of M. During the move, M makes a transition from state q<SUB>1</SUB> to state q<SUB>0</SUB> while
reading a and writing nothing.
   <P >The sequence continues by a move on the second transition rule (q<SUB>0</SUB>, b, q<SUB>1</SUB>, <FONT FACE="SYMBOL">e</FONT>), followed
by a move on the third transition rule (q<SUB>1</SUB>, b, q<SUB>1</SUB>, 1), and it terminates after an additional
move on the fourth transition rule (q<SUB>1</SUB>, a, q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>).
   <P >The sequence of moves is the only one that can start at the initial configuration and end
at an accepting configuration for the input aabba. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >By definition, |<FONT FACE="SYMBOL">a</FONT>| = 0 or |<FONT FACE="SYMBOL">a</FONT>| = 1 in each transition rule (q, <FONT FACE="SYMBOL">a</FONT>, p, <FONT FACE="SYMBOL">r</FONT>). |<FONT FACE="SYMBOL">a</FONT>| = 0 if no input
symbol is read during the moves that use the transition rule (i.e., <FONT FACE="SYMBOL">a</FONT> = <FONT FACE="SYMBOL">e</FONT>), and |<FONT FACE="SYMBOL">a</FONT>| = 1 if
exactly one input symbol is read during the moves. Similarly, |<FONT FACE="SYMBOL">r</FONT>| = 0 or |<FONT FACE="SYMBOL">r</FONT>| = 1,
depending on whether nothing is written during the moves or exactly one symbol is
written, respectively.<A NAME="30002-6019"> </A>
   <P ><EM><A 
   NAME="30002-7000"> </A><A 
 HREF="#Q2-30002-7"  NAME="Q1-30002-7">Determinism and Nondeterminism in Finite-State Transducers</A></EM>
   <P >A finite-state transducer M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt; is said to be <I>deterministic</I><A NAME="30002-7001"> </A> if, for
each state q in Q and each input symbol a in <FONT FACE="SYMBOL">S</FONT>, the union <FONT FACE="SYMBOL">d</FONT>(q, a) <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">d</FONT>(q, <FONT FACE="SYMBOL">e</FONT>) is a multiset that
contains at most one element.
   <P >Intuitively, M is deterministic if each state of M fully determines whether an
input symbol is to be read on a move from the state, and the state together with
the input to be consumed in the move fully determine the transition rule to be
used.
   <P >A finite-state transducer is said to be <I>nondeterministic</I><A NAME="30002-7002"> </A> if the previous conditions do not
hold.
   <P ><STRONG>Example 2.2.9</STRONG> <A 
   NAME="30002-7003t2.2.9"> </A> 
The finite-state transducer M<SUB>1</SUB>, whose transition diagram is given in Figure <A 
 HREF="#30002-5013r2.2.2">2.2.2</A>, is
deterministic. In each of its moves M<SUB>1</SUB> reads an input symbol. The transition rule to be
used in each move is uniquely determined by the state and the input symbol being
read.
   <P >If M<SUB>1</SUB> reads the input symbol a in the move from state q<SUB>0</SUB>, then M<SUB>1</SUB> must use
the transition rule (q<SUB>0</SUB>, a, q<SUB>1</SUB>, 1) in the move. If M<SUB>1</SUB> reads the input symbol b in
the move from state q<SUB>0</SUB> then M<SUB>1</SUB> must use the transition rule (q<SUB>0</SUB>, b, q<SUB>1</SUB>, <FONT FACE="SYMBOL">e</FONT>) in the
move.
   <P >On the other hand, consider the finite-state transducer M<SUB>2</SUB>, which satisfies
M<SUB>2</SUB> = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt; for Q = {q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>3</SUB>}, <FONT FACE="SYMBOL">S</FONT> = {a, b}, <FONT FACE="SYMBOL">D</FONT> = {a, b},
<FONT FACE="SYMBOL">d</FONT> = {(q<SUB>0</SUB>, a, q<SUB>1</SUB>, a), (q<SUB>1</SUB>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>2</SUB>, a), (q<SUB>2</SUB>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>1</SUB>, b), (q<SUB>2</SUB>, b, q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>), (q<SUB>2</SUB>, b, q<SUB>3</SUB>, a)}, and F = {q<SUB>3</SUB>}.
The transition diagram of M<SUB>2</SUB> is given in Figure <A 
 HREF="#30002-7004r2.2.7">2.2.7</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-7004r2.2.7"> </A>
<A 
   NAME="30002-7004r2.2.7"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-2-7.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.7 </STRONG></NOBR></TD><TD  
>A nondeterministic Turing transducer.                                                                         </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>M<SUB>2</SUB> is a nondeterministic finite-state transducer.
   <P >On moving from state q<SUB>0</SUB>, the finite-state transducer M<SUB>2</SUB> must read an input symbol.
On moving from state q<SUB>1</SUB>, the finite-state transducer M<SUB>2</SUB> does not read an input symbol.
The transition rules that M<SUB>2</SUB> can use on moving from states q<SUB>0</SUB> and q<SUB>1</SUB> are uniquely
determined by the states, and, therefore, these states are not the source for the
nondeterminism of M<SUB>2</SUB>.
   <P >The source for the nondeterminism of M<SUB>2</SUB> is in the transition rules that originate at
state q<SUB>2</SUB>. The transition rules do not determine whether M<SUB>2</SUB> has to read a symbol in moving
from state q<SUB>2</SUB>, nor do they specify which of the transition rules is to be used on the moves
that read the symbol b. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P ><EM><A 
   NAME="30002-8000"> </A><A 
 HREF="#Q2-30002-8"  NAME="Q1-30002-8">Computations of Finite-State Transducers</A></EM>
<A NAME="30002-8001"> </A>
   <P >The computations of the finite-state transducers are defined in a manner similar to that
for the programs. An <I>accepting<A NAME="30002-8002"> </A> computation</I> of a finite-state transducer M is a sequence of
moves of M that starts at an initial configuration and ends at an accepting configuration. A
<I>nonaccepting</I><A NAME="30002-8003"> </A>, or <I>rejecting</I>, <I>computation</I> of M is a sequence of moves on an input x for
which the following conditions hold.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="30002-8004xa"> </A>The sequence starts from the initial configuration of M on x.
     <LI><A 
   NAME="30002-8005xb"> </A>If the sequence is finite, then it ends at a configuration from which no move is
     possible.
     <LI><A 
   NAME="30002-8006xc"> </A>M has no accepting computation on x.</OL>
Each accepting computation and each nonaccepting computation of M is said to be a
<I>computation</I> of M.
   <P >A computation is said to be a <I>halting<A NAME="30002-8007"> </A> computation</I> if it consists of a finite number of
moves.
   <P ><STRONG>Example 2.2.10</STRONG> <A 
   NAME="30002-8008t2.2.10"> </A> 
Let M be the finite-state transducer of Example <A 
 HREF="#30002-5009t2.2.3">2.2.3</A> (see Figure <A 
 HREF="#30002-5013r2.2.2">2.2.2</A>). On input aabba
the finite-state transducer M has a computation that is given by the sequence
of moves in Example <A 
 HREF="#30002-6017t2.2.8">2.2.8</A> (see Figure <A 
 HREF="#30002-6018r2.2.6">2.2.6</A>). The computation is an accepting
one.
   <P >Alternatively, on input aab the finite-state transducer M has the following sequence of
moves: (q<SUB>0</SUB>aab, <FONT FACE="SYMBOL">e</FONT>) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aq<SUB>1</SUB>ab, 1) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aaq<SUB>0</SUB>b, 1) <IMG
SRC="cmsy10-60.gif" ALT=" |- "> (aabq<SUB>1</SUB>, 1). This sequence is the only one
possible from the initial configuration of M on input abb; it is a nonaccepting computation
of M.
   <P >The two computations in the example are halting computations of M. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P >By definition, on inputs that are accepted by a finite-state transducer the finite-state
transducer may have also executable sequences of transition rules which are not
considered to be computations.
   <P ><STRONG>Example 2.2.11</STRONG> <A 
   NAME="30002-8009t2.2.11"> </A> 
Consider the finite-state transducer M whose transition diagram is given in Figure <A 
 HREF="#30002-7004r2.2.7">2.2.7</A>.
On input ab, M has the accepting computation that moves along the sequence of states q<SUB>0</SUB>,
q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>3</SUB>. Similarly, on input ab, M also has an accepting computation that
moves along the sequence of states q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>3</SUB>. However, on input ab
across the states q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>0</SUB>, M's sequence of moves is not a computation of
M.
   <P >On input a the finite-state transducer has only one computation. The computation is a
nonhalting computation that goes along the sequence of states q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, <FONT FACE="SYMBOL">¼</FONT>  On the
other hand, on input aba the Turing transducer has infinitely many halting computations
and infinitely many nonhalting computations. All the computations on input aba are
nonaccepting computations.
   <P >The halting computations of M on input aba consume just the prefix ab of
M and move through the sequences q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, <FONT FACE="SYMBOL">¼</FONT> , q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>3</SUB> of states. The
nonhalting computations of M on input aba consume the input until its end and move
through the sequences q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, <FONT FACE="SYMBOL">¼</FONT> , q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, <FONT FACE="SYMBOL">¼</FONT> of states. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P >By definition, each move in each computation must be on a transition rule that
allows the computation to eventually read all the input and thereafter reach an
accepting state. Whenever more than one such alternative exists in the set of feasible
transition rules, any of these alternatives can be chosen. Similarly, whenever none
of the feasible transition rules satisfy the conditions above, then any of these
transition rules can be chosen. This fact suggests that we view the computations of
the finite-state transducers as being executed by imaginary agents with magical
power.
   <P >An input x is said to be <I>accepted</I><A NAME="30002-8010"> </A>, or <I>recognized</I><A NAME="30002-8011"> </A>, by a finite-state transducer M if M
has an accepting computation on x. An accepting computation that terminates in an
accepting configuration (xq<SUB>f</SUB>, y) is said to have an <I>output</I><A NAME="30002-8012"> </A> y. The output of a nonaccepting
computation is assumed to be undefined.<A NAME="30002-8013"> </A>
   <P >A finite-state transducer M is said to have an <I>output</I><A NAME="30002-8014"> </A> y on input x if it has an accepting
computation on x with output y. M is said to <I>halt</I><A NAME="30002-8015"> </A> on x if all the computations of M on
input x are halting computations.
   <P ><STRONG>Example 2.2.12</STRONG> <A 
   NAME="30002-8016t2.2.12"> </A> 
The finite-state transducer M whose transition diagram is given in Figure <A 
 HREF="#30002-8017r2.2.8">2.2.8</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-8017r2.2.8"> </A>
<A 
   NAME="30002-8017r2.2.8"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-2-8.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.8 </STRONG></NOBR></TD><TD  
>A nondeterministic finite-state transducer.                                                                   </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>has, on input baabb, a sequence of moves that goes through the states q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>1</SUB>, q<SUB>1</SUB>, q<SUB>1</SUB>, q<SUB>1</SUB>;
a sequence of moves that goes through the states q<SUB>0</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>; and a sequence of
moves that goes through the states q<SUB>0</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>, q<SUB>3</SUB>. The sequence of moves that goes
through the states q<SUB>0</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>, q<SUB>2</SUB>, q<SUB>3</SUB> is the only computation of M on input
baabb. The computation is an accepting computation that provides the output
111.
   <P >M accepts all inputs. However, the finite-state transducer of Example <A 
 HREF="#30002-8009t2.2.11">2.2.11</A> accepts
exactly those inputs that have the form ababa · · · bab. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >As in the case of programs, the semantics of the finite-state transducers are
characterized by their computations. Consequently, the behavior of these transducers are
labeled with respect to their computations.
   <P >For instance, a finite-state transducer M is said <I>to move</I> from configuration C<SUB>1</SUB> to
configuration C<SUB>2</SUB> on x if C<SUB>2</SUB> follows C<SUB>1</SUB> in the considered computation of M on x.
Similarly, M is said <I>to read</I> <FONT FACE="SYMBOL">a</FONT> from its input if <FONT FACE="SYMBOL">a</FONT> is consumed from the input in the
considered computation of M.<A NAME="30002-8018"> </A>
   <P ><STRONG>Example 2.2.13</STRONG> <A 
   NAME="30002-8019t2.2.13"> </A> 
The finite-state transducer whose transition diagram is given in Figure <A 
 HREF="#30002-8017r2.2.8">2.2.8</A> on input baabb
starts its computation with a move that takes M from state q<SUB>0</SUB> to state q<SUB>2</SUB>. M then makes
four moves, which consume baab and leave M in state q<SUB>2</SUB>. Finally, M moves from state q<SUB>2</SUB>
to state q<SUB>3</SUB> while reading b. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P ><EM><A 
   NAME="30002-9000"> </A><A 
 HREF="#Q2-30002-9"  NAME="Q1-30002-9">Relations and Languages of Finite-State Transducers</A></EM>
   <P >The relation <I>computed</I><A NAME="30002-9001"> </A> by a finite-state transducer M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt;, denoted
R(M), is the set { (x, y) | (q<SUB>0</SUB>x, <FONT FACE="SYMBOL">e</FONT>) <IMG
SRC="cmsy10-60.gif" ALT=" |- ">* (xq<SUB>f</SUB>, y) for some q<SUB>f</SUB> in F }. That is, the relation
computed by M is the set of all the pairs (x, y) such that M has an accepting computation
on input x with output y.
   <P >The language <I>accepted</I><A NAME="30002-9002"> </A>, or <I>recognized</I>, by M, denoted L(M), is the set of all the inputs
that M accepts, that is, the set { x | (x, y) is in R(M) for some y }. The language is
said to be <I>decided</I><A NAME="30002-9003"> </A> by M if, in addition, M halts on all inputs, that is, on all x in
<FONT FACE="SYMBOL">S</FONT>*.
   <P >The language <I>generated</I><A NAME="30002-9004"> </A> by M is the set of all the outputs that M has on its inputs, that
is, the set { y | (x, y) is in R(M) for some x }.
   <P ><STRONG>Example 2.2.14</STRONG> <A 
   NAME="30002-9005t2.2.14"> </A> 
The nondeterministic finite-state transducer M whose transition diagram is given in
Figure <A 
 HREF="#30002-8017r2.2.8">2.2.8</A> computes the relation R(M) = { (x, 1<SUP>i</SUP>) | x is in {a, b}*, i = number of a's in x
if the last symbol in x is a, and i = number of b's in x if the last symbol in x is
b }. The finite-state automaton M accepts the language L(M) = {a, b}*. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P ><STRONG>Example 2.2.15</STRONG> <A 
   NAME="30002-9006t2.2.15"> </A> 
The nondeterministic finite-state transducer M whose transition diagram is given in
Figure <A 
 HREF="#30002-9007r2.2.9">2.2.9</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-9007r2.2.9"> </A>
<A 
   NAME="30002-9007r2.2.9"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-2-9.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.9 </STRONG></NOBR></TD><TD  
>A finite-state transducer that computes the relation R(M) = { (x, y) | x and y are in
{a, b}*, and y<IMG 
SRC="theory-bk-two7x.gif" ALT="/="ALIGN="MIDDLE" > x }.                                                                                                    </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>computes the relation R(M) = { (x, y) | x and y are in {a, b}*, and y<IMG 
SRC="theory-bk-two8x.gif" ALT="/="ALIGN="MIDDLE" > x }.
   <P >As long as M is in its initial state &#34;x = y&#34; the output of M is equal to the portion of
the input consumed so far.
   <P >If M wants to provide an output that is a proper prefix of its input, then upon reaching
the end of the output, M must move from the initial state to state &#34;y is proper prefix of
x.&#34;
   <P >If M wants its input to be a proper prefix of its output, then M must move to state &#34;x is
a proper prefix of y&#34; upon reaching the end of the input.
   <P >Otherwise, at some nondeterministically chosen instance of the computation, M
must move to state &#34;x is not a prefix of y, and y is not a prefix of x,&#34; to create a
discrepancy between a pair of corresponding input and output symbols. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P ><EM><A 
   NAME="30002-10000"> </A><A 
 HREF="#Q2-30002-10"  NAME="Q1-30002-10">From Finite-State Transducers to Finite-Memory Programs</A></EM>
   <P >The previous discussion shows us that there is an algorithm that translates any given
finite-memory program into an equivalent finite-state transducer, that is, into a finite-state
transducer that computes the same relation as the program. Conversely, there is also an
algorithm that derives an equivalent finite-memory program from any given finite-state
transducer. The program can be a &#34;table-driven&#34; program that simulates a given
finite-state transducer M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt; in the manner described in
Figure <A 
 HREF="#30002-10001r2.2.10">2.2.10</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-10001r2.2.10"> </A>
        <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>state</TT> := q<SUB>0</SUB>
<B>do</B>
    /* Accept if an accepting state of M is reached at the end of the
    input.                                                                                     */
    <B>if</B> F(<TT>state</TT>) <B>then</B>
        <B>if</B> <I>eof</I> <B>then accept</B>
    /* Nondeterministically find the entries of the transition rule
    (q, <FONT FACE="SYMBOL">a</FONT>, p, <FONT FACE="SYMBOL">r</FONT>) used in the next simulated move.                         */
    <B>do</B> <TT>in</TT> := e <B>or</B> <B>read</B> <TT>in</TT> <B>until</B> true                  /* <TT>in</TT> := <FONT FACE="SYMBOL">a</FONT>  */
    <TT>next_ state</TT> := ?                            /* <TT>next_ state</TT> := p  */
    <TT>out</TT> := ?                                            /* <TT>out</TT> := <FONT FACE="SYMBOL">r</FONT>  */
    <B>if</B> not <FONT FACE="SYMBOL">d</FONT>(<TT>state</TT>, <TT>in</TT>, <TT>next_ state</TT>, <TT>out</TT>) <B>then reject</B>
    /* Simulate the move.  */
    <B>if</B> <TT>out</TT><IMG 
SRC="theory-bk-two9x.gif" ALT="/="ALIGN="MIDDLE" > e <B>then</B>
        <B>write</B> <TT>out</TT>
    <TT>state</TT> := <TT>next_ state</TT>
<B>until</B> false                                                          </PRE></TD></TR></TABLE>
<A 
   NAME="30002-10001r2.2.10"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.10 </STRONG></NOBR></TD><TD  
>A table-driven finite-memory program for simulating a finite-state transducer.          </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >The program uses a variable <TT>state</TT> for recording M's state in a given move, a variable
<TT>in</TT> for recording the input M consumes in a given move, a variable <TT>next_ state</TT> for recording
the state M enters in a given move, and a variable <TT>out</TT> for recording the output M writes in
a given move.
   <P >The program starts a simulation of M by initializing the variable <TT>state</TT> to the initial
state q<SUB>0</SUB> of M. Then M enters an infinite loop.
   <P >The program starts each iteration of the loop by checking whether an accepting state of
M has been reached at the end of the input. If such is the case, the program halts in
an accepting configuration. Otherwise, the program simulates a single move
of M. The predicate F is used to determine whether <TT>state</TT> holds an accepting
state.
   <P >The simulation of each move of M is done in a nondeterministic manner. The program
guesses the value for variable <TT>in</TT> that has to be read in the simulated move, the state for
variable <TT>next_ state</TT> that M enters in the simulated move, and the value for variable <TT>out</TT> that
the program writes in the simulated move. Then the program uses the predicate <FONT FACE="SYMBOL">d</FONT> to verify
that the guessed values are appropriate and continues according to the outcome of the
verification.
   <P >The domain of the variables of the program is assumed to equal Q <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">D</FONT> <FONT FACE="SYMBOL">È</FONT> {e},
where e is assumed to be a new symbol not in Q <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">D</FONT>, used for denoting the empty
string <FONT FACE="SYMBOL">e</FONT>.
   <P >In the table-driven program, F is a predicate that assumes a true value when, and only
when, its parameter is an accepting state. Similarly, <FONT FACE="SYMBOL">d</FONT> is a predicate that assumes a
true value when, and only when, its entries correspond to a transition rule of
M.
   <P >The programs that correspond to different finite-state transducers differ in the
domains of their variables and in the truth assignments for the predicates F and
<FONT FACE="SYMBOL">d</FONT>.
   <P >The algorithm can be easily modified to give a deterministic finite-memory program
whenever the finite-state transducer M is deterministic.
   <P ><STRONG>Example 2.2.16</STRONG> <A 
   NAME="30002-10002t2.2.16"> </A> 
For the finite-state transducer M of Figure <A 
 HREF="#30002-10003r2.2.11">2.2.11</A>(a),
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-10003r2.2.11"> </A>
<A 
   NAME="30002-10003r2.2.11"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-2-11.jpg" ALT="[PICT]" 
>
   <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.11 </STRONG></NOBR></TD><TD  
>(a) A finite-state transducer M. (b) Tables for a table-driven program that simulates
M. (c) Tables for a deterministic table-driven program that simulates M.                  </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>the program in Figure <A 
 HREF="#30002-10001r2.2.10">2.2.10</A> has the domain of variables {a, b, 1, q<SUB>0</SUB>, q<SUB>1</SUB>, e}. The
truth values of the predicates F and <FONT FACE="SYMBOL">d</FONT> are defined by the corresponding tables of
Figure <A 
 HREF="#30002-10003r2.2.11">2.2.11</A>(b).
   <P >The program also allows that for F and <FONT FACE="SYMBOL">d</FONT> there are parameters that differ from
those specified in the tables. On such parameters the predicates are assumed to be
undefined.
   <P >The finite-state transducer can be simulated also by the deterministic table-driven
program in Figure <A 
 HREF="#30002-10004r2.2.12">2.2.12</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-10004r2.2.12"> </A>
                   <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>state</TT> := q<SUB>0</SUB>
<B>do</B>
    <B>if</B> F(<TT>state</TT>) <B>then</B>
        <B>if</B> <I>eof</I> <B>then accept</B>
    <B>if</B> not <FONT FACE="SYMBOL">d</FONT><SUB>in</SUB>(<TT>state</TT>) <B>then</B>
        <TT>in</TT> := e
   <B>if</B> <FONT FACE="SYMBOL">d</FONT><SUB>in</SUB>(<TT>state</TT>) <B>then</B>
        <B>read</B> <TT>in</TT>
    <TT>next_ state</TT> := <FONT FACE="SYMBOL">d</FONT><SUB>state</SUB>(<TT>state</TT>, <TT>in</TT>)
   <TT>out</TT> := <FONT FACE="SYMBOL">d</FONT><SUB>out</SUB>(<TT>state</TT>, <TT>in</TT>)
   <B>if</B> <TT>out</TT><IMG 
SRC="theory-bk-two10x.gif" ALT="/="ALIGN="MIDDLE" > e <B>then</B>
        <B>write</B> <TT>out</TT>
    <TT>state</TT> := <TT>next_ state</TT>
<B>until</B> false                         </PRE></TD></TR></TABLE>
<A 
   NAME="30002-10004r2.2.12"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.12 </STRONG></NOBR></TD><TD  
>A table-driven, deterministic finite-memory program for simulating a deterministic
finite-state transducer.                                                                                                  </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>F is assumed to be a predicate as before, and <FONT FACE="SYMBOL">d</FONT><SUB>in</SUB>, <FONT FACE="SYMBOL">d</FONT><SUB>out</SUB>, and <FONT FACE="SYMBOL">d</FONT><SUB>state</SUB> are assumed to be
defined by the corresponding tables in Figure <A 
 HREF="#30002-10003r2.2.11">2.2.11</A>(c).
   <P >The predicate <FONT FACE="SYMBOL">d</FONT><SUB>in</SUB> determines whether an input symbol is to be read on moving
from a given state. The function <FONT FACE="SYMBOL">d</FONT><SUB>out</SUB> determines the output to be written in each
simulated move, and <FONT FACE="SYMBOL">d</FONT><SUB>state</SUB> determines the state to be reached in each simulated
state.
   <P >The deterministic finite-state transducer can be simulated also by a non-table-driven
finite-memory program of the form shown in Figure <A 
 HREF="#30002-10005r2.2.13">2.2.13</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30002-10005r2.2.13"> </A>
                       <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>state</TT> := q<SUB>0</SUB>
<B>do</B>
    <B>if</B> <TT>state</TT> = q<SUB>0</SUB> <B>then</B>
    <B>do</B>
        <B>read</B> <TT>in</TT>
        <B>if</B> <TT>in</TT> = a <B>then</B>
        <B>do</B>
            <TT>state</TT> := q<SUB>1</SUB>
           <TT>out</TT> := 1
         <B>write</B> <TT>out</TT>
        <B>until</B> true
      <B>if</B> <TT>in</TT> = b <B>then</B>
            <TT>state</TT> := q<SUB>1</SUB>
    <B>until</B> true
   <B>if</B> <TT>state</TT> = q<SUB>1</SUB> <B>then</B>
    <B>do</B>
        <B>if</B> <I>eof</I> <B>then accept</B>
        <TT>state</TT> := q<SUB>0</SUB>
       <TT>out</TT> := 1
      <B>write</B> <TT>out</TT>
    <B>until</B> true
<B>until</B> false               </PRE></TD></TR></TABLE>
<A 
   NAME="30002-10005r2.2.13"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.2.13 </STRONG></NOBR></TD><TD  
>A   non-table-driven   deterministic   finite-memory   program   that   simulates   the
deterministic finite-state transducer of Figure <A 
 HREF="#30002-10003r2.2.11">2.2.11</A>(a).                                              </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>In such a case, through conditional if instructions, the program explicitly records the effect
of F, <FONT FACE="SYMBOL">d</FONT><SUB>in</SUB>, <FONT FACE="SYMBOL">d</FONT><SUB>out</SUB>, and <FONT FACE="SYMBOL">d</FONT><SUB>state</SUB>. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >It follows that the finite-state transducers characterize the finite-memory programs, and
so they can be used for designing and analyzing finite-memory programs. As a result, the
study conducted below for finite-state transducers applies also for finite-memory
programs.
   <P >Finite-state transducers offer advantages in
     <OL TYPE="a" 
>
     <LI><A 
   NAME="30002-10006xa"> </A>Their straightforward graphic representations, which are in many instances
     more &#34;natural&#34; than finite-memory programs.
     <LI><A 
   NAME="30002-10007xb"> </A>Their  succinctness,  because  finite-state  transducers  are  abstractions  that
     ignore those details irrelevant to the study undertaken.
     <LI><A 
   NAME="30002-10008xc"> </A>The close dependency of the outputs on the inputs.<A NAME="30002-10009"> </A></OL>
   <P >
   <P >[<A 
 HREF="theory-bk-twose3.html" >next</A>] [<A 
 HREF="theory-bk-twose1.html" >prev</A>] [<A 
 HREF="theory-bk-twose1.html#tailtheory-bk-twose1.html" >prev-tail</A>] [<A 
 HREF="theory-bk-twose2.html" >front</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose2.html" >up</A>] <A 
   NAME="tailtheory-bk-twose2.html"> </A></BODY></HTML>