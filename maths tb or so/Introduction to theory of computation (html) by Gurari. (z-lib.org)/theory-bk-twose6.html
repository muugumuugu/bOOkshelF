
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-two.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-twoli1.html" >next</A>] [<A 
 HREF="theory-bk-twose5.html" >prev</A>] [<A 
 HREF="theory-bk-twose5.html#tailtheory-bk-twose5.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-twose6.html">tail</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose6.html" >up</A>]
<H3>2.6 <A 
   NAME="30006-220002.6"> </A><A 
 HREF="theory-bk.html#Q2-30006-22"  NAME="Q1-30006-22">Decidable Properties for Finite-Memory Programs</A></H3>
   <P >
<A NAME="30006-22001"> </A>
   <P >The emptiness<A NAME="30006-22002"> </A> problem, the equivalence<A NAME="30006-22003"> </A> problem, the halting<A NAME="30006-22004"> </A> problem, and other
decision problems for finite-memory programs or, equivalently, for finite-state transducers
are defined in a similar manner as for the general class of programs.
   <P >For instance, the equivalence problem for finite-state transducers asks for any given
pair of finite-state transducers whether or not the transducers compute the same
relation.
   <P >Similarly, the halting problem for finite-state transducers asks for any given pair
(M, x), of a finite-state transducer M and of an input x for M, whether or not M has only
halting computations on x.
   <P >In this section, some properties of finite-state transducers are shown to be
decidable. The proofs are constructive in nature and they therefore imply effective
algorithms for determining the properties in discourse. The first theorem is interesting
mainly for its applications (see Example <A 
 HREF="theory-bk-twose1.html#30001-2005t2.1.2">2.1.2</A>). It is concerned with the problem
of determining whether an arbitrarily given finite-state automaton accepts no
input.
   <P ><STRONG>Theorem 2.6.1</STRONG> <A 
   NAME="30006-22005t2.6.1"> </A> 
The emptiness problem is decidable for finite-state automata.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30006-22006t"> </A> 
Consider any finite-state automaton M. M accepts some input if and only if there is a path
in its transition diagram from the node that corresponds to the initial state to a node that
corresponds to an accepting state. The existence of such a path can be determined by the
following algorithm.
    <DL><DT><STRONG>
 <STRONG>Step 1</STRONG> </STRONG><DD 
>Mark in the transition diagram the node that corresponds to the initial state
    of M.
    <DT><STRONG>
 <STRONG>Step 2</STRONG> </STRONG><DD 
>Repeatedly mark those unmarked nodes in the transition diagram that are
    reachable  by  an  edge  from  a  marked  node.  Terminate  the  process  when  no
    additional nodes can be marked.
    <DT><STRONG>
 <STRONG>Step 3</STRONG> </STRONG><DD 
>If the transition diagram contains a marked node that corresponds to an
    accepting state, then determine that L(M) is not empty. Otherwise, determine
    that L(M) is empty. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 ></DL>
   <P >
   <P >By definition, a program has only halting computations on inputs that it accepts. On
the other hand, on each input that it does not accept, the program may have some
computations that never terminate.
   <P >An important general determination about programs is whether they halt
on all inputs. The proof of the following theorem indicates how, in the case of
finite-memory programs, the uniform halting problem can be reduced to the emptiness
problem.<A NAME="30006-22007"> </A>
   <P ><STRONG>Theorem 2.6.2</STRONG> <A 
   NAME="30006-22008t2.6.2"> </A> 
The uniform halting problem is decidable for finite-state automata.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30006-22009t"> </A> 
Consider any finite-state automaton M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt;. With no loss of generality,
assume that the symbol c is not in <FONT FACE="SYMBOL">S</FONT>, and that Q has n states. In addition, assume that
every state from which M can reach an accepting state by reading nothing is also an
accepting state. Let A be a finite-state automaton obtained from M by replacing each <FONT FACE="SYMBOL">e</FONT>
transition rule of the form (q, <FONT FACE="SYMBOL">e</FONT>, p) with a transition rule of the form (q, c, p). Let B be a
finite-state automaton that accepts the language { x | x is in (<FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> {c})*, and c<SUP>n</SUP> is a
substring of x }.
   <P >M has a nonhalting computation on a given input if and only if the following two
conditions hold.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="30006-22010xa"> </A>The input is not accepted by M.
     <LI><A 
   NAME="30006-22011xb"> </A>On the given input M can reach a state that can be repeated without reading
     any input symbol.</OL>
Consequently, M has a nonhalting computation if and only if A accepts some input that
has c<SUP>n</SUP> as a substring.
   <P >By the proof of Theorem <A 
 HREF="theory-bk-twose5.html#30005-21013t2.5.2">2.5.2</A>, a finite-state automaton C can be constructed to accept
the complementation of L(A). By that same proof, a finite-state automaton D can also be
constructed to accept the intersection of L(B) and L(C).
   <P >By construction, D is a finite-state automaton that accepts exactly those inputs that
have c<SUP>n</SUP> as a substring and that are not accepted by A. That is, D accepts no input if and
only if M halts on all inputs. The theorem thus follows from Theorem <A 
 HREF="#30006-22005t2.6.1">2.6.1</A>. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P >For finite-memory programs that need not halt on all inputs, the proof of the following
result implies an algorithm to decide whether or not they halt on specifically given
inputs.
   <P ><STRONG>Theorem 2.6.3</STRONG> <A 
   NAME="30006-22012t2.6.3"> </A> 
The halting<A NAME="30006-22013"> </A> problem is decidable for finite-state automata.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30006-22014t"> </A> 
Consider any finite-state automaton M and any input a<SUB>1</SUB> · · · a<SUB>n</SUB> for M. As in the proof of
Theorem <A 
 HREF="theory-bk-twose3.html#30003-13001t2.3.1">2.3.1</A>, one can derive for each i = 1,<FONT FACE="SYMBOL"> ¼</FONT>, n the set A<SUB>a<SUB>1</SUB>··· a<SUB>i</SUB></SUB> of all the states that can
be reached by consuming a<SUB>1</SUB> · · · a<SUB>i</SUB>. Then M is determined to halt on a<SUB>1</SUB> · · · a<SUB>n</SUB> if and only
if either of the following two conditions hold.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="30006-22015xa"> </A>A<SUB>a<SUB>1</SUB>··· a<SUB>n</SUB></SUB>  contains  an  accepting  state.
     <LI><A 
   NAME="30006-22016xb"> </A>For no integer i such that 1 <FONT FACE="SYMBOL">£</FONT> i <FONT FACE="SYMBOL">£</FONT> n the set A<SUB>a<SUB>1</SUB>··· a<SUB>i</SUB></SUB> contains a state that can
     be reached from itself by a sequence of one or more moves on <FONT FACE="SYMBOL">e</FONT> transition
     rules.<IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 ></OL>
   <P >
   <P >There are many other properties that are decidable for finite-memory programs. This
section concludes with the following theorem.
   <P ><STRONG>Theorem 2.6.4</STRONG> <A 
   NAME="30006-22017t2.6.4"> </A> 
The equivalence problem is decidable for finite-state automata.<A NAME="30006-22018"> </A>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30006-22019t"> </A> 
Two finite-state automata M<SUB>1</SUB> and M<SUB>2</SUB> are equivalent if and only if the relation
(L(M<SUB>1</SUB>) <FONT FACE="SYMBOL">Ç</FONT> <IMG 
SRC="theory-bk-two24x.gif" ALT="------
L(M2)">) <FONT FACE="SYMBOL">È</FONT> (<IMG 
SRC="theory-bk-two25x.gif" ALT="------
L(M1)"> <FONT FACE="SYMBOL">Ç</FONT> L(M<SUB>2</SUB>)) = Ø holds, where <IMG 
SRC="theory-bk-two26x.gif" ALT="------
L(Mi)"> denotes the
complementation of L(M<SUB>i</SUB>) for i = 1, 2. The result then follows from the proof of
Theorem <A 
 HREF="theory-bk-twose5.html#30005-21013t2.5.2">2.5.2</A> and from Theorem <A 
 HREF="#30006-22005t2.6.1">2.6.1</A>. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >The result in Theorem <A 
 HREF="#30006-22017t2.6.4">2.6.4</A> can be shown to hold also for deterministic finite-state
transducers (see Corollary <A 
 HREF="theory-bk-threese6.html#40006-29008t3.6.1">3.6.1</A>). However, for the general class of finite-state transducers
the equivalence problem can be shown to be undecidable (see Corollary <A 
 HREF="theory-bk-fourse7.html#50007-24001t4.7.1">4.7.1</A>).<A NAME="30006-22020"> </A><A NAME="30006-22021"> </A>
   <P >
   <P >[<A 
 HREF="theory-bk-twoli1.html" >next</A>] [<A 
 HREF="theory-bk-twose5.html" >prev</A>] [<A 
 HREF="theory-bk-twose5.html#tailtheory-bk-twose5.html" >prev-tail</A>] [<A 
 HREF="theory-bk-twose6.html" >front</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose6.html" >up</A>] <A 
   NAME="tailtheory-bk-twose6.html"> </A></BODY></HTML>