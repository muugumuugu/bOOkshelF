
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-two.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-twose5.html" >next</A>] [<A 
 HREF="theory-bk-twose3.html" >prev</A>] [<A 
 HREF="theory-bk-twose3.html#tailtheory-bk-twose3.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-twose4.html">tail</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose4.html" >up</A>]
<H3>2.4 <A 
   NAME="30004-170002.4"> </A><A 
 HREF="theory-bk.html#Q2-30004-17"  NAME="Q1-30004-17">Limitations of Finite-Memory Programs</A></H3>
   <P >
      <A 
 HREF="#Q1-30004-18"  NAME="Q2-30004-18">A Pumping Lemma for Regular Languages</A>
<BR>         <A 
 HREF="#Q1-30004-19"  NAME="Q2-30004-19">Applications of the Pumping Lemma</A>
<BR>         <A 
 HREF="#Q1-30004-20"  NAME="Q2-30004-20">A Generalization to the Pumping Lemma</A>
   <P >It can be intuitively argued that there are computations that finite-memory programs
cannot carry out, because of the limitations imposed on the amount of memory the
programs can use. For instance, it can be argued that { a<SUP>n</SUP>b<SUP>n</SUP> | n <FONT FACE="SYMBOL">³</FONT> 0 } is not recognizable
by any finite-memory program. The reasoning here is that upon reaching the first b in a
given input, the program must remember how many a's it read. Moreover, the
argument continues that each finite-memory program has an upper bound on
the number of values that it can record, whereas no such bound exists on the
number of a's that the inputs can contain. As a result, one can conclude that each
finite-memory program can recognize only a finite number of strings in the set
{ a<SUP>n</SUP>b<SUP>n</SUP> | n <FONT FACE="SYMBOL">³</FONT> 0 }.
   <P >The purposes of this section are to show that there are computations that cannot be
carried out by finite-memory programs, and to provide formal tools for identifying
such computations. The proofs rely on abstractions of the intuitive argument
above. However, it should be mentioned that the problem of determining for
any given language, whether the language is recognizable by a finite-memory
program, can be shown to be undecidable (see Theorem <A 
 HREF="theory-bk-fourse5.html#50005-20016t4.5.6">4.5.6</A>). Therefore, no tool
can be expected to provide an algorithm that decides the problem in its general
form.
   <P ><EM><A 
   NAME="30004-18000"> </A><A 
 HREF="#Q2-30004-18"  NAME="Q1-30004-18">A Pumping Lemma for Regular Languages</A></EM>
   <P >The following theorem provides necessary conditions for a language to be decidable
by a finite-memory program. The proof of the theorem relies on the observations that the
finite-memory programs must repeat a state on long inputs, and that the subcomputations
between the repetitions of the states can be pumped.
   <P ><STRONG>Theorem 2.4.1</STRONG> <A 
   NAME="30004-18001t2.4.1"> </A> 
(Pumping lemma<A NAME="30004-18002"> </A> for regular languages) Every regular language L has a number m for
which the following conditions hold. If w is in L and |w| <FONT FACE="SYMBOL">³</FONT> m, then w can be
written as xyz, where xy<SUP>k</SUP>z is in L for each k <FONT FACE="SYMBOL">³</FONT> 0. Moreover, |xy| <FONT FACE="SYMBOL">£</FONT> m, and
|y| &gt; 0.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30004-18003t"> </A> 
Consider any regular language L. Let M be a finite-state automaton that recognizes L. By
Theorem <A 
 HREF="theory-bk-twose3.html#30003-13001t2.3.1">2.3.1</A> it can be assumed that M has no <FONT FACE="SYMBOL">e</FONT> transition rules. Denote by m the number
of states of M.
   <P >On input w = a<SUB>1</SUB> · · · a<SUB>n</SUB> from L the finite-state automaton M has a computation of the
form
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-two13x.gif" ALT=" p0a1···an |-  a1p1a2···an |-  ···  |- a1···aipiai+1···an  |-  ···  |- 
          a1··· ajpjaj+1···an  |- ···  |- a1 ···anpn"></PRE></CENTER>
   <P >The computation goes through some sequence p<SUB>0</SUB>, p<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , p<SUB>n</SUB> of n + 1 states, where p<SUB>0</SUB> is
the initial state of M and p<SUB>n</SUB> is an accepting state of M. In each move of the computation
exactly one input symbol is being read.
   <P >If the length n of the input is equal at least to the number m of states of M, then the
computation consists of m or more moves and some state q must be repeated
within the first m moves. That is, if n <FONT FACE="SYMBOL">³</FONT> m then p<SUB>i</SUB> = p<SUB>j</SUB> for some i and j such
that 0 <FONT FACE="SYMBOL">£</FONT> i &lt; j <FONT FACE="SYMBOL">£</FONT> m. In such a case, take x = a<SUB>1</SUB> · · · a<SUB>i</SUB>, y = a<SUB>i+1</SUB> · · · a<SUB>j</SUB>, and
z = a<SUB>j+1</SUB> · · · a<SUB>n</SUB>.
   <P >With such a decomposition xyz of w the above computation of M takes the
form
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-two14x.gif" ALT=" p xyz |- * xqyz |-  *xyqz  |- *xyzp
 0                        n"></PRE></CENTER>
   <P >During the computation the state q = p<SUB>i</SUB> = p<SUB>j</SUB> of M is repeated. The string x is
consumed before reaching the state q that is repeated. The string y is consumed between
the repetition of the state q. The string z is consumed after the repetition of state
q.
   <P >Consequently, M also has an accepting computation of the form
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-two15x.gif" ALT="     k   *   k   *     k- 1  *     *   k   *   k
p0xy z  |-  xqy z  |-  xyqy  z |-  ··· |-  xy qz |-  xy zpn"></PRE></CENTER>
   <P >for each k <FONT FACE="SYMBOL">³</FONT> 0. That is, M has an accepting computation on xy<SUP>k</SUP>z for each k <FONT FACE="SYMBOL">³</FONT> 0,
where M starts and ends consuming each y in state q.
   <P >The substring y that is consumed between the repetition of state q is not empty,
because by assumption M has no <FONT FACE="SYMBOL">e</FONT> transition rules. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P ><STRONG>Example 2.4.1</STRONG> <A 
   NAME="30004-18004t2.4.1"> </A> 
Let L be the regular language accepted by the finite-state automaton of Figure <A 
 HREF="#30004-18005r2.4.1">2.4.1</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30004-18005r2.4.1"> </A>
<A 
   NAME="30004-18005r2.4.1"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-4-1.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.4.1 </STRONG></NOBR></TD><TD  
>A finite-state automaton.                                                                                              </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Using the terminology in the proof of the pumping lemma (Theorem <A 
 HREF="#30004-18001t2.4.1">2.4.1</A>), L has the
constant m = 3.
   <P >On input w = ababaa, the finite-state automaton goes through the sequence q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>0</SUB>,
q<SUB>1</SUB>, q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB> of states. For such an input the pumping lemma provides the decomposition
x = <FONT FACE="SYMBOL">e</FONT>, y = ab, z = abaa; and the decomposition x = a, y = ba, z = baa. The first
decomposition is due to the first repetition of state q<SUB>0</SUB>; the second is a result of to the first
repetition of state q<SUB>1</SUB>.
   <P >For each string w of a minimum length 3, the pumping lemma implies a decomposition
xyz in which the string y must be either ab or ba or ac. If y = ab, then x = <FONT FACE="SYMBOL">e</FONT>
and the repetition of q<SUB>0</SUB> is assumed. If y = ba, then x = a and the repetition of
q<SUB>1</SUB> is assumed. If y = ac, then x = a and the repetition of q<SUB>1</SUB> is assumed. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P ><EM><A 
   NAME="30004-19000"> </A><A 
 HREF="#Q2-30004-19"  NAME="Q1-30004-19">Applications of the Pumping Lemma</A></EM>
   <P >For proving that a given language L is not regular, the pumping lemma implies the
following schema of reduction to contradiction.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="30004-19001xa"> </A>For the purpose of the proof assume that L is a regular language.
     <LI><A 
   NAME="30004-19002xb"> </A>Let m denote the constant implied by the pumping lemma for L, under the
     assumption in (a) that L is regular.
     <LI><A 
   NAME="30004-19003xc"> </A>Find a string w in L, whose length is at least m. Require that w implies a k,
     for each decomposition xyz of w, such that xy<SUP>k</SUP>z is not in L. That is, find a w
     that implies, by using the pumping lemma, that a string not in L must, in fact,
     be there.
     <LI><A 
   NAME="30004-19004xd"> </A>Use the contradiction in (c) to conclude that the pumping lemma does not
     apply for L.
     <LI><A 
   NAME="30004-19005xe"> </A>Use the conclusion in (d) to imply that the assumption in (a), that L is regular,
     is false.</OL>
It should be emphasized that in the previous schema the pumping lemma implies
only the existence of a constant m for the assumed regular language L, and the
existence of a decomposition xyz for the chosen string w. This lemma does not
provide any information about the specific values of m, x, y, and z besides the
restriction that they satisfy the conditions |xy| <FONT FACE="SYMBOL">£</FONT> m and |y| &gt; 0. The importance
for the schema of the condition |xy| <FONT FACE="SYMBOL">£</FONT> m lies in allowing some limitation on
the possible decompositions that are to be considered for the chosen w. The
importance of the restriction |y| &gt; 0 is in enabling a proper change in the pumped
string.
   <P ><STRONG>Example 2.4.2</STRONG> <A 
   NAME="30004-19006t2.4.2"> </A> 
Consider the nonregular language L = { 0<SUP>n</SUP>1<SUP>n</SUP> | n <FONT FACE="SYMBOL">³</FONT> 0 }. To prove that L is nonregular
assume to the contrary that it is regular. From the assumption that L is regular deduce the
existence of a fixed constant m that satisfies the conditions of the pumping lemma for
L.
   <P >Choose the string w = 0<SUP>m</SUP>1<SUP>m</SUP> in L. By the pumping lemma, 0<SUP>m</SUP>1<SUP>m</SUP> has a
decomposition of the form xyz, where |xy| <FONT FACE="SYMBOL">£</FONT> m, |y| &gt; 0, and xy<SUP>k</SUP>z is in L for
each k <FONT FACE="SYMBOL">³</FONT> 0. That is, the decomposition must be of the form x = 0<SUP>i</SUP>, y = 0<SUP>j</SUP>, and
z = 0<SUP>m-i-j</SUP>1<SUP>m</SUP> for some i and j such that j &gt; 0. (Note that the values of i, j,
and m cannot be chosen arbitrarily.) Moreover, xy<SUP>0</SUP>z must be in L. However,
xy<SUP>0</SUP>z = 0<SUP>m-j</SUP>1<SUP>m</SUP> cannot be in L because j &gt; 0. It follows that the pumping
lemma does not apply for L, consequently contradicting the assumption that L is
regular.
   <P >Other choices of w can also be used to show that L is not regular. However, they might
result in a more complex analysis. For instance, for w = 0<SUP>m-1</SUP>1<SUP>m-1</SUP> the pumping lemma
provides three possible forms of decompositions:
     <OL TYPE="a" 
>
     <LI><A 
   NAME="30004-19007xa"> </A>x = 0<SUP>i</SUP>, y = 0<SUP>j</SUP>, z = 0<SUP>m-i-j-1</SUP>1<SUP>m-1</SUP> for some j &gt; 0.
     <LI><A 
   NAME="30004-19008xb"> </A>x = 0<SUP>m-1-j</SUP>, y = 0<SUP>j</SUP>1, z = 1<SUP>m-2</SUP> for some j &gt; 0.
     <LI><A 
   NAME="30004-19009xc"> </A>x = 0<SUP>m-1</SUP>, y = 1, z = 1<SUP>m-2</SUP>.</OL>
In such a case, each of the three forms of decompositions must be shown to be
inappropriate to conclude that the pumping lemma does not apply to w. For (a) the choice
of k = 0 provides xy<SUP>0</SUP>z = 0<SUP>m-1-j</SUP>1<SUP>m-1</SUP> not in L. For (b) the choice of k = 2 provides
xy<SUP>2</SUP>z = 0<SUP>m-1</SUP>10<SUP>j</SUP>1<SUP>m-1</SUP> not in L. For (c) the choice of c = 0 provides xy<SUP>0</SUP>z = 0<SUP>m-1</SUP>1<SUP>m-2</SUP>
not in L. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P ><STRONG>Example 2.4.3</STRONG> <A 
   NAME="30004-19010t2.4.3"> </A> 
Consider the nonregular language L = { <FONT FACE="SYMBOL">a</FONT><FONT FACE="SYMBOL">a</FONT><SUP>rev</SUP> | <FONT FACE="SYMBOL">a</FONT> is in {a, b}* }. To prove that L is
not regular assume to the contrary that it is regular. Then deduce the existence
of a fixed constant m that satisfies the conditions of the pumping lemma for
L.
   <P >Choose w = a<SUP>m</SUP>bba<SUP>m</SUP> in L. By the pumping lemma, a<SUP>m</SUP>bba<SUP>m</SUP> = xyz for some x, y,
and z such that |xy| <FONT FACE="SYMBOL">£</FONT> m, |y| &gt; 0 and xy<SUP>k</SUP>z is in L for each k <FONT FACE="SYMBOL">³</FONT> 0. That is,
x = a<SUP>i</SUP>, y = a<SUP>j</SUP>, and z = a<SUP>m-i-j</SUP>bba<SUP>m</SUP> for some i and j such that j &gt; 0. However,
xy<SUP>0</SUP>z = a<SUP>m-j</SUP>bba<SUP>m</SUP> is not in L, therefore contradicting the assumption that L is
regular.
   <P >It should be noted that not every choice for w implies the desired contradiction. For
instance, consider the choice of a<SUP>2m</SUP> for w. By the pumping lemma, a<SUP>2m</SUP> has a
decomposition xyz in which x = a<SUP>i</SUP>, y = a<SUP>j</SUP>, and z = a<SUP>2m-i-j</SUP> for some i and j such that
j &gt; 0. With such a decomposition, xy<SUP>k</SUP>z = a<SUP>2m+(k-1)j</SUP> is not in L if and only if
2m + (k - 1)j is an odd integer. On the other hand, 2m + (k - 1)j is an odd
integer if and only if k is an even number and j is an odd number. However,
although k can arbitrarily be chosen to equal any value, such is not the case with j.
Consequently, the choice of a<SUP>2m</SUP> for w does not guarantee the desired contradiction. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P ><EM><A 
   NAME="30004-20000"> </A><A 
 HREF="#Q2-30004-20"  NAME="Q1-30004-20">A Generalization to the Pumping Lemma</A></EM>
   <P >The proof of the pumping lemma is based on the observation that a state is repeated in
each computation on a &#34;long&#34; input, with a portion of the input being consumed between
the repetition. The repetition of the state allows the pumping of the subcomputation
between the repetition to obtain new accepting computations on different inputs. The proof
of the pumping lemma with minor modifications also holds for the following more general
theorem.
   <P ><STRONG>Theorem 2.4.2</STRONG> <A 
   NAME="30004-20001t2.4.2"> </A> 
For each relation R that is computable by a finite-state transducer, there exists a constant
m that satisfies the following conditions. If (v, w) is in R and |v| + |w| <FONT FACE="SYMBOL">³</FONT> m, then v can be
written as x<SUB>v</SUB>y<SUB>v</SUB>z<SUB>v</SUB> and w can be written as x<SUB>w</SUB>y<SUB>w</SUB>z<SUB>w</SUB>, where (x<SUB>v</SUB>y<SUB>v</SUB><SUP>k</SUP>z<SUB>v</SUB>, x<SUB>w</SUB>y<SUB>w</SUB><SUP>k</SUP>z<SUB>w</SUB>) is in R
for each k <FONT FACE="SYMBOL">³</FONT> 0. Moreover, |x<SUB>v</SUB>y<SUB>v</SUB>| + |x<SUB>w</SUB>y<SUB>w</SUB>| <FONT FACE="SYMBOL">£</FONT> m, and |y<SUB>v</SUB>| + |y<SUB>w</SUB>| &gt; 0.
   <P >
   <P >A schema, similar to the one that uses the pumping lemma for determining nonregular
languages, can utilize Theorem <A 
 HREF="#30004-20001t2.4.2">2.4.2</A> for determining relations that are not computable by
finite-state transducers.
   <P ><STRONG>Example 2.4.4</STRONG> <A 
   NAME="30004-20002t2.4.4"> </A> 
The relation R = { (u, u<SUP>rev</SUP>) | u is in {0, 1}* } is not computable by a finite-state
transducer. If R were computable by a finite-state transducer, then there would be a
constant m that satisfies the conditions of Theorem <A 
 HREF="#30004-20001t2.4.2">2.4.2</A> for R. In such a case, since
(0<SUP>m</SUP>1<SUP>m</SUP>, 1<SUP>m</SUP>0<SUP>m</SUP>) is in R, then u = 0<SUP>m</SUP>1<SUP>m</SUP> could be written as x<SUB>v</SUB>y<SUB>v</SUB>z<SUB>v</SUB> and u<SUP>rev</SUP> = 1<SUP>m</SUP>0<SUP>m</SUP>
could be written as x<SUB>w</SUB>y<SUB>w</SUB>z<SUB>w</SUB>, where x<SUB>v</SUB> = 0<SUP>i<SUB>v</SUB></SUP>, y<SUB>v</SUB> = 0<SUP>j<SUB>v</SUB></SUP>, z<SUB>v</SUB> = 0<SUP>m-i<SUB>v</SUB>-j<SUB>v</SUB></SUP>1<SUP>m</SUP>, x<SUB>w</SUB>  =  1<SUP>i<SUB>w</SUB></SUP>,
y<SUB>w</SUB> = 1<SUP>j<SUB>w</SUB></SUP>, z<SUB>w</SUB> = 1<SUP>m-i<SUB>w</SUB>-j<SUB>w</SUB></SUP>0<SUP>m</SUP>, and j<SUB>v</SUB> + j<SUB>w</SUB> &gt; 0. Moreover, it would be implied that
(x<SUB>v</SUB>y<SUB>v</SUB><SUP>0</SUP>z<SUB>v</SUB>, x<SUB>w</SUB>y<SUB>w</SUB><SUP>0</SUP>z<SUB>w</SUB>) = (0<SUP>m-j<SUB>v</SUB></SUP>1<SUP>m</SUP>, 1<SUP>m-j<SUB>w</SUB></SUP>0<SUP>m</SUP>) must also be in R, which is not the case. <IMG 
SRC="theory-bk-two2x.gif" ALT="
*** " 
 >
   <P >
   <P >
   <P >[<A 
 HREF="theory-bk-twose5.html" >next</A>] [<A 
 HREF="theory-bk-twose3.html" >prev</A>] [<A 
 HREF="theory-bk-twose3.html#tailtheory-bk-twose3.html" >prev-tail</A>] [<A 
 HREF="theory-bk-twose4.html" >front</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose4.html" >up</A>] <A 
   NAME="tailtheory-bk-twose4.html"> </A></BODY></HTML>