<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-two.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-twose2.html" >next</A>] [<A 
 HREF="#tailtheory-bk-twose1.html">tail</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose1.html" >up</A>]
<H3>2.1 <A 
   NAME="30001-20002.1"> </A><A 
 HREF="theory-bk.html#Q2-30001-2"  NAME="Q1-30001-2">Motivation</A></H3>
   <P >
   <P >It is often useful when developing knowledge in a new field to start by considering
restricted cases and then gradually expand to the general case. Such an approach allows a
gradual increase in the complexity of the argumentation. In particular, it is a quite
common strategy in the investigation of infinite systems to start by considering
finite subsystems. We take a similar approach here by using programs with finite
domains of variables, called <I>finite-memory<A NAME="30001-2001"> </A> programs</I> or <I>finite-domain<A NAME="30001-2002"> </A> programs</I>,
first.
   <P >However, it should be mentioned that finite-memory programs are also important on
their own merit. They are applicable in the design and analysis of some common types of
computer programs.
   <P >For instance, in compilers (i.e., in programs that translate programs written in
high-level languages to equivalent programs written in machine languages) the lexical
analyzers are basically designed as finite-memory programs. The main task of a lexical
analyzer is to scan the given inputs and locate the symbols that belong to each of the
tokens.
   <P ><STRONG>Example 2.1.1</STRONG> <A 
   NAME="30001-2003t2.1.1"> </A> 
Let LEXANL be the finite-memory program in Figure <A 
 HREF="#30001-2004r2.1.1">2.1.1</A>(a).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30001-2004r2.1.1"> </A>
          <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>char</TT> := &#34;  &#34;
<B>do</B>
    /* Find the first character of the next token. */
    <B>if</B> <TT>char</TT> = &#34;  &#34; <B>then</B>
        <B>do</B>
            <B>if</B> <I>eof</I> <B>then accept</B>
            <B>read</B> <TT>char</TT>
        <B>until</B> <TT>char</TT><IMG 
SRC="theory-bk-two0x.gif" ALT="/="ALIGN="MIDDLE" > &#34;  &#34;
    /* Determine the class of the token. */
    <TT>charClass</TT> := class(<TT>char</TT>)
   <B>write</B> className(<TT>charClass</TT>)
   /* Determine the remaining characters of the token. */
    <B>do</B>
        <B>write</B> <TT>char</TT>
        <B>if</B> <I>eof</I> <B>then accept</B>
        <TT>oldCharClass</TT> := <TT>charClass</TT>
        <B>read</B> <TT>char</TT>
        <TT>charClass</TT> := M(<TT>charClass</TT>, <TT>char</TT>)
   <B>until</B> <TT>charClass</TT><IMG 
SRC="theory-bk-two1x.gif" ALT="/="ALIGN="MIDDLE" > <TT>oldCharClass</TT>
<B>until</B> false                                                     </PRE></TD></TR></TABLE>
                               (a)

<IMG 
SRC="draw-pic/theory-bk-two-2-1-1-b.jpg" ALT="[PICT]" 
>
                               (b)
<A 
   NAME="30001-2004r2.1.1"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.1.1 </STRONG></NOBR></TD><TD  
>(a) A lexical analyzer. (b) Tables for the lexical analyzer.                                           </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>The domain of the variables is assumed to equal {&#34;  &#34;, &#34;A&#34;,<FONT FACE="SYMBOL"> ¼</FONT>, &#34;Z&#34;, &#34;0&#34;,<FONT FACE="SYMBOL"> ¼</FONT>, &#34;9&#34;, 0, 1, 2}, with &#34;  &#34;
as initial value. The functions class, className, and M are defined by the tables of
Figure <A 
 HREF="#30001-2004r2.1.1">2.1.1</A>(b).
   <P >LEXANL is a lexical analyzer that determines the tokens in the given inputs, and
classifies them into identifiers and natural numbers. Each identifier is represented by a
letter followed by an arbitrary number of letters and digits. Each natural number is
represented by one or more digits. Each pair of consecutive tokens, except for
a natural number followed by an identifier, must be separated by one or more
blanks.
   <P >LEXANL can be easily modified to recognize a different class of tokens, by just
redefining class, className, and M. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** ">
   <P >
   <P >Protocols for communicating processes are also examples of systems that are
frequently designed as finite-memory programs. In such systems, each process is
represented by a finite-memory program. Each channel from one process to another is
abstracted by an implicit queue, that is, by a first-in-first-out memory. At each instance the
queue holds those messages that have been sent through the channel but not received yet.
Each sending of a message is represented by the writing of the message to the appropriate
channel. Each receiving of a message is represented by the reading of the message from
the appropriate channel.
   <P >In Section 2.6 it is shown that finite-memory programs have some interesting
decidable properties. Such decidable properties make the finite-memory programs
also attractive as tools for showing the complexity of some seemingly unrelated
problems.
   <P ><STRONG>Example 2.1.2</STRONG> <A 
   NAME="30001-2005t2.1.2"> </A> 
<A NAME="30001-2006"> </A>
Consider the problem K of deciding the existence of solutions over the natural numbers
for systems of linear Diophantine<A NAME="30001-2007"> </A> equations, that is, for systems of equations of the
following form. The a<SUB>i j</SUB>'s and b<SUB>i</SUB>'s are assumed to be integers. <CENTER>
                   <TABLE  
><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
> a<SUB>1 1</SUB>x<SUB>1</SUB> + · · · +  a<SUB>1 n</SUB>x<SUB>n</SUB></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>b<SUB>1</SUB></TD>                   <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>   <TD 
NOWRAP ALIGN="CENTER"  
><IMG 
SRC="theory-bk-two3x.gif" ALT=".
.."></TD>   <TD 
NOWRAP ALIGN="LEFT "  
></TD>                     <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                   </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
>a<SUB>m 1</SUB>x<SUB>1</SUB> + · · · + a<SUB>m n</SUB>x<SUB>n</SUB></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>b<SUB>m</SUB></TD>                   <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                     </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>   <TD 
NOWRAP ALIGN="CENTER"  
></TD>   <TD 
NOWRAP ALIGN="LEFT "  
></TD>                     <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
</TR></TABLE>
</CENTER>
   <P >No straightforward algorithm seems to be evident for deciding the problem, though
one can easily partially decide the problem by exhaustively searching for an assignment to
the variables that satisfies the given system.
   <P >For each instance I of K, a finite-memory program P<SUB>I</SUB> can be constructed to accept
some input if and only if I has a solution over the natural numbers. Consequently, the
problem K is reducible to the emptiness<A NAME="30001-2008"> </A> problem for finite-memory programs. The
decidability of K is then implied by the decidability of the emptiness problem for
finite-memory programs (Theorem <A 
 HREF="theory-bk-twose6.html#30006-22005t2.6.1">2.6.1</A>).
   <P >In fact, the proof of Theorem <A 
 HREF="theory-bk-twose6.html#30006-22005t2.6.1">2.6.1</A> implies that a system I has a solution over the
natural numbers if and only if the system has a solution in which the values of x<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , x<SUB>n</SUB> are
no greater than some bound that depends only on the a<SUB>i j</SUB>'s, b<SUB>i</SUB>'s, m and n. <A NAME="30001-2009"> </A><IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P >Computer programs that use no auxiliary memory, except for holding the input and
output values, are by definition examples of finite-memory programs. However, such
programs can deal with domains of high cardinality (i.e., 2<SUP>k</SUP> for computers with k bits per
word), and as a result their designs are generally not affected by the finiteness of their
domains. Consequently, such programs should not generally be considered as &#34;natural&#34;
finite-memory programs.
   <P >
   <P >[<A 
 HREF="theory-bk-twose2.html" >next</A>] [<A 
 HREF="theory-bk-twose1.html" >front</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose1.html" >up</A>] <A 
   NAME="tailtheory-bk-twose1.html"> </A></BODY></HTML>