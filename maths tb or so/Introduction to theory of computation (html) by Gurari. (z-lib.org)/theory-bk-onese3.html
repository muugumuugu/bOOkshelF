
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-one.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-onese4.html" >next</A>] [<A 
 HREF="theory-bk-onese2.html" >prev</A>] [<A 
 HREF="theory-bk-onese2.html#tailtheory-bk-onese2.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-onese3.html">tail</A>] [<A 
 HREF="theory-bk-one.html#theory-bk-onese3.html" >up</A>]
<H3>1.3 <A 
   NAME="20003-130001.3"> </A><A 
 HREF="theory-bk.html#Q2-20003-13"  NAME="Q1-20003-13">Programs</A></H3>
   <P >
      <A 
 HREF="#Q1-20003-14"  NAME="Q2-20003-14">Choice of a Programming Language</A>
<BR>         <A 
 HREF="#Q1-20003-15"  NAME="Q2-20003-15">Deterministic Programs</A>
<BR>         <A 
 HREF="#Q1-20003-16"  NAME="Q2-20003-16">Computations</A>
<BR>         <A 
 HREF="#Q1-20003-17"  NAME="Q2-20003-17">Nondeterministic Programs</A>
<BR>         <A 
 HREF="#Q1-20003-18"  NAME="Q2-20003-18">Guessing in Programs</A>
<BR>         <A 
 HREF="#Q1-20003-19"  NAME="Q2-20003-19">Configurations of Programs</A>
   <P >Our deep dependency on the processing of information brought about the deployment
of programs in an ever increasing array of applications. Programs can be found at
home, at work, and in businesses, libraries, hospitals, and schools. They are used
for learning, playing games, typesetting, directing telephone calls, providing
medical diagnostics, forecasting weather, flying airplanes, and for many other
purposes.
   <P >To facilitate the task of writing programs for the multitude of different applications,
numerous programming languages have been developed. The diversity of programming
languages reflects the different interpretations that can be given to information. However,
from the perspective of their power to express computations, there is very little difference
among them. Consequently, different programming languages can be used in the study of
programs.
   <P >The study of programs can benefit, however, from fixing the programming language in
use. This enables a unified discussion about programs. The choice, however, must be for a
language that is general enough to be relevant to all programs but primitive enough to
simplify the discussion.
   <P ><EM><A 
   NAME="20003-14000"> </A><A 
 HREF="#Q2-20003-14"  NAME="Q1-20003-14">Choice of a Programming Language</A></EM>
   <P >Here, a <I>program</I><A NAME="20003-14001"> </A> is defined as a finite sequence of instructions over some domain D.
The domain D, called the <I>domain<A NAME="20003-14002"> </A> of the variables</I>, is assumed to be a set of elements with
a distinguished element, called the <I>initial<A NAME="20003-14003"> </A> value of the variables</I>. Each of the elements in D
is assumed to be a possible assignment of a value to the variables of the program. The
sequence of instructions is assumed to consist of instructions of the following
form.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="20003-14004xa"> </A>Read<A NAME="20003-14005"> </A> instructions of the form
<P >
                      <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>read</B> <TT>x</TT>  </PRE></TD></TR></TABLE>
     <P >where <TT>x</TT> is a variable.
     <LI><A 
   NAME="20003-14006xb"> </A>Write<A NAME="20003-14007"> </A> instructions of the form
<P >
                      <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>write</B> <TT>x</TT>  </PRE></TD></TR></TABLE>
     <P >where <TT>x</TT> is a variable.
     <LI><A 
   NAME="20003-14008xc"> </A>Deterministic assignment instructions of the form <A NAME="20003-14009"> </A>
<P >
                      <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>y</TT> := f(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>)     </PRE></TD></TR></TABLE>
     <P >where <TT>x</TT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <TT>x</TT><SUB>m</SUB>, and <TT>y</TT> are variables, and f is a function from D<SUP>m</SUP> to D.
     <LI><A 
   NAME="20003-14010xd"> </A>Conditional if instructions of the form <A NAME="20003-14011"> </A>
<P >
                      <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>if</B> Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) <B>then</B> I   </PRE></TD></TR></TABLE>
     <P >where I is an instruction, <TT>x</TT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <TT>x</TT><SUB>m</SUB> are variables, and Q is a predicate from D<SUP>m</SUP>
     to {false, true}.
     <LI><A 
   NAME="20003-14012xe"> </A>Deterministic looping instructions of the form<A NAME="20003-14013"> </A>
<P >
                      <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>do</B>
    <FONT FACE="SYMBOL">a</FONT>
<B>until</B> Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>)     </PRE></TD></TR></TABLE>
     <P >where <FONT FACE="SYMBOL">a</FONT> is a nonempty sequence of instructions, <TT>x</TT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <TT>x</TT><SUB>m</SUB> are variables, and Q
     is a predicate from D<SUP>m</SUP> to {false, true}.
     <LI><A 
   NAME="20003-14014xf"> </A>Conditional accept instructions of the form<A NAME="20003-14015"> </A>
<P >
                      <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>if</B> <I>eof</I> <B>then accept</B> </PRE></TD></TR></TABLE>
     <LI><A 
   NAME="20003-14016xg"> </A>Reject instructions of the form<A NAME="20003-14017"> </A>
<P >
                      <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>reject</B> </PRE></TD></TR></TABLE>
     <LI><A 
   NAME="20003-14018xh"> </A>Nondeterministic assignment instructions of the form<A NAME="20003-14019"> </A>
<P >
                      <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>x</TT> := ? </PRE></TD></TR></TABLE>
     <P >where <TT>x</TT> is a variable.
     <LI><A 
   NAME="20003-14020xi"> </A>Nondeterministic looping instructions of the form<A NAME="20003-14021"> </A>
<P >
                      <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>do</B>
    <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>
<B>or</B>
    <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>
<B>or</B>
    <IMG 
SRC="theory-bk-one46x.gif" ALT=".
..">
<B>or</B>
    <FONT FACE="SYMBOL">a</FONT><SUB>k</SUB>
<B>until</B> Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>)     </PRE></TD></TR></TABLE>
     <P >where k <FONT FACE="SYMBOL">³</FONT> 2, each of <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">a</FONT><SUB>k</SUB> is a nonempty sequence of instructions, <TT>x</TT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <TT>x</TT><SUB>m</SUB>
     are variables, and Q is a predicate from D<SUP>m</SUP> to {false, true}.
     </OL>
   <P >
In each program the domain D of the variables is assumed to have a representation over
some alphabet. For instance, D can be the set of natural numbers, the set of integers, and
any finite set of elements. The functions f and predicates Q are assumed to be from a
given &#34;built-in&#34; set of computable functions and predicates (see Section 1.4 and Church's
thesis in Section 4.1).
   <P >In what follows, the domains of the variables will not be explicitly noted when their
nature is of little significance. In addition, expressions in infix notations will be used for
specifying functions and predicates.
   <P >Programs without nondeterministic instructions are called <I>deterministic</I><A NAME="20003-14022"> </A> programs,
and programs with nondeterministic instructions are called <I>nondeterministic</I><A NAME="20003-14023"> </A>
programs.
   <P ><STRONG>Example 1.3.1</STRONG> <A 
   NAME="20003-14024t1.3.1"> </A> 
The program P<SUB>1</SUB> in Figure <A 
 HREF="#20003-14025r1.3.1">1.3.1</A>(a)
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20003-14025r1.3.1"> </A>
<TABLE WIDTH="100%"> <TR VALIGN="BOTTOM"><TD NOWRAP><TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>read</B> <TT>x</TT>
<TT>y</TT> := 0
<TT>z</TT> := 1
<B>do</B>
    <TT>y</TT> := <TT>y</TT> + 1
   <TT>z</TT> := <TT>z</TT> + 1
<B>until</B> <TT>z</TT> = <TT>x</TT>
<B>read</B> <TT>y</TT>
<B>if</B> <I>eof</I> <B>then accept</B>
<B>reject</B>                     </PRE></TD></TR></TABLE></TD><TD> </TD><TD NOWRAP><TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>do</B>
    <B>read</B> <TT>x</TT>
<B>or</B>
    <TT>y</TT> := ?
   <B>write</B> <TT>y</TT>
<B>until</B> <TT>y</TT> = <TT>x</TT>
<B>if</B> <I>eof</I> <B>then accept</B> </PRE></TD></TR></TABLE></TD></TR><TR><TD ALIGN="CENTER">(a) </TD><TD> </TD><TD ALIGN="CENTER">(b) </TD></TR></TABLE>  <A 
   NAME="20003-14025r1.3.1"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.3.1 </STRONG></NOBR></TD><TD  
>(a) A deterministic program. (b) A nondeterministic program.                                   </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>is an example of a deterministic program, and the program P<SUB>2</SUB> in Figure <A 
 HREF="#20003-14025r1.3.1">1.3.1</A>(b) is an
example of a nondeterministic program. The set of natural numbers is assumed for the
domains of the variables, with 0 as initial value.
   <P >The program P<SUB>1</SUB> uses three variables, namely, <TT>x</TT>, <TT>y</TT>, and <TT>z</TT>. There are two functions in
this program. The constant function f<SUB>1</SUB>() = 0, and the unary function f<SUB>2</SUB>(n) = n + 1 of
addition by one. The looping instruction uses the binary predicate of equality.
   <P >The program P<SUB>2</SUB> uses two nondeterministic instructions. One of the nondeterministic
instructions is an assignment instruction of the form &#34;<TT>y</TT> := ?&#34;; the other is a looping
instruction of the form &#34;<B>do</B> · · · <B>or</B> · · · <B>until</B> · · · &#34; <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >An <I>input</I><A NAME="20003-14026"> </A> of a given program is a sequence of elements from the domain of the
variables of the program. Each element in an input of a program is called an <I>input<A NAME="20003-14027"> </A>
value</I>.
   <P ><STRONG>Example 1.3.2</STRONG> <A 
   NAME="20003-14028t1.3.2"> </A> 
The programs of Example <A 
 HREF="#20003-14024t1.3.1">1.3.1</A> (see Figure <A 
 HREF="#20003-14025r1.3.1">1.3.1</A>) can have any input that is a finite
sequence of natural numbers. An input of the form &#34;1, 2, 3, 4&#34; consists of four input
values, and an input of the form &#34; &#34; contains no input value.
   <P >The sequence &#34;1, 2, 3, . . . &#34; cannot be an input for the programs because it is not a
finite sequence. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >An <I>execution<A NAME="20003-14029"> </A> sequence</I> of a given program is an execution on a given input of the
instructions according to their semantics. The instructions are executed consecutively,
starting with the first instruction. The variables initially hold the initial value<A NAME="20003-14030"> </A> of the
variables.
   <P ><EM><A 
   NAME="20003-15000"> </A><A 
 HREF="#Q2-20003-15"  NAME="Q1-20003-15">Deterministic Programs</A></EM>
   <P >Deterministic programs have the property that no matter how many times they are
executed on a given input, the executions are always in exactly the same manner. Each
instruction of a deterministic program fully specifies the operations to be performed. In
contrast, nondeterministic instructions provide only partial specifications for the
actions.<A NAME="20003-15001"> </A>
   <P >An execution of a read instruction <B>read</B><A NAME="20003-15002"> </A> <TT>x</TT> reads the next input value to <TT>x</TT>. An execution
of a write<A NAME="20003-15003"> </A> instruction <B>write</B> <TT>x</TT> writes the value of <TT>x</TT>.
   <P >The deterministic assignment instructions<A NAME="20003-15004"> </A> and the conditional<A NAME="20003-15005"> </A> if instructions have the
conventional semantics.
   <P >An execution of a deterministic<A NAME="20003-15006"> </A> looping instruction <B>do</B> <FONT FACE="SYMBOL">a</FONT> <B>until</B> Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) consists of
repeatedly executing <FONT FACE="SYMBOL">a</FONT> and checking the value of Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>). The execution of the
looping instruction is terminated upon detecting that the predicate Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) has the
value true. If Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) is the constant true, then only one iteration is executed. On the
other hand, if Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) is the constant false, then the looping goes on forever, unless the
execution terminates in <FONT FACE="SYMBOL">a</FONT>.
   <P >A conditional accept instruction<A NAME="20003-15007"> </A> causes an execution sequence to halt<A NAME="20003-15008"> </A> if executed after
all the input is consumed, that is, after reaching the end of input file (<I>eof</I> for
short). Otherwise the execution of the instruction causes the execution sequence to
continue at the code following the instruction. Similarly, an execution sequence also
halts upon executing a reject<A NAME="20003-15009"> </A> instruction, trying to read<A NAME="20003-15010"> </A> beyond the end of the
input, trying to transfer the control beyond the end of the program, or trying
to compute a value not in the domain of the variables (e.g., trying to divide by
0).
   <P ><STRONG>Example 1.3.3</STRONG> <A 
   NAME="20003-15011t1.3.3"> </A> 
Consider the two programs in Figure <A 
 HREF="#20003-15012r1.3.2">1.3.2</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20003-15012r1.3.2"> </A>
<TABLE WIDTH="100%"> <TR VALIGN="BOTTOM"><TD NOWRAP><TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>do</B>
    <B>if</B> <I>eof</I> <B>then accept</B>
    <B>read</B> <TT>value</TT>
    <B>write</B> <TT>value</TT>
<B>until</B> false            </PRE></TD></TR></TABLE></TD><TD> </TD><TD NOWRAP><TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>do</B>
    <B>read</B> <TT>value</TT>
    <B>write</B> <TT>value</TT>
<B>until</B> <TT>value</TT> &lt; 0
<B>if</B> <I>eof</I> <B>then accept</B> </PRE></TD></TR></TABLE></TD></TR><TR><TD ALIGN="CENTER">(a) </TD><TD> </TD><TD ALIGN="CENTER">(b) </TD></TR></TABLE>  <A 
   NAME="20003-15012r1.3.2"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.3.2 </STRONG></NOBR></TD><TD  
>Two deterministic programs.                                                                                        </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Assume that the programs have the set of integers for the domains of their variables, with 0
as initial value.
   <P >For each input the program in Figure <A 
 HREF="#20003-15012r1.3.2">1.3.2</A>(a) has one execution sequence. In each
execution sequence the program provides an output that is equal to the input. All the
execution sequences of the program terminate due to the execution of the conditional
accept instruction.
   <P >On input &#34;1, 2&#34; the execution sequence repeatedly executes for three times the body of
the deterministic looping instruction. During the first iteration, the execution sequence
determines that the predicate <I>eof</I> has the value false. Consequently, the execution
sequence ignores the accept command and continues by reading the value 1 and writing it
out. During the second iteration the execution sequence verifies again that the end of the
input has not been reached yet, and then the execution sequence reads the input value 2
and writes it out. During the third iteration, the execution sequence terminates due
to the accept command, after determining a true value for the predicate <I>eof</I>
.
   <P >The execution sequences of the program in Figure <A 
 HREF="#20003-15012r1.3.2">1.3.2</A>(b) halt due to the conditional
accept instruction, only on inputs that end with a negative value and have no negative
values elsewhere (e.g., the input &#34;1, 2, -3&#34;). On inputs that contain no negative
values at all, the execution sequences of the program halt due to trying to read
beyond the end of the input (e.g., on input &#34;1, 2, 3&#34;). On inputs that have negative
values before their end, the execution sequences of the program halt due to the
transfer of control beyond the end of the program (e.g., on input &#34;-1, 2, -3&#34;). <IMG 
SRC="theory-bk-one0x.gif" ALT=" ***
" 
 >
   <P >
   <P >Intuitively, an <B>accept</B><A NAME="20003-15013"> </A> can be viewed as a halt command that signals a successful
completion of a program execution, where the <B>accept</B> can be executed only after the end of
the input is reached. Similarly, a <B>reject</B><A NAME="20003-15014"> </A> can be viewed as a halt instruction that signals an
unsuccessful completion of a program execution.
   <P >The requirement that the accept commands be executed only after reading all the
input values should cause no problem, because each program can be modified to
satisfy this condition. Moreover, such a constraint seems to be natural, because it
forces each program to check all its input values before signaling a success by an
accept command. Similarly, the requirement that an execution sequence must halt
upon trying to read beyond the end of an input seems to be natural. It should not
matter whether the reading is due to a read instruction or to checking for the <I>eof</I>
predicate.
   <P >It should be noted that the predicates Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) in the conditional<A NAME="20003-15015"> </A> if instructions
and in the looping instructions cannot be of the form <I>eof</I> . The predicates are
defined just in terms of the values of the variables <TT>x</TT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <TT>x</TT><SUB>m</SUB>, not in terms of the
input.<A NAME="20003-15016"> </A>
   <P ><EM><A 
   NAME="20003-16000"> </A><A 
 HREF="#Q2-20003-16"  NAME="Q1-20003-16">Computations</A></EM>
   <P >Programs use finite sequences of instructions for describing sets of infinite numbers of
computations. The descriptions of the computations are obtained by &#34;unrolling&#34; the
sequences of instructions into execution sequences. In the case of deterministic programs,
each execution sequence provides a description for a computation. On the other
hand, as it will be seen below, in the case of nondeterministic programs<A NAME="20003-16001"> </A> some
execution sequences might be considered as computations, whereas others might be
considered noncomputations. To delineate this distinction we need the following
definitions.
   <P >An execution sequence is said to be an <I>accepting<A NAME="20003-16002"> </A> computation</I> if it terminates due to an
accept command. An execution sequence is said to be a <I>nonaccepting<A NAME="20003-16003"> </A> computation</I> or a
<I>rejecting<A NAME="20003-16004"> </A> computation</I> if it is on input that has no accepting computations. An execution
sequence is said to be a <I>computation</I><A NAME="20003-16005"> </A> if it is an accepting computation or a nonaccepting
computation.
   <P >A computation is said to be a <I>halting<A NAME="20003-16006"> </A> computation</I> if it is finite.
   <P ><STRONG>Example 1.3.4</STRONG> <A 
   NAME="20003-16007t1.3.4"> </A> 
Consider the program in Figure <A 
 HREF="#20003-16008r1.3.3">1.3.3</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20003-16008r1.3.3"> </A>
                       <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>read</B> <TT>value</TT>
<B>do</B>
    <B>write</B> <TT>value</TT>
    <TT>value</TT> := <TT>value</TT> - 2
<B>until</B> <TT>value</TT> = 0
<B>if</B> <I>eof</I> <B>then accept</B>       </PRE></TD></TR></TABLE>
<A 
   NAME="20003-16008r1.3.3"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.3.3 </STRONG></NOBR></TD><TD  
>A deterministic program.                                                                                             </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Assume that the domain of the variables is the set of integers, with 0 as initial
value.
   <P >On an input that consists of a single, even, positive integer, the program has an
execution sequence that is an accepting computation (e.g., on input &#34;4&#34;).
   <P >On an input that consists of more than one value and that starts with an even positive
integer, the program has a halting execution sequence that is a nonaccepting computation
(e.g., on input &#34;4, 3, 2&#34;).
   <P >On the rest of the inputs the program has nonhalting execution sequences that are
nonaccepting computations (e.g., on input &#34;1&#34;). <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >An input is said to be <I>accepted</I><A NAME="20003-16009"> </A>, or <I>recognized</I><A NAME="20003-16010"> </A>, by a program if the program has an
accepting computation on such an input. Otherwise the input is said to be <I>not accepted</I><A NAME="20003-16011"> </A>, or
<I>rejected</I><A NAME="20003-16012"> </A>, by the program.
   <P >A program is said to have an <I>output</I><A NAME="20003-16013"> </A> y on input x if it has an accepting computation on
x with output y. The outputs of the nonaccepting computations are considered to be
undefined<A NAME="20003-16014"> </A>, even though such computations may execute write instructions.
   <P ><STRONG>Example 1.3.5</STRONG> <A 
   NAME="20003-16015t1.3.5"> </A> 
The program in Example <A 
 HREF="#20003-16007t1.3.4">1.3.4</A> (see Figure <A 
 HREF="#20003-16008r1.3.3">1.3.3</A>) accepts the inputs &#34;2&#34;, &#34;4&#34;, &#34;6&#34;, <FONT FACE="SYMBOL">¼</FONT>  On input
&#34;6&#34; the program has the output &#34;6, 4, 2&#34;, and on input &#34;2&#34; the program has the output
&#34;2&#34;.
   <P >The program does not accept the inputs &#34;0&#34;, &#34;1&#34;, and &#34;4, 2&#34;. For these inputs the
program has no output, that is, the output is undefined. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >A computation is said to be a <I>nondeterministic<A NAME="20003-16016"> </A> computation</I> if it involves the execution
of a nondeterministic instruction. Otherwise the computation is said to be a <I>deterministic<A NAME="20003-16017"> </A>
computation</I>.
   <P ><EM><A 
   NAME="20003-17000"> </A><A 
 HREF="#Q2-20003-17"  NAME="Q1-20003-17">Nondeterministic Programs</A></EM>
<A NAME="20003-17001"> </A>
   <P >Different objectives create the need for nondeterministic instructions in programming
languages. One of the objectives is to allow the programs to deal with problems that
may have more than one solution. In such a case, nondeterministic instructions
provide a natural method of selection (see, e.g., Example <A 
 HREF="#20003-17003t1.3.6">1.3.6</A> below). Another
objective is to simplify the task of programming (see, e.g., Example <A 
 HREF="#20003-18005t1.3.9">1.3.9</A> below).
Still another objective is to provide tools for identifying difficult problems (see
Chapter 5) and for studying restricted classes of programs (see Chapter 2 and
Chapter 3).
   <P >Implementation considerations should not bother the reader at this point. After all, one
usually learns the semantics of new programming languages before learning, if one ever
does, the implementation of such languages. Later on it will be shown how a
nondeterministic program can be translated into a deterministic program that computes a
related function (see Section 4.3).
   <P >Nondeterministic instructions are essentially instructions that can choose
between some given options. Although one is often required to make choices in
everyday life, the use of such instructions might seem strange within the context of
programs.
   <P >The semantics of a nondeterministic looping instruction<A NAME="20003-17002"> </A> of the form <B>do</B> <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB> <B>or</B>
<FONT FACE="SYMBOL">a</FONT><SUB>2</SUB> <B>or</B> · · · <B>or</B> <FONT FACE="SYMBOL">a</FONT><SUB>k</SUB> <B>until</B> Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>), are similar to those of a deterministic looping
instruction of the form <B>do</B> <FONT FACE="SYMBOL">a</FONT> <B>until</B> Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>). The only difference is that in the
deterministic case a fixed code segment <FONT FACE="SYMBOL">a</FONT> is executed in each iteration, whereas in the
nondeterministic case an arbitrary code segment from <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">a</FONT><SUB>k</SUB> is executed in
each iteration. The choice of a code segment can differ from one iteration to
another.
   <P ><STRONG>Example 1.3.6</STRONG> <A 
   NAME="20003-17003t1.3.6"> </A> 
The program in Figure <A 
 HREF="#20003-17004r1.3.4">1.3.4</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20003-17004r1.3.4"> </A>
                 <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>counter</TT> := 0
/* Choose five input values. */
<B>do</B>
    <B>read</B> <TT>value</TT>
<B>or</B>
    <B>read</B> <TT>value</TT>
    <B>write</B> <TT>value</TT>
    <TT>counter</TT> := <TT>counter</TT> + 1
<B>until</B> <TT>counter</TT> = 5
/* Read the remainder of the input. */
<B>do</B>
    <B>if</B> <I>eof</I> <B>then accept</B>
    <B>read</B> <TT>value</TT>
<B>until</B> false                               </PRE></TD></TR></TABLE>
<A 
   NAME="20003-17004r1.3.4"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.3.4 </STRONG></NOBR></TD><TD  
>A nondeterministic program that chooses five input values.                                        </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>is nondeterministic. The set of natural numbers is assumed to be the domain of the
variables, with 0 as initial value. Parenthetical remarks are enclosed between /* and
*/.
   <P >The program on input &#34;1, 2, 3, 4, 5, 6&#34; has an execution sequence of the following
form. The execution sequence starts with an iteration of the nondeterministic looping
instruction in which the first code segment is chosen. The execution of the code segment
consists of reading the input value 1, while writing nothing and leaving <TT>counter</TT> with the
value of 0. Then the execution sequence continues with five additional iterations of the
nondeterministic looping instruction. In each of the additional iterations, the
second code segment is chosen. Each execution of the second code segment
reads an input value, outputs the value that has been read, and increases the value
of <TT>counter</TT> by 1. When <TT>counter</TT> reaches the value of 5, the execution sequence
exits the first looping instruction. During the first iteration of the second looping
instruction, the execution sequence halts due to the execution of the conditional accept
instruction. The execution sequence is an accepting computation with output
&#34;2, 3, 4, 5, 6&#34;.
   <P >The program on input &#34;1, 2, 3, 4, 5, 6&#34; has four additional execution sequences similar
to the one above. The only difference is that the additional execution sequences, instead of
ignoring the input value 1, ignore the input values 2, 3, 4, and 5, respectively. An execution
sequence ignores an input value i by choosing to read the value in the first code segment of
the nondeterministic looping instruction. The additional execution sequences are accepting
computations with outputs &#34;1, 3, 4, 5, 6&#34;, &#34;1, 2, 4, 5, 6&#34;, &#34;1, 2, 3, 5, 6&#34;, and &#34;1, 2, 3, 4, 6&#34;,
respectively.
   <P >The program on input &#34;1, 2, 3, 4, 5, 6&#34; also has an accepting computation of the
following form. The computation starts with five iterations of the first looping instruction.
In each of these iterations the second code segment of the nondeterministic looping
instruction is executed. During each iteration an input value is read, that value is written
into the output, and the value of <TT>counter</TT> is increased by 1. After five iterations of the
nondeterministic looping instruction, <TT>counter</TT> reaches the value of 5, and the computation
transfers to the deterministic looping instruction. The computation reads the
input value 6 during the first iteration of the deterministic looping instruction,
and terminates during the second iteration. The output of the computation is
&#34;1, 2, 3, 4, 5&#34;.
   <P >The program has 2<SUP>7</SUP> - 14 execution sequences on input &#34;1, 2, 3, 4, 5, 6&#34; that are not
computations. 2<SUP>6</SUP> - 7 of these execution sequences terminate due to trying to read beyond
the input end by the first read instruction, and 2<SUP>6</SUP> - 7 of these execution sequences
terminate due to trying to read beyond the input end by the second read instruction.
In each of these execution sequences at least two input values are ignored by
consuming the values in the first code segment of the nondeterministic looping
instruction. The execution sequences differ in the input values they choose to
ignore.
   <P >None of the execution sequences of the program on input &#34;1, 2, 3, 4, 5, 6&#34; is a
nonaccepting computation, because the program has an accepting computation on such an
input.
   <P >The program does not accept the input &#34;1, 2, 3, 4&#34;. On such an input the program has
2<SUP>5</SUP> execution sequences all of which are nonaccepting computations.
   <P >The first nondeterministic looping instruction of the program is used for choosing the
output values from the inputs. Upon choosing five values the execution sequences
continue to consume the rest of the inputs in the second deterministic looping
instruction.
   <P >On inputs with fewer than five values the execution sequences terminate in the first
nondeterministic looping instruction, upon trying to read beyond the end of the
inputs.
   <P >The variable <TT>counter</TT> records the number of values chosen at steps during each
execution sequence. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >A deterministic program has exactly one execution sequence on each input, and each
execution sequence of a deterministic program is a computation. On the other hand, the
last example shows that a nondeterministic program might have more than one execution
sequence on a given input, and that some of the execution sequences might not be
computations of the program.
   <P >Nondeterministic looping instructions have been introduced to allow selections
between code segments. The motivation for introducing nondeterministic assignment
instructions<A NAME="20003-17005"> </A> is to allow selections between values. Specifically, a nondeterministic
assignment instruction of the form <TT>x</TT> := ? assigns to the variable <TT>x</TT> an arbitrary value from
the domain of the variables. The choice of the assigned value can differ from one
encounter of the instruction to another.
   <P ><STRONG>Example 1.3.7</STRONG> <A 
   NAME="20003-17006t1.3.7"> </A> 
The program in Figure <A 
 HREF="#20003-17007r1.3.5">1.3.5</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20003-17007r1.3.5"> </A>
              <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE>/* Nondeterministically find a value that
 a. appears exactly once in the input, and
 b. is the last value in the input.                        */
<TT>last</TT> := ?
<B>write</B> <TT>last</TT>
/* Read the input values, until a value
equal to the one stored in <TT>last</TT> is reached.    
*/
<B>do</B>
    <B>read</B> <TT>value</TT>
<B>until</B> <TT>value</TT> = <TT>last</TT>
/* Check for end of input. */
<B>if</B> <I>eof</I> <B>then accept</B>
<B>reject</B>                                                                </PRE></TD></TR></TABLE>
<A 
   NAME="20003-17007r1.3.5"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.3.5 </STRONG></NOBR></TD><TD  
>A nondeterministic program for determining a single appearance of the last input
value.                                                                                                                            </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>is nondeterministic. The set of natural numbers is assumed to be the domain of the
variables. The initial value is assumed to be 0.
   <P >The program accepts a given input if and only if the last value in the input does not
appear elsewhere in the input. Such a value is also the output of an accepting computation.
For instance, on input &#34;1, 2, 3&#34; the program has the output &#34;3&#34;. On the other hand,
on input &#34;1, 2, 1&#34; no output is defined since the program does not accept the
input.
   <P >On each input the program has infinitely many execution sequences. Each execution
sequence corresponds to an assignment of a different value to <TT>last</TT> from the domain of the
variables.
   <P >An assignment to <TT>last</TT> of a value that appears in the input, causes an execution
sequence to exit the looping instruction upon reaching such a value in the input. With such
an assignment, one of the following cases holds.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="20003-17008xa"> </A>The execution sequence is an accepting computation if the value assigned to
     <TT>last</TT> appears only at the end of the input (e.g., an assignment of 3 to <TT>last</TT> on
     input &#34;1, 2, 3&#34;).
     <LI><A 
   NAME="20003-17009xb"> </A>The execution sequence is a nonaccepting computation if the value at the end
     of the input appears more than once in the input (e.g., an assignment of 1 or 2
     to <TT>last</TT> on input &#34;1, 2, 1&#34;).
     <LI><A 
   NAME="20003-17010xc"> </A>The execution sequence is not a computation if neither (a) nor (b) hold (e.g.,
     an assignment of 1 or 2 to <TT>last</TT> on input &#34;1, 2, 3&#34;).</OL>
An assignment to <TT>last</TT> of a value that does not appear in the input causes an execution
sequence to terminate within the looping instruction upon trying to read beyond the end of
the input. With such an assignment, one of the following cases hold.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="20003-17011xa"> </A>The execution sequence is a nonaccepting computation if the value at the end
     of the input appears more than once in the input (e.g., an assignment to <TT>last</TT> of
     any natural number that differs from 1 and 2 on input &#34;1, 2, 1&#34;).
     <LI><A 
   NAME="20003-17012xb"> </A>The execution sequence is a nonaccepting computation if the input is empty
     (e.g., an assignment of any natural number to <TT>last</TT> on input &#34; &#34;).
     <LI><A 
   NAME="20003-17013xc"> </A>The execution sequence is not a computation, if neither (a) nor (b) hold (e.g.,
     an assignment to <TT>last</TT> of any natural number that differs from 1, 2, and 3 on
     input &#34;1, 2, 3&#34;).                                                                                           <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 ></OL>
   <P >
   <P >Intuitively, each program on each input defines &#34;good&#34; execution sequences, and &#34;bad&#34;
execution sequences. The good execution sequences terminate due to the accept
commands, and the bad execution sequences do not terminate due to accept commands.
The best execution sequences for a given input are the computations that the program has
on the input. If there exist good execution sequences, then the set of computations is
identified with that set. Otherwise, the set of computations is identified with the set of bad
execution sequences.
   <P >The computations of a program on a given input are either all accepting computations
or all nonaccepting computations. Moreover, some of the nonaccepting computations may
never halt. On inputs that are accepted the program might have execution sequences that
are not computations. On the other hand, on inputs that are not accepted all the execution
sequences are computations.<A NAME="20003-17014"> </A>
   <P ><EM><A 
   NAME="20003-18000"> </A><A 
 HREF="#Q2-20003-18"  NAME="Q1-20003-18">Guessing in Programs</A></EM>
   <P >The semantics of each program are characterized by the computations of the program.
In the case of deterministic programs the semantics of a given program are directly related
to the semantics of its instructions. That is, each execution of the instructions keeps the
program within the course of a computation.
   <P >In the case of nondeterministic programs a distinction is made between execution
sequences and computations, and so the semantics of a given program are related only in a
restricted manner to the semantics of its instructions. That is, although each computation
of the program can be achieved by executing the instructions, some of the execution
sequences do not correspond to any computation of the program. The source for this
phenomenon is the ability of the nondeterministic instructions to make arbitrary
choices.
   <P >Each program can be viewed as having an imaginary agent with magical power
that executes the program. On a given input, the task of the imaginary agent is
to follow any of the computations the program has on the input. The case of
deterministic programs can be considered as a lesser and restricted example in
which the agent is left with no freedom. That is, the outcome of the execution
of each deterministic instruction is completely determined for the agent by the
semantics of the instruction. On the other hand, when executing a nondeterministic
instruction the agent must satisfy not only the local semantics of the instruction, but
also the global goal of reaching an accept command whenever the global goal is
achievable.
   <P >Specifically, the local semantics of a nondeterministic looping instruction of the form
<A NAME="20003-18001"> </A><B>do</B> <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB> <B>or</B> · · · <B>or</B> <FONT FACE="SYMBOL">a</FONT><SUB>k</SUB> <B>until</B> Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) require that in each iteration exactly one of the code
segments <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">a</FONT><SUB>k</SUB> will be chosen in an arbitrary fashion by the agent. The global semantics
of a program require that the choice be made for a code segment which can lead the
execution sequence to halt due to a conditional accept instruction, whenever such is
possible.
   <P >Similarly, the local semantics of a nondeterministic assignment<A NAME="20003-18002"> </A> instruction of the form
<TT>x</TT> := ? require that each assigned value of <TT>x</TT> be chosen by the agent in an arbitrary fashion
from the domain of the variables. The global semantics of the program require that the
choice be made for a value that halts the execution sequence due to a conditional accept
instruction, whenever such is possible.
   <P >From the discussion above it follows that the approach of &#34;first guess a solution and
then check for its validity&#34; can be used when writing a program. This approach simplifies
the task of the programmer whenever checking for the validity of a solution is simpler than
the derivation of the solution. In such a case, the burden of determining a correct &#34;guess&#34;
is forced on the agent performing the computations.
   <P >It should be emphasized that from the point of view of the agent, a guess is correct if
and only if it leads an execution sequence along a computation of the program. The
agent knows nothing about the problem that the program intends to solve. The
only thing that drives the agent is the objective of reaching the execution of a
conditional accept instruction at the end of the input. Consequently, it is still up to the
programmer to fully specify the constraints that must be satisfied by the correct
guesses.
   <P ><STRONG>Example 1.3.8</STRONG> <A 
   NAME="20003-18003t1.3.8"> </A> 
The program of Figure <A 
 HREF="#20003-18004r1.3.6">1.3.6</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20003-18004r1.3.6"> </A>
                     <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE>/* Guess the output value. */
<TT>x</TT> := ?
<B>write</B> <TT>x</TT>
/* Check for the correctness of the
guessed value.                       */
<B>do</B>
    <B>if</B> <I>eof</I> <B>then accept</B>
    <B>read</B> <TT>y</TT>
<B>until</B> <TT>y</TT> = <TT>x</TT>                             </PRE></TD></TR></TABLE>
<A 
   NAME="20003-18004r1.3.6"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.3.6 </STRONG></NOBR></TD><TD  
>A nondeterministic program that outputs a noninput value.                                        </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>outputs a value that does not appear in the input. The program starts each computation by
guessing a value and storing it in <TT>x</TT>. Then the program reads the input and checks that each
of the input values differs from the value stored in <TT>x</TT>. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >The notion of an imaginary agent provides an appealing approach for explaining
nondeterminism. Nevertheless, the notion should be used with caution to avoid
misconceptions. In particular, an imaginary agent should be employed only on full
programs. The definitions leave no room for one imaginary agent to be employed by other
agents. For instance, an imaginary agent that is given the program P in the following
example cannot be employed by other agents to derive the acceptance of exactly those
inputs that the agent rejects.
   <P ><STRONG>Example 1.3.9</STRONG> <A 
   NAME="20003-18005t1.3.9"> </A> 
Consider the program P in Figure <A 
 HREF="#20003-18006r1.3.7">1.3.7</A>. On a given input, P outputs an arbitrary choice of
input values, whose sum equals the sum of the nonchosen input values. The values have
the same relative ordering in the output as in the input.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20003-18006r1.3.7"> </A>
        <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>sum1</TT> := 0
<TT>sum2</TT> := 0
<B>do</B>
    <B>if</B> <I>eof</I> <B>then accept</B>
    <B>do</B>                  /* Guess where the next input value belongs. */
        <B>read</B> <TT>x</TT>
        <TT>sum1</TT> := <TT>sum1</TT> + <TT>x</TT>
    <B>or</B>
        <B>read</B> <TT>x</TT>
        <B>write</B> <TT>x</TT>
        <TT>sum2</TT> := <TT>sum2</TT> + <TT>x</TT>
    <B>until</B> <TT>sum1</TT> = <TT>sum2</TT>         /* Check for the correctness of the
                   guesses, with respect to the portion
                   of the input consumed so far.   
                */
<B>until</B> false                                                            </PRE></TD></TR></TABLE>
<A 
   NAME="20003-18006r1.3.7"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.3.7 </STRONG></NOBR></TD><TD  
>A nondeterministic program for partitioning the input into two subsets of equal sums
of elements.                                                                                                                  </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >For instance, on input &#34;2, 1, 3, 4, 2&#34; the possible outputs are &#34;2, 1, 3&#34;, &#34;1, 3, 2&#34;, &#34;2, 4&#34;,
and &#34;4, 2&#34;. On the other hand, no output is defined for input &#34;2, 3&#34;.
   <P >In each iteration of the nested looping instruction the program guesses whether the
next input value is to be among the chosen ones. If it is to be chosen then <TT>sum2</TT> is
increased by the magnitude of the input value. Otherwise, <TT>sum1</TT> is increased by the
magnitude of the input value. The program checks that the sum of the nonchosen input
values equals the sum of the chosen input values by comparing the value in <TT>sum1</TT> with the
value in <TT>sum2</TT>. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P ><STRONG>Example 1.3.10</STRONG> <A 
   NAME="20003-18007t1.3.10"> </A> 
The program of Figure <A 
 HREF="#20003-18008r1.3.8">1.3.8</A> outputs the median of its input values, that is, the <FONT FACE="SYMBOL">é</FONT>n/2<FONT FACE="SYMBOL">ù</FONT>th
smallest input value for the case that the input consists of n values. On input &#34;1, 3, 2&#34; the
program has the output &#34;2&#34;, and on input &#34;2, 1, 3, 3&#34; the program has the output
&#34;3&#34;.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20003-18008r1.3.8"> </A>
               <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>median</TT> := ?         /* Guess the median. */
<B>write</B> <TT>median</TT>
<TT>count</TT> := 0
<B>do</B>
    /* Find the difference between the
    number of values greater than and those
    smaller than the guessed median.   
 */
    <B>do</B>
        <B>read</B> <TT>x</TT>
        <B>if</B> <TT>x</TT> &gt; <TT>median</TT> <B>then</B>
            <TT>count</TT> := <TT>count</TT> + 1
      <B>if</B> <TT>x</TT> &lt; <TT>median</TT> <B>then</B>
            <TT>count</TT> := <TT>count</TT> - 1
      <B>if</B> <TT>x</TT> = <TT>median</TT> <B>then</B>
            <B>do</B>
                <TT>count</TT> := <TT>count</TT> + 1
         <B>or</B>
                <TT>count</TT> := <TT>count</TT> - 1
         <B>until</B> true
   <B>until</B> 0 <FONT FACE="SYMBOL">£</FONT> count <FONT FACE="SYMBOL">£</FONT> 1
   /* The median is correct for the portion of the
    input consumed so far.                            */
    <B>if</B> <I>eof</I> <B>then accept</B>
<B>until</B> false                                     </PRE></TD></TR></TABLE>
<A 
   NAME="20003-18008r1.3.8"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.3.8 </STRONG></NOBR></TD><TD  
>A nondeterministic program that finds the median of the input values.                      </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >The program starts each computation by storing in <TT>median</TT> a guess for the value of the
median. Then the program reads the input values and determines in <TT>count</TT> the
difference between the number of input values that are greater than the one stored in
<TT>median</TT> and the number of input values that are smaller than the one stored in
<TT>median</TT>.
   <P >For those input values that are equal to the value stored in <TT>median</TT>, the program guesses
whether they should be considered as bigger values or smaller values.
   <P >The program checks that the guesses are correct by verifying that <TT>count</TT> holds either
the value 0 or the value 1. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >The <I>relation<A NAME="20003-18009"> </A> computed</I> by a program P, denoted R(P), is the set { (x, y) | P has an
accepting computation on input x with output y }. When P is a deterministic program, the
relation R(P) is a function.
   <P ><STRONG>Example 1.3.11</STRONG> <A 
   NAME="20003-18010t1.3.11"> </A> 
Consider the program P in Figure <A 
 HREF="#20003-18004r1.3.6">1.3.6</A>. Assume the set of natural numbers for the domain
of the variables. The relation R(P) that P computes is { (<FONT FACE="SYMBOL">a</FONT>, a) | <FONT FACE="SYMBOL">a</FONT> is a sequence of
natural numbers, and a is a natural number that does not appear in <FONT FACE="SYMBOL">a</FONT> }. <IMG 
SRC="theory-bk-one0x.gif" ALT=" ***
" 
 >
   <P >
   <P >The language that a program P accepts<A NAME="20003-18011"> </A> is denoted by L(P) and it consists of all the
inputs that P accepts.<A NAME="20003-18012"> </A><A NAME="20003-18013"> </A>
   <P ><EM><A 
   NAME="20003-19000"> </A><A 
 HREF="#Q2-20003-19"  NAME="Q1-20003-19">Configurations of Programs</A></EM>
   <P >An execution of a program on a given input is a discrete process in which the input is
consumed, an output is generated, the variables change their values, and the program
traverses its instructions. Each stage in the process depends on the outcome of the previous
stage, but not on the history of the stages. The outcome of each stage is a configuration of
the program that indicates the instruction being reached, the values stored in the variables,
the portion of the input left to be read, and the output that has been generated so far.
Consequently, the process can be described by a sequence of moves between
configurations of the program.
   <P >Formally, a segment of a program is said to be an <I>instruction<A NAME="20003-19001"> </A> segment</I> if it is of any of
the following forms.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="20003-19002xa"> </A>Read instruction
     <LI><A 
   NAME="20003-19003xb"> </A>Write instruction
     <LI><A 
   NAME="20003-19004xc"> </A>Assignment instruction
     <LI><A 
   NAME="20003-19005xd"> </A><B>if</B> Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) <B>then</B> portion of a conditional if instruction
     <LI><A 
   NAME="20003-19006xe"> </A><B>do</B> portion of a looping instruction
     <LI><A 
   NAME="20003-19007xf"> </A><B>until</B> Q(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) portion of a looping instruction
     <LI><A 
   NAME="20003-19008xg"> </A>Conditional accept instruction
     <LI><A 
   NAME="20003-19009xh"> </A>Reject instruction</OL>
Consider a program P that has k instruction segments, m variables, and a domain of
variables that is denoted by D. A <I>configuration</I><A NAME="20003-19010"> </A>, or <I>instantaneous<A NAME="20003-19011"> </A> description</I>, of P is a
five-tuple (i, x, u, v, w), where 1 <FONT FACE="SYMBOL">£</FONT> i <FONT FACE="SYMBOL">£</FONT> k, x is a sequence of m values from D, and u, v,
and w are sequences of values from D.
   <P >Intuitively, a configuration (i, x, u, v, w) says that P is in its <I>i</I>th instruction
segment, its <I>j</I>th variable contains the <I>j</I>th value of x, u is the portion of the input
that has already been read, the leftover of the input is v, and the output so far
is w. (The component u is not needed in the definition of a configuration. It is
inserted here for reasons of compatibility with future definitions that require such a
component.)
   <P ><STRONG>Example 1.3.12</STRONG> <A 
   NAME="20003-19012t1.3.12"> </A> 
Consider the program in Figure <A 
 HREF="#20003-19013r1.3.9">1.3.9</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20003-19013r1.3.9"> </A>
                  <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>last</TT> := ?                       /* I<SUB>1</SUB> */
<B>write</B> <TT>last</TT>                              /* I<SUB>2</SUB> */
<B>do</B>                                         /* I<SUB>3</SUB> */
    <B>read</B> <TT>value</TT>                        /* I<SUB>4</SUB> */
<B>until</B> <TT>value</TT> = <TT>last</TT>                 /* I<SUB>5</SUB> */
<B>if</B> <I>eof</I> <B>then accept</B>                /* I<SUB>6</SUB> */
<B>reject</B>                                    /* I<SUB>7</SUB> */ </PRE></TD></TR></TABLE>
<A 
   NAME="20003-19013r1.3.9"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.3.9 </STRONG></NOBR></TD><TD  
>A program consisting of seven instruction segments.                                                  </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Assume the set of natural numbers for the domain D of the variables, with 0 as initial
value. Each line I<SUB>i</SUB> in the program is an instruction segment. The program has k = 7
instruction segments, and m = 2 variables.
   <P >In each configuration (i, x, u, v, w) of the program i is a natural number between 1 and
7, and x is a pair &lt;last, value&gt; of natural numbers that corresponds to a possible
assignment of last and value in the variables <TT>last</TT> and <TT>value</TT>, respectively. Similarly, u, v,
and w are sequences of natural numbers.
   <P >The configuration (1, &lt;0, 0&gt;, &lt;&gt;, &lt;1, 2, 3&gt;, &lt;&gt;) states that the program is in the
first instruction segment, the variables hold the value 0, no input value has been read so far,
the rest of the input is &#34;1, 2, 3&#34;, and the output is empty.
   <P >The configuration (5, &lt;3, 2&gt;, &lt;1, 2&gt;, &lt;3&gt;, &lt;3&gt;) states that the program is in the
fifth instruction segment, the variable <TT>last</TT> holds the value 3, the variable <TT>value</TT> holds the
value 2, &#34;1, 2&#34; is the portion of the input consumed so far, the rest of the input
contains just the value 3, and the output so far contains only the value 3. <IMG 
SRC="theory-bk-one0x.gif" ALT=" ***
" 
 >
   <P >
   <P >A configuration (i, x, u, v, w) of P is called an <I>initial<A NAME="20003-19014"> </A> configuration</I> if i = 1, x
is a sequence of m initial values, u is an empty sequence, and w is an empty
sequence. The configuration is said to be an <I>accepting<A NAME="20003-19015"> </A> configuration</I> if the <I>i</I>th
instruction segment of P is a conditional accept instruction and v is an empty
sequence.
   <P >A direct move of P from configuration C<SUB>1</SUB> to configuration C<SUB>2</SUB> is denoted C<SUB>1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "><SUB> P </SUB>C<SUB>2</SUB>,
or simply C<SUB>1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "> C<SUB>2</SUB> if P is understood. A sequence of unspecified number of moves of P
from configuration C<SUB>1</SUB> to configuration C<SUB>2</SUB> is denoted C<SUB>1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "><SUB> P </SUB>* C<SUB>2</SUB>, or simply C<SUB>1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- ">* C<SUB>2</SUB> if
P is understood.
   <P ><STRONG>Example 1.3.13</STRONG> <A 
   NAME="20003-19016t1.3.13"> </A> 
Consider the program in Figure <A 
 HREF="#20003-19013r1.3.9">1.3.9</A>. On input &#34;1, 2, 3&#34; it has an accepting computation
that goes through the following sequence of moves between configurations. The first
configuration in the sequence is the initial configuration of the program on input
&#34;1, 2, 3&#34;, and the last configuration in the sequence is an accepting configuration of
the program. In each configuration (i, x, u, v, w) the pair x = &lt;last, value&gt;
corresponds to the assignment of last and value in the variables <TT>last</TT> and <TT>value</TT>,
respectively.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-one47x.gif" ALT=" (1,&lt;0,0&gt;, &lt;&gt;, &lt;1,2,3&gt;,&lt;&gt;)   |-   (2,&lt;3,0&gt;, &lt;&gt;,&lt;1, 2,3&gt;,&lt;&gt;)
                           |-   (3,&lt;3,0&gt;, &lt;&gt;,&lt;1, 2,3&gt;,&lt;3&gt;)
                           |-   (4,&lt;3,0&gt;, &lt;&gt;,&lt;1, 2,3&gt;,&lt;3&gt;)
                           |-   (5,&lt;3,1&gt;, &lt;1&gt;,&lt;2, 3&gt;,&lt;3&gt;)
                           |-   (3,&lt;3,1&gt;, &lt;1&gt;,&lt;2, 3&gt;,&lt;3&gt;)
                           |-   (4,&lt;3,1&gt;, &lt;1&gt;,&lt;2, 3&gt;,&lt;3&gt;)
                           |-   (5,&lt;3,2&gt;, &lt;1,2&gt;,&lt;3&gt;,&lt;3&gt;)
                           |-   (3,&lt;3,2&gt;, &lt;1,2&gt;,&lt;3&gt;,&lt;3&gt;)
                           |-   (4,&lt;3,2&gt;, &lt;1,2&gt;,&lt;3&gt;,&lt;3&gt;)
                           |-   (5,&lt;3,3&gt;, &lt;1,2,3&gt;,&lt;&gt;,&lt;3&gt;)
                           |-   (6,&lt;3,3&gt;, &lt;1,2,3&gt;,&lt;&gt;,&lt;3&gt;)"></PRE></CENTER>
   <P >The subcomputation
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-one48x.gif" ALT=" (1,&lt;0, 0&gt;,&lt;&gt;, &lt;1,2,3&gt;,&lt;&gt;) |-  *(1,&lt;0,0&gt;,&lt;&gt;,&lt;1,2,3&gt;,&lt;&gt;)"></PRE></CENTER>
   <P >consists of zero moves, and the subcomputation
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-one49x.gif" ALT=" (1,&lt;0, 0&gt;,&lt;&gt;, &lt;1,2,3&gt;,&lt;&gt;) |-  *(6,&lt;3,3&gt;,&lt;1,2,3&gt;,&lt;&gt;,&lt;3&gt;)"></PRE></CENTER>
   <P >consists of eleven moves. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >
   <P >[<A 
 HREF="theory-bk-onese4.html" >next</A>] [<A 
 HREF="theory-bk-onese2.html" >prev</A>] [<A 
 HREF="theory-bk-onese2.html#tailtheory-bk-onese2.html" >prev-tail</A>] [<A 
 HREF="theory-bk-onese3.html" >front</A>] [<A 
 HREF="theory-bk-one.html#theory-bk-onese3.html" >up</A>] <A 
   NAME="tailtheory-bk-onese3.html"> </A></BODY></HTML>