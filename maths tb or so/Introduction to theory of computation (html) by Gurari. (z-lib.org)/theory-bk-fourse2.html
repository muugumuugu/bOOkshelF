
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-four.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-fourse3.html" >next</A>] [<A 
 HREF="theory-bk-fourse1.html" >prev</A>] [<A 
 HREF="theory-bk-fourse1.html#tailtheory-bk-fourse1.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-fourse2.html">tail</A>] [<A 
 HREF="theory-bk-four.html#theory-bk-fourse2.html" >up</A>]
<H3>4.2 <A 
   NAME="50002-90004.2"> </A><A 
 HREF="theory-bk.html#Q2-50002-9"  NAME="Q1-50002-9">Programs and Turing Transducers</A></H3>
   <P >
      <A 
 HREF="#Q1-50002-10"  NAME="Q2-50002-10">From Programs to Turing Transducers</A>
<BR>         <A 
 HREF="#Q1-50002-11"  NAME="Q2-50002-11">From Turing Transducers to Programs</A>
   <P >The definition of a program relies on the notion of computability of functions and
predicates. In the cases of finite-memory programs and recursive finite-domain programs,
the computability of the program's functions and predicates is implied by the finiteness of
the domains of the variables. On the other hand, for the general class of programs the
issue of the computability of the functions and predicates needs to be resolved
explicitly.
   <P ><EM><A 
   NAME="50002-10000"> </A><A 
 HREF="#Q2-50002-10"  NAME="Q1-50002-10">From Programs to Turing Transducers</A></EM>
   <P >By Church's thesis a program's functions and predicates can be assumed
to be computable by deterministic Turing transducers. Consequently, a similar
assumption can be used when showing that programs can be simulated by Turing
transducers.
   <P >Consider any program P. Let D denote the domain of the variables of P and E be a
binary representation for D. Then P can be simulated by a Turing transducer M of the
following form.
   <P >M dedicates one auxiliary work tape for each of the variables of the program P.
Each input &#34;v<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, v<SUB>n</SUB>&#34; of the program P is presented to M by a string of the form
E(v<SUB>1</SUB>)# · · · #E(v<SUB>n</SUB>). Each output &#34;w<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, w<SUB>t</SUB>&#34; of P is represented in M by a string of
the form #E(w<SUB>1</SUB>)# · · · #E(w<SUB>t</SUB>). E(u) stands for the binary representation of
u.
   <P >For each instruction of the form <B>read</B> <TT>x</TT>, the Turing transducer M has a component that
reads the representation E(v) of the next input value v of P and stores it in the auxiliary
work tape that corresponds to <TT>x</TT>. Similarly, for each instruction of the form <B>write</B> <TT>x</TT> the
Turing transducer M has a component that copies onto the output tape the content of the
auxiliary work tape that corresponds to <TT>x</TT>.
   <P >For each instruction of the form <TT>y</TT> := f(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>) the Turing transducer has
a component similar to the deterministic Turing transducer that computes the
function f(<TT>x</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB>). The main difference is that the component gets the values of
<TT>x</TT><SUB>
1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>x</TT><SUB>m</SUB> from the auxiliary work tapes that correspond to the variables instead
of from the input, and instead of writing onto the output tape the component
writes the value of the function onto the auxiliary work tape that corresponds to
<TT>y</TT>.
   <P >In a similar manner M has a component corresponding to each of the other instruction
segments in P, as well as a component for recording the initial values of the
variables of P. Moreover, the components are arranged in M in the same order as in
P.
   <P >By construction, the Turing transducer M is deterministic when the program P is
deterministic.
   <P ><STRONG>Example 4.2.1</STRONG> <A 
   NAME="50002-10001t4.2.1"> </A> 
Let P be the program in Figure <A 
 HREF="#50002-10002r4.2.1">4.2.1</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50002-10002r4.2.1"> </A>
                         <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>do</B>
    <TT>y</TT> := ?
<B>or</B>
    <B>if</B> <TT>x</TT><IMG 
SRC="theory-bk-four9x.gif" ALT="/="ALIGN="MIDDLE" > <TT>y</TT> <B>then</B>
        <B>reject</B>
    <B>write</B> <TT>y</TT>
    <B>read</B> <TT>x</TT>
<B>until</B> <TT>x</TT> = 0
<B>if</B> <I>eof</I> <B>then accept</B> </PRE></TD></TR></TABLE>
<A 
   NAME="50002-10002r4.2.1"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.2.1 </STRONG></NOBR></TD><TD  
>A program.                                                                                                                   </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Assume the set of natural numbers for the domain of the variables of the program, with 0
as an initial value.
   <P >Figure <A 
 HREF="#50002-10003r4.2.2">4.2.2</A>(a)
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50002-10003r4.2.2"> </A>
<A 
   NAME="50002-10003r4.2.2"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-four-4-2-2.jpg" ALT="[PICT]" 
>
<BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure                                                                                                                  4.2.2
</STRONG></NOBR></TD><TD  
>(a) A schema of a Turing transducer M that simulates the program of Figure <A 
 HREF="#50002-10002r4.2.1">4.2.1</A>.
(b) A transition diagram for M. (The asterisk * stands for the current symbol under
the corresponding head.)                                             </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>shows the schema of a Turing transducer M that simulates P. The first auxiliary work tape
of M is used for recording the values of <TT>x</TT>. The second is used for recording the values of
<TT>y</TT>, and the third is used for recording the values of predicates (0 for false and 1 for
true).
   <P >Figure <A 
 HREF="#50002-10003r4.2.2">4.2.2</A>(b) gives the transition diagram of M. Each of the components of
M starts and ends each subcomputation with each of the heads of the auxiliary
work tapes positioned at the leftmost, nonblank symbol of the corresponding
tape.
   <P >The component &#34;Initiate the variables&#34; records the value 0 in the first and second
auxiliary work tapes.
   <P >The component &#34;<B>do</B> · · · <B>or</B> · · · &#34; nondeterministically chooses to proceed either to the
component &#34;<TT>y</TT> := ?&#34; or to &#34;<B>if</B> <TT>x</TT><IMG 
SRC="theory-bk-four10x.gif" ALT="/="ALIGN="MIDDLE" > <TT>y</TT> <B>then</B>.&#34;
   <P >In state q<SUB>2</SUB> the component &#34;<TT>y</TT> := ?&#34; erases the value recorded in the second auxiliary
work tape for <TT>y</TT>. Then the component enters state q<SUB>3</SUB> where it records a new value for <TT>y</TT>,
which is found nondeterministically.
   <P >The component &#34;<B>if</B> <TT>x</TT><IMG 
SRC="theory-bk-four11x.gif" ALT="/="ALIGN="MIDDLE" > <TT>y</TT> <B>then</B>&#34; locates in state q<SUB>4</SUB> the rightmost digits in <TT>x</TT> and <TT>y</TT>. In
state q<SUB>5</SUB> the component moves backward across the digits of <TT>x</TT> and <TT>y</TT> and determines
whether the corresponding digits are equal. If so, the component stores the value 0 in the
third auxiliary work tape. Otherwise, the component stores the value 1. In state q<SUB>6</SUB> the
component locates the leftmost digits of <TT>x</TT> and <TT>y</TT>, and depending on the value stored on the
third auxiliary work tape transfers the control either to the component &#34;<B>reject</B>&#34; or to &#34;<B>write</B>
<TT>y</TT>.&#34;
   <P >The component &#34;<B>write</B> <TT>y</TT>&#34; outputs the symbol # in state q<SUB>8</SUB>, and the value of <TT>y</TT> in state
q<SUB>9</SUB>. Then it returns to the leftmost symbol of <TT>y</TT>.
   <P >The component &#34;<B>read</B> <TT>x</TT>&#34; verifies in state q<SUB>11</SUB> that the input has a value to be read and
reads it in state q<SUB>12</SUB>. Then in state q<SUB>13</SUB> the component locates the leftmost digit of
<TT>x</TT>.
   <P >The component &#34;<B>until</B> <TT>x</TT> = 0&#34; checks whether <TT>x</TT> is 0 in state q<SUB>14</SUB>. If so, the component
stores 1 in the third auxiliary work tape. Otherwise, the component stores 0. In state q<SUB>15</SUB>
the component locates the leftmost digit of <TT>x</TT>, and then, depending on the value stored on
the third auxiliary work tape, either moves to the component &#34;<B>do</B> · · · <B>or</B> · · · &#34; or to &#34;<B>if</B> <I>eof</I>
<B>then accept</B>.&#34;
   <P >The component &#34;<B>if</B> <I>eof</I> <B>then accept</B>&#34; moves from state q<SUB>16</SUB> to the accepting state q<SUB>17</SUB> if
and only if the end of the input is reached. <IMG 
SRC="theory-bk-four0x.gif" ALT=" *** " 
 >
   <P >
   <P ><EM><A 
   NAME="50002-11000"> </A><A 
 HREF="#Q2-50002-11"  NAME="Q1-50002-11">From Turing Transducers to Programs</A></EM>
   <P >As a result of the previous discussion, we see that there is an algorithm that translates
any given program to an equivalent Turing transducer. Conversely, there is also an
algorithm that, for any given Turing transducer M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">G</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, B, F&gt;, provides
an equivalent program.
   <P >The program can be table-driven and of the form shown in Figure <A 
 HREF="#50002-11001r4.2.3">4.2.3</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50002-11001r4.2.3"> </A>
   <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE>/* Record the initial configuration              (uqv, u<SUB>1</SUB>qv<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, u<SUB>m</SUB>qv<SUB>m</SUB>, w)
of M (see Figure <A 
 HREF="theory-bk-fourse1.html#50001-4002r4.1.4">4.1.4</A>).                                                                                     */
<TT>state</TT> := q<SUB>0</SUB>
<TT>u</TT> := ¢
<TT>v</TT> := get(<TT>input</TT>)
<B>for</B> <TT>j</TT> := 1 <B>to</B> m <B>do</B>
    <B>begin</B>
        <TT>u</TT><SUB>j</SUB> := B · · · B
      <TT>v</TT><SUB>j</SUB> := B · · · B
   <B>end</B>
<TT>w</TT> := <FONT FACE="SYMBOL">e</FONT>
<B>do</B>
    /* Check for acceptance conditions. */
    <B>if</B> F(<TT>state</TT>) <B>then</B>
    <B>begin</B>
        <B>write</B> <TT>w</TT>
        <B>if</B> <I>eof</I> <B>then accept</B>
        <B>reject</B>
    <B>end</B>
    /* Determine the transition rule
            (state, a, b<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, b<SUB>m</SUB>, next_ state, d<SUB>0</SUB>, c<SUB>1</SUB>, d<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>c<SUB>m</SUB>, d<SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT>)
   to be used in the next simulated move.                                                          */
    <TT>a</TT> := top (<TT>v</TT>);  <TT>b</TT><SUB>1</SUB> := top (<TT>v</TT><SUB>1</SUB>); <FONT FACE="SYMBOL">¼</FONT> ; <TT>b</TT><SUB>m</SUB> := top (<TT>v</TT><SUB>m</SUB>)
   (<TT>next_ state</TT>, <TT>d</TT><SUB>0</SUB>, <TT>c</TT><SUB>1</SUB>, <TT>d</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>c</TT><SUB>m</SUB>, <TT>d</TT><SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT>) := <FONT FACE="SYMBOL">d</FONT>(<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>)
   /* Record the changes in the input head position. */
    <B>case</B>
        <TT>d</TT><SUB>0</SUB> = -1: <TT>a</TT> := top (<TT>u</TT>);  pop (<TT>u</TT>);  push (<TT>v</TT>, <TT>a</TT>)
      <TT>d</TT><SUB>0</SUB> = +1: push (<TT>u</TT>, <TT>a</TT>);  pop (<TT>v</TT>)
   <B>end</B>
    /* Record the changes in the auxiliary work tapes and in their corresponding
    head positions.                                                                                              */
    <B>for</B> <TT>j</TT> = 1 <B>to</B> m <B>do</B>
        <B>case</B>
            <TT>d</TT><SUB>j</SUB> = -1: pop (<TT>v</TT><SUB>j</SUB>);  push (<TT>v</TT><SUB>j</SUB>, <TT>c</TT><SUB>j</SUB>);  <TT>b</TT><SUB>j</SUB> := top (<TT>u</TT><SUB>j</SUB>);  
  pop (<TT>u</TT><SUB>j</SUB>);  push (<TT>v</TT><SUB>j</SUB>, <TT>b</TT><SUB>j</SUB>)
           <TT>d</TT><SUB>j</SUB> = 0: pop (<TT>v</TT><SUB>j</SUB>);  push (<TT>v</TT><SUB>j</SUB>, <TT>c</TT><SUB>j</SUB>)
         <TT>d</TT><SUB>j</SUB> = +1: push (<TT>u</TT><SUB>j</SUB>, <TT>c</TT><SUB>j</SUB>);  pop (<TT>v</TT><SUB>j</SUB>)
      <B>end</B>
    /* Record the output and modify the state. */
    <TT>w</TT> := append (<TT>w</TT>, <FONT FACE="SYMBOL">r</FONT>)
   <TT>state</TT> := <TT>next_ state</TT>
<B>until</B> false                                                                           </PRE></TD></TR></TABLE>
<A 
   NAME="50002-11001r4.2.3"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.2.3 </STRONG></NOBR></TD><TD  
>A table-driven program for simulating Turing transducers.                                         </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>The program simulates the Turing transducer in a manner like that of a finite-memory
program in Section 2.2 simulating a finite-state transducer. It is also similar to a recursive
finite-domain program in Section 3.2 simulating a pushdown transducer. The main
difference is in the recording of the content of the tapes.
   <P >The variables of the program are assumed to have the domain of natural
numbers. Intuitively, however, we consider the variables as having the domain
Q <FONT FACE="SYMBOL">È</FONT> ({¢, $} <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT>)* <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">G</FONT>* <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">D</FONT>* <FONT FACE="SYMBOL">È</FONT> {-1, 0, +1}.
   <P >For each of the nonoutput tapes of M the program has a pair of &#34;pushdown&#34; variables.
One pushdown variable is used for holding the sequence of characters on the tape to the
left of the corresponding head (at the given order). The other is used for holding the
sequence of characters on the tape from the corresponding head position to its right
(in reverse order). The pair of pushdown variables <TT>u</TT> and <TT>v</TT> is used for the input
tape. The pair <TT>u<SUB>i</SUB></TT> and <TT>v<SUB>i</SUB></TT> is used for the <I>i</I>th auxiliary work tape. The variable <TT>w</TT> is
used for recording the output, and the variable <TT>state</TT> is used for recording the
state.
   <P ><STRONG>Example 4.2.2</STRONG> <A 
   NAME="50002-11002t4.2.2"> </A> 
The program records the configuration (¢aabq<SUB>3</SUB>aab$, q<SUB>3</SUB>aab, aab) in the following manner
(see Figure <A 
 HREF="#50002-11003r4.2.4">4.2.4</A>(a)).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50002-11003r4.2.4"> </A>
<A 
   NAME="50002-11003r4.2.4"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-four-4-2-4.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.2.4 </STRONG></NOBR></TD><TD  
>Configurations of a Turing transducer.                                                                         </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P ><CENTER>
                       <TABLE  
><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>state</TT></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>q<SUB>3</SUB></TD>                              <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                         </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>u</TT></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>¢aab</TD>                             <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                         </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>v</TT></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>$baa</TD>                            <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                         </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>u</TT><SUB>1</SUB></TD> <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>B · · · B</TD>                          <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                         </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>v</TT><SUB>1</SUB></TD> <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>B · · · Bbaa</TD>                       <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                         </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>w</TT></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>aab</TD>                             <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>   <TD 
NOWRAP ALIGN="CENTER"  
></TD>   <TD 
NOWRAP ALIGN="LEFT "  
></TD>                                <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
</TR></TABLE>
</CENTER>
   <P >Similarly, the program records the configuration (¢aabaq<SUB>3</SUB>ab$, aq<SUB>3</SUB>ab, aab) in the
following manner (see Figure <A 
 HREF="#50002-11003r4.2.4">4.2.4</A>(b)).
   <P >      <P ><CENTER>
                                                <TABLE  
><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>state</TT></TD>    <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>   <TD 
NOWRAP ALIGN="LEFT "  
>q<SUB>3</SUB></TD>                                                          <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                                   </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                                 </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>u</TT></TD>    <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>   <TD 
NOWRAP ALIGN="LEFT "  
>¢aaba</TD>                                            <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                         </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>v</TT></TD>    <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>   <TD 
NOWRAP ALIGN="LEFT "  
>$ba</TD>                                              <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                         </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>u</TT><SUB>1</SUB></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>   <TD 
NOWRAP ALIGN="LEFT "  
>B · · · Ba</TD>                                       <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                         </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>v</TT><SUB>1</SUB></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>   <TD 
NOWRAP ALIGN="LEFT "  
>B · · · Bba  </TD>                                    <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                          </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                        </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><TT>w</TT></TD>    <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>   <TD 
NOWRAP ALIGN="LEFT "  
>aab</TD>                                              <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
</TR></TABLE>
</CENTER>                                                                                                   <IMG 
SRC="theory-bk-four12x.gif" ALT="PICT" >
   <P >
   <P >A simulation of a head movement to the right involves the pushing of a symbol
to the first pushdown variable, and the popping of a symbol from the second.
Similarly, a simulation of a head movement to the left involves the popping of a
symbol from the first pushdown variable, and the pushing of a symbol to the
second.
   <P >The program uses top (<TT>var</TT>) to determine the topmost symbol in <TT>var</TT>. The program uses
pop (<TT>var</TT>) to remove the topmost symbol from <TT>var</TT>, and it uses push (<TT>var</TT>, ch) and
append (<TT>var</TT>, <FONT FACE="SYMBOL">r</FONT>) to push ch and <FONT FACE="SYMBOL">r</FONT>, respectively, into <TT>var</TT>.
   <P ><TT>v</TT> := get (<TT>input</TT>) is assumed to be a code segment as shown in Figure <A 
 HREF="#50002-11004r4.2.5">4.2.5</A>(a).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50002-11004r4.2.5"> </A>
               <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>read</B> <TT>input</TT>
<TT>v</TT> := $
<B>if</B> not empty (<TT>input</TT>) <B>then</B>
    <B>do</B>
        <TT>char</TT> := top (<TT>input</TT>)
      <B>if</B> not input_ symbol (<TT>char</TT>) <B>then reject</B>
        pop (<TT>input</TT>)
      push (<TT>v</TT>, <TT>char</TT>)
   <B>until</B> empty (<TT>input</TT>)                         </PRE></TD></TR></TABLE>
                               (a)
                <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>next_ state</TT> := <FONT FACE="SYMBOL">d</FONT><SUB>state</SUB>(<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>)
<TT>c</TT><SUB>1</SUB>  := <FONT FACE="SYMBOL">d</FONT><SUB>c<SUB>1</SUB></SUB> (<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>)
      <IMG 
SRC="theory-bk-four13x.gif" ALT=".
..">
<TT>c</TT><SUB>m</SUB> := <FONT FACE="SYMBOL">d</FONT><SUB>c<SUB>m</SUB></SUB>(<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>)
<TT>d</TT><SUB>1</SUB>  := <FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>1</SUB></SUB> (<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>)
      <IMG 
SRC="theory-bk-four14x.gif" ALT="...">
<TT>d</TT><SUB>m</SUB> := <FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>m</SUB></SUB>(<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>)
<TT><FONT FACE="SYMBOL">r</FONT></TT><SUB> </SUB>   := <FONT FACE="SYMBOL">d</FONT><SUB><FONT FACE="SYMBOL">r</FONT><SUB> </SUB></SUB> (<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>)               </PRE></TD></TR></TABLE>
                               (b)
            <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><TT>next_ state</TT> := ?
<TT>c</TT><SUB>1</SUB>  := ?
      <IMG 
SRC="theory-bk-four15x.gif" ALT="..
.">
<TT>c</TT><SUB>m</SUB> := ?
<TT>d</TT><SUB>0</SUB>  := ?
      <IMG 
SRC="theory-bk-four16x.gif" ALT=".
..">
<TT>d</TT><SUB>m</SUB> := ?
<FONT FACE="SYMBOL">r</FONT>   := ?
<B>if</B> not <FONT FACE="SYMBOL">d</FONT><SUB>tran</SUB>(<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>, <TT>next_ state</TT>,
             <TT>d</TT><SUB>0</SUB>, <TT>c</TT><SUB>1</SUB>, <TT>d</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>c</TT><SUB>m</SUB>, <TT>d</TT><SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT>) <B>then reject</B>      </PRE></TD></TR></TABLE>
                               (c)
<A 
   NAME="50002-11004r4.2.5"> </A>
<BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure                                                                                                                  4.2.5
</STRONG></NOBR></TD><TD  
>(a) The code segment <TT>v</TT> := get (<TT>input</TT>). (b) The code segment
       (<TT>next_ state</TT>, <TT>d</TT><SUB>0</SUB>, <TT>c</TT><SUB>1</SUB>, <TT>d</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>c</TT><SUB>m</SUB>, <TT>d</TT><SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT>) := <FONT FACE="SYMBOL">d</FONT>(<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>)
for a deterministic Turing transducer. (c) The code segment
       (<TT>next_ state</TT>, <TT>d</TT><SUB>0</SUB>, <TT>c</TT><SUB>1</SUB>, <TT>d</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>c</TT><SUB>m</SUB>, <TT>d</TT><SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT>) := <FONT FACE="SYMBOL">d</FONT>(<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>)
for a nondeterministic Turing transducer.                                </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>F(<TT>state</TT>) is assumed to be a table lookup function specifying whether <TT>state</TT> holds an
accepting state. (<TT>next_ state</TT>, <TT>d</TT><SUB>0</SUB>, <TT>c</TT><SUB>1</SUB>, <TT>d</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>c</TT><SUB>m</SUB>, <TT>d</TT><SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT>) := <FONT FACE="SYMBOL">d</FONT>(<TT>state</TT>, <TT>a</TT>, <TT>b</TT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <TT>b</TT><SUB>m</SUB>) is assumed to be
a code segment as shown in Figure <A 
 HREF="#50002-11004r4.2.5">4.2.5</A>(b) for deterministic Turing transducers, and a
code segment as shown in Figure <A 
 HREF="#50002-11004r4.2.5">4.2.5</A>(c) for nondeterministic Turing transducers. <FONT FACE="SYMBOL">d</FONT><SUB>state</SUB>,
<FONT FACE="SYMBOL">d</FONT><SUB>c<SUB>1</SUB></SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">d</FONT><SUB>c<SUB>m</SUB></SUB>, <FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>0</SUB></SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>m</SUB></SUB>, <FONT FACE="SYMBOL">d</FONT><SUB><FONT FACE="SYMBOL">r</FONT></SUB>, <FONT FACE="SYMBOL">d</FONT><SUB>tran</SUB> are assumed to be table lookup functions specifying the
desired information.
   <P ><STRONG>Example 4.2.3</STRONG> <A 
   NAME="50002-11005t4.2.3"> </A> 
For the deterministic Turing transducer M<SUB>1</SUB>, whose transition diagram is given in
Figure <A 
 HREF="theory-bk-fourse1.html#50001-4007r4.1.6">4.1.6</A>, the following equalities hold.     <CENTER>
                    <TABLE  
><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>state</SUB>(q<SUB>0</SUB>, a, B, B)</TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>q<SUB>1</SUB></TD>                      <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>c<SUB>1</SUB></SUB>(q<SUB>0</SUB>, a, B, B)  </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>B</TD>                      <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>c<SUB>2</SUB></SUB>(q<SUB>0</SUB>, a, B, B)  </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>B</TD>                      <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB><FONT FACE="SYMBOL">r</FONT></SUB>  (q<SUB>0</SUB>, a, B, B)  </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
><FONT FACE="SYMBOL">e</FONT></TD>                       <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>0</SUB></SUB>(q<SUB>0</SUB>, a, B, B)  </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
> + 1</TD>                    <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>1</SUB></SUB>(q<SUB>0</SUB>, a, B, B)  </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>0</TD>                       <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>2</SUB></SUB>(q<SUB>0</SUB>, a, B, B)  </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>0</TD>                       <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>state</SUB>(q<SUB>2</SUB>, a, c, B) </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>q<SUB>2</SUB></TD>                      <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>c<SUB>1</SUB></SUB>(q<SUB>2</SUB>, a, c, B)    </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>a</TD>                      <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>c<SUB>2</SUB></SUB>(q<SUB>2</SUB>, a, c, B)    </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>B</TD>                      <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB><FONT FACE="SYMBOL">r</FONT></SUB>  (q<SUB>2</SUB>, a, c, B)    </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
><FONT FACE="SYMBOL">e</FONT></TD>                       <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>0</SUB></SUB>(q<SUB>2</SUB>, a, c, B)    </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
> - 1</TD>                    <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>1</SUB></SUB>(q<SUB>2</SUB>, a, c, B)    </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
> - 1</TD>                    <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                  </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                    </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>d<SUB>2</SUB></SUB>(q<SUB>2</SUB>, a, c, B)    </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>0</TD>                       <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
</TR></TABLE>
</CENTER>
   <P >For the nondeterministic Turing transducer M<SUB>2</SUB>, whose transition diagram is given in
Figure <A 
 HREF="theory-bk-fourse1.html#50001-3025r4.1.3">4.1.3</A>, the following equalities hold.    <CENTER>
               <TABLE  
><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>tran</SUB>(q<SUB>0</SUB>, a, B, q<SUB>1</SUB>, +1, a, +1, a)</TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>true</TD>               <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                       </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
               </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>tran</SUB>(q<SUB>0</SUB>, b, B, q<SUB>1</SUB>, +1, b, +1, b) </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>true</TD>               <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                       </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
               </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>tran</SUB>(q<SUB>0</SUB>, $, B, q<SUB>4</SUB>, 0, B, 0, <FONT FACE="SYMBOL">e</FONT>)    </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>true</TD>               <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
                                       </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
               </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
><FONT FACE="SYMBOL">d</FONT><SUB>tran</SUB>(q<SUB>0</SUB>, a, b, q<SUB>2</SUB>, 0, B, +1, <FONT FACE="SYMBOL">e</FONT>)   </TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>false</TD>               <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
</TR></TABLE>
</CENTER>
   <P >For M<SUB>1</SUB> and M<SUB>2</SUB> the equalities F(q<SUB>4</SUB>) = true, and F(q<SUB>0</SUB>) = F(q<SUB>1</SUB>) = F(q<SUB>2</SUB>) = F(q<SUB>3</SUB>) = false
hold. <IMG 
SRC="theory-bk-four0x.gif" ALT=" *** " 
 >
   <P >
   <P >The program represents each of the symbols in Q <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">G</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">D</FONT> <FONT FACE="SYMBOL">È</FONT> {¢, $, -1, 0, +1}
by a distinct number between 0 and k - 1, where k denotes the cardinality of
Q <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">G</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">D</FONT> <FONT FACE="SYMBOL">È</FONT> {¢, $, -1, 0, +1}. In particular, the blank symbol B is assumed to
correspond to 0. The variables are assumed to hold natural numbers that are
interpreted as the strings corresponding to the representations of the numbers in base
k.
   <P >top (<TT>var</TT>) returns the remainder of <TT>var</TT> divided by k. push (<TT>var</TT>, ch) assigns to <TT>var</TT> the
value <TT>var</TT> × k + ch. pop (<TT>var</TT>) assigns to <TT>var</TT> the integer value of <TT>var</TT> divided by k.
empty (<TT>var</TT>) provides the value true if <TT>var</TT> = 0, and provides the value false otherwise.
input_ symbol (<TT>char</TT>) is assumed to provide the value true if <TT>char</TT> holds a symbol from <FONT FACE="SYMBOL">S</FONT>,
and provides false otherwise. append (<TT>var</TT>, <FONT FACE="SYMBOL">r</FONT>) returns k × <TT>var</TT> + <FONT FACE="SYMBOL">r</FONT> if <FONT FACE="SYMBOL">r</FONT><IMG 
SRC="theory-bk-four17x.gif" ALT="/="ALIGN="MIDDLE" > 0, and returns the
value of <TT>var</TT> if <FONT FACE="SYMBOL">r</FONT> = 0.
   <P ><STRONG>Example 4.2.4</STRONG> <A 
   NAME="50002-11006t4.2.4"> </A> 
Let M be the deterministic Turing transducer whose transition diagram is given in
Figure <A 
 HREF="theory-bk-fourse1.html#50001-4007r4.1.6">4.1.6</A>. For such an M the set Q <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">G</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">D</FONT> <FONT FACE="SYMBOL">È</FONT> {¢, $, -1, 0, +1} is equal to
{B, a, b, c, ¢, $, -1, 0, +1, q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>3</SUB>, q<SUB>4</SUB>} and has cardinality k = 14. Under the given
order for the elements of the set Q <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">G</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">D</FONT> <FONT FACE="SYMBOL">È</FONT> {¢, $, -1, 0, +1}, the empty string <FONT FACE="SYMBOL">e</FONT>, as
well as any string B · · · B of blank symbols, is represented by 0. a is represented by 1, and
b is represented by 2. On the other hand, the input string abbab is represented by the natural
number <CENTER>
         <TABLE  
><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
>44312</TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>(((1 · 14 + 2) · 14 + 2) · 14 + 1) · 14 + 2</TD>             <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
              </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
              </TR><TR VALIGN="BASELINE"><TD 
NOWRAP ALIGN="RIGHT"  
></TD>  <TD 
NOWRAP ALIGN="CENTER"  
> =</TD>  <TD 
NOWRAP ALIGN="LEFT "  
>1 · 14<SUP>4</SUP> + 2 · 14<SUP>3</SUP> + 2 · 14<SUP>2</SUP> + 1 · 14<SUP>1</SUP> + 2 · 14<SUP>0</SUP>.</TD>         <TD 
WIDTH="10"></TD><TD 
NOWRAP ALIGN="RIGHT"  
></TD>
</TR></TABLE>
</CENTER>                                                              <IMG 
SRC="theory-bk-four18x.gif" ALT="PICT" ><P >
   <P >An obvious distinction between programs and Turing transducers is in the
primitiveness and uniformity of the descriptions of the latter. These characteristics
contribute to the importance of Turing transducers in the study of computation.
   <P >
   <P >[<A 
 HREF="theory-bk-fourse3.html" >next</A>] [<A 
 HREF="theory-bk-fourse1.html" >prev</A>] [<A 
 HREF="theory-bk-fourse1.html#tailtheory-bk-fourse1.html" >prev-tail</A>] [<A 
 HREF="theory-bk-fourse2.html" >front</A>] [<A 
 HREF="theory-bk-four.html#theory-bk-fourse2.html" >up</A>] <A 
   NAME="tailtheory-bk-fourse2.html"> </A></BODY></HTML>