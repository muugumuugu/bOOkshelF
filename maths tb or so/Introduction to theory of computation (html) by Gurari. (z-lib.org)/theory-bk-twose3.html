
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-two.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-twose4.html" >next</A>] [<A 
 HREF="theory-bk-twose2.html" >prev</A>] [<A 
 HREF="theory-bk-twose2.html#tailtheory-bk-twose2.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-twose3.html">tail</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose3.html" >up</A>]
<H3>2.3 <A 
   NAME="30003-110002.3"> </A><A 
 HREF="theory-bk.html#Q2-30003-11"  NAME="Q1-30003-11">Finite-State Automata and Regular Languages</A></H3>
   <P >
      <A 
 HREF="#Q1-30003-12"  NAME="Q2-30003-12">Finite-State Automata</A>
<BR>         <A 
 HREF="#Q1-30003-13"  NAME="Q2-30003-13">Nondeterminism versus Determinism in Finite-State Automata</A>
<BR>         <A 
 HREF="#Q1-30003-14"  NAME="Q2-30003-14">Finite-State Automata and Type 3 Grammars</A>
<BR>         <A 
 HREF="#Q1-30003-15"  NAME="Q2-30003-15">Type 3 Grammars and Regular Grammars</A>
<BR>         <A 
 HREF="#Q1-30003-16"  NAME="Q2-30003-16">Regular Languages and Regular Expressions</A>
<A NAME="30003-11001"> </A>
   <P >The computations of programs are driven by their inputs. The outputs are
just the results of the computations, and they have no influence on the course
that the computations take. Consequently, it seems that much can be studied
about finite-state transducers, or equivalently, about finite-memory programs even
when their outputs are ignored. The advantage of conducting a study of such
stripped-down finite-state transducers is in the simplified argumentation that they
allow.
   <P ><EM><A 
   NAME="30003-12000"> </A><A 
 HREF="#Q2-30003-12"  NAME="Q1-30003-12">Finite-State Automata</A></EM>
   <P >A finite-state transducer whose output components are ignored is called a finite-state
automaton. Formally, a <I>finite-state<A NAME="30003-12001"> </A> automaton</I> M is a tuple &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt;, where Q, <FONT FACE="SYMBOL">S</FONT>,
q<SUB>0</SUB>, and F are defined as for finite-state transducers, and the transition table <FONT FACE="SYMBOL">d</FONT> is a relation
from Q × (<FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> {<FONT FACE="SYMBOL">e</FONT>}) to Q.
   <P >Transition diagrams similar to those used for representing finite-state transducers can
also be used to represent finite-state automata. The only difference is that in the case of
finite-state automata, an edge that corresponds to a transition rule (p, <FONT FACE="SYMBOL">a</FONT>, p) is labeled by
the string <FONT FACE="SYMBOL">a</FONT>.
   <P ><STRONG>Example 2.3.1</STRONG> <A 
   NAME="30003-12002t2.3.1"> </A> 
The finite-state automaton that is induced by the finite-state transducer
of Figure <A 
 HREF="theory-bk-twose2.html#30002-5013r2.2.2">2.2.2</A> is &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt;, where Q = {q<SUB>0</SUB>, q<SUB>1</SUB>}, <FONT FACE="SYMBOL">S</FONT> = {a, b},
<FONT FACE="SYMBOL">d</FONT> = {(q<SUB>0</SUB>, a, q<SUB>1</SUB>), (q<SUB>0</SUB>, b, q<SUB>1</SUB>), (q<SUB>1</SUB>, b, q<SUB>1</SUB>), (q<SUB>1</SUB>, a, q<SUB>0</SUB>)}, and F = {q<SUB>0</SUB>}.
   <P >The transition diagram in Figure <A 
 HREF="#30003-12003r2.3.1">2.3.1</A> represents the finite-state automaton. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30003-12003r2.3.1"> </A>
<A 
   NAME="30003-12003r2.3.1"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-3-1.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.3.1 </STRONG></NOBR></TD><TD  
>A   finite-state   automaton   that   corresponds   to   the   finite-state   transducer   of
Figure <A 
 HREF="theory-bk-twose2.html#30002-5013r2.2.2">2.2.2</A>.                                                                                                                  </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >The finite-state automaton M is said to be <I>deterministic</I><A NAME="30003-12004"> </A> if, for each state q in Q and for
each input symbol a in <FONT FACE="SYMBOL">S</FONT>, the union <FONT FACE="SYMBOL">d</FONT>(q, a) <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">d</FONT>(q, <FONT FACE="SYMBOL">e</FONT>) is a multiset that contains at most one
element. The finite-state automaton is said to be <I>nondeterministic</I><A NAME="30003-12005"> </A> if it is not a deterministic
finite-state automaton.
   <P >A transition rule (q, <FONT FACE="SYMBOL">a</FONT>, p) of the finite-state automaton is said to be an <I><FONT FACE="SYMBOL">e</FONT><A NAME="30003-12006"> </A> transition rule</I>
if <FONT FACE="SYMBOL">a</FONT> = <FONT FACE="SYMBOL">e</FONT>. A finite-state automaton with no <FONT FACE="SYMBOL">e</FONT> transition rules is said to be an <I><FONT FACE="SYMBOL">e</FONT>-free</I><A NAME="30003-12007"> </A>
finite-state automaton.
   <P ><STRONG>Example 2.3.2</STRONG> <A 
   NAME="30003-12008t2.3.2"> </A> 
Consider the finite-state automaton M<SUB>1</SUB>  =  &lt;{q<SUB>0</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, q<SUB>6</SUB>}, {0, 1},
{(q<SUB>0</SUB>, 0, q<SUB>0</SUB>), (q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>1</SUB>), (q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>4</SUB>), (q<SUB>1</SUB>, 0, q<SUB>2</SUB>), (q<SUB>1</SUB>, 1, q<SUB>1</SUB>), (q<SUB>2</SUB>, 0, q<SUB>3</SUB>), (q<SUB>2</SUB>, 1, q<SUB>2</SUB>), (q<SUB>3</SUB>,
0, q<SUB>3</SUB>), (q<SUB>3</SUB>, 1, q<SUB>1</SUB>), (q<SUB>4</SUB>, 0, q<SUB>4</SUB>), (q<SUB>4</SUB>, 1, q<SUB>5</SUB>), (q<SUB>5</SUB>, 0, q<SUB>5</SUB>), (q<SUB>5</SUB>, 1, q<SUB>6</SUB>), (q<SUB>6</SUB>, 1, q<SUB>6</SUB>), (q<SUB>6</SUB>, 0, q<SUB>4</SUB>)},
q<SUB>0</SUB>, {q<SUB>0</SUB>, q<SUB>3</SUB>, q<SUB>6</SUB>}&gt;. The transition diagram of M<SUB>1</SUB> is given in Figure <A 
 HREF="#30003-12009r2.3.2">2.3.2</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30003-12009r2.3.2"> </A>
<A 
   NAME="30003-12009r2.3.2"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-3-2.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.3.2 </STRONG></NOBR></TD><TD  
>A nondeterministic finite-state automaton.                                                                  </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >M<SUB>1</SUB> is nondeterministic owing to the transition rules that originate at state q<SUB>0</SUB>. One of
the transition rules requires that an input value be read, whereas the other two transition
rules require that no input value be read. Moreover, M<SUB>1</SUB> is also nondeterministic when
the transition rule (q<SUB>0</SUB>, 0, q<SUB>0</SUB>) is ignored, because M<SUB>1</SUB> cannot determine locally
which of the other transition rules to follow on the moves that originate at state
q<SUB>0</SUB>.
   <P >The finite-state automaton M<SUB>2</SUB> in Figure <A 
 HREF="#30003-12010r2.3.3">2.3.3</A> is a deterministic finite-state
automaton.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30003-12010r2.3.3"> </A>
<A 
   NAME="30003-12010r2.3.3"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-3-3.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.3.3 </STRONG></NOBR></TD><TD  
>A deterministic finite-state automaton.                                                                        </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >M<SUB>1</SUB> has two <FONT FACE="SYMBOL">e</FONT> transition rules, and M<SUB>2</SUB> has one. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >A <I>configuration</I><A NAME="30003-12011"> </A>, or an <I>instantaneous<A NAME="30003-12012"> </A> description</I>, of the finite-state automaton is a
singleton uqv, where q is a state in Q, and uv is a string in <FONT FACE="SYMBOL">S</FONT>*. The configuration is said to
be an <I>initial<A NAME="30003-12013"> </A> configuration</I> if u = <FONT FACE="SYMBOL">e</FONT> and q is the initial state. The configuration is said to be
an <I>accepting</I><A NAME="30003-12014"> </A>, or <I>final</I>, <I>configuration</I> if v = <FONT FACE="SYMBOL">e</FONT> and q is an accepting state. With no loss of
generality it is assumed that Q and <FONT FACE="SYMBOL">S</FONT> are mutually disjoint.
   <P >Other definitions, like those of <IMG
SRC="cmsy10-60.gif" ALT=" |- "><SUB> M </SUB>, <IMG
SRC="cmsy10-60.gif" ALT=" |- ">, <IMG
SRC="cmsy10-60.gif" ALT=" |- "><SUB> M </SUB>*, <IMG
SRC="cmsy10-60.gif" ALT=" |- ">*, and acceptance, recognition, and
decidability of a language by a finite-state automaton, are similar to those given for
finite-state transducers.
   <P ><EM><A 
   NAME="30003-13000"> </A><A 
 HREF="#Q2-30003-13"  NAME="Q1-30003-13">Nondeterminism versus Determinism in Finite-State Automata</A></EM>
   <P >By the following theorem, nondeterminism does not add to the recognition power of
finite-state automata, even though it might add to their succinctness. The proof
of the theorem provides an algorithm for constructing, from any given n-state
finite-state automaton, an equivalent deterministic finite-state automaton of at most 2<SUP>n</SUP>
states.
   <P ><STRONG>Theorem 2.3.1</STRONG> <A 
   NAME="30003-13001t2.3.1"> </A> 
If a language is accepted by a finite-state automaton, then it is also decided by a
deterministic finite-state automaton that has no <FONT FACE="SYMBOL">e</FONT> transition rules.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30003-13002t"> </A> 
Consider any finite-state automaton M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt;. Let A<SUB>x</SUB> denote the set of all
the states that M can reach from its initial state q<SUB>0</SUB>, by the sequences of moves that
consume the string x, that is, the set { q | q<SUB>0</SUB>x <IMG
SRC="cmsy10-60.gif" ALT=" |- ">* xq }. Then an input w is accepted by M
if and only if A<SUB>w</SUB> contains an accepting state.
   <P >The proof relies on the observation that A<SUB>xa</SUB> contains exactly those states that can be
reached from the states in A<SUB>x</SUB>, by the sequences of transition rules that consume a, that is,
A<SUB>xa</SUB> = { p | q is in A<SUB>x</SUB>, and qa <IMG
SRC="cmsy10-60.gif" ALT=" |- ">* ap }.
   <P >Specifically, if p is a state in A<SUB>xa</SUB>, then by definition there is a sequence of transition
rules <FONT FACE="SYMBOL">t</FONT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">t</FONT><SUB>t</SUB> that takes M from the initial state q<SUB>0</SUB> to state p while consuming xa. This
sequence must have a prefix <FONT FACE="SYMBOL">t</FONT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">t</FONT><SUB>i</SUB> that takes M from q<SUB>0</SUB> to some state q while consuming
x (see Figure <A 
 HREF="#30003-13003r2.3.4">2.3.4</A>(a)).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30003-13003r2.3.4"> </A>
<A 
   NAME="30003-13003r2.3.4"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-3-4.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.3.4 </STRONG></NOBR></TD><TD  
>Sequences of transition rules that consume xa.                                                           </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Consequently, q is in A<SUB>x</SUB> and the subsequence <FONT FACE="SYMBOL">t</FONT><SUB>i+1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">t</FONT><SUB>t</SUB> of transition rules takes M from
state q to state p while consuming a.
   <P >On the other hand, if q is in A<SUB>x</SUB> and if p is a state that is reachable from state q by a
sequence <FONT FACE="SYMBOL">t</FONT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">t</FONT><SUB>s</SUB> of transition rules that consumes a, then the state p is in A<SUB>xa</SUB>. In such a
case, if <FONT FACE="SYMBOL">t</FONT>'<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">t</FONT>'<SUB>r</SUB> is a sequence of transition rules that takes M from the initial
state q<SUB>0</SUB> to state q while consuming x, then M can reach the state p from state
q<SUB>0</SUB> by the sequence <FONT FACE="SYMBOL">t</FONT>'<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">t</FONT>'<SUB>r</SUB>, <FONT FACE="SYMBOL">t</FONT><SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">t</FONT><SUB>s</SUB> of transition rules that consumes xa (see
Figure <A 
 HREF="#30003-13003r2.3.4">2.3.4</A>(b)).
   <P >As a result, to determine if a<SUB>1</SUB> · · · a<SUB>n</SUB> is accepted by M, one needs only to follow the
sequence A<SUB><FONT FACE="SYMBOL">e</FONT></SUB>, A<SUB>a<SUB>1</SUB></SUB>, A<SUB>a<SUB>1</SUB>a<SUB>2</SUB></SUB>, <FONT FACE="SYMBOL">¼</FONT> , A<SUB>a<SUB>1</SUB>··· a<SUB>n</SUB></SUB> of sets of states, where each A<SUB>a<SUB>1</SUB>··· a<SUB>i+1</SUB></SUB> is
uniquely determined from A<SUB>a<SUB>1</SUB>··· a<SUB>i</SUB></SUB> and a<SUB>i+1</SUB>. Therefore, a deterministic finite-state
automaton M' of the following form decides the language that is accepted by
M.
   <P >The set of states of M' is equal to { A | A is a subset of Q, and A = A<SUB>x</SUB> for some x in
<FONT FACE="SYMBOL">S</FONT>* }. Since Q is finite, it follows that Q has only a finite number of subsets A, and
consequently M' has also only a finite number of states. The initial state of M' is the
subset of Q that is equal to A<SUB><FONT FACE="SYMBOL">e</FONT></SUB>. The accepting states of M' are those states of M' that
contain at least one accepting state of M. The transition table of M' is the set
{ (A, a, A') | A and A' are states of M', a is in <FONT FACE="SYMBOL">S</FONT>, and A' is the set of states that the
finite-state automaton M can reach by consuming a from those states that are in
A }.
   <P >By definition, M' has no <FONT FACE="SYMBOL">e</FONT> transition rules. Moreover, M' is deterministic because, for
each x in <FONT FACE="SYMBOL">S</FONT>* and each a in <FONT FACE="SYMBOL">S</FONT>, the set A<SUB>xa</SUB> is uniquely defined from the set A<SUB>x</SUB> and the
symbol a. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P ><STRONG>Example 2.3.3</STRONG> <A 
   NAME="30003-13004t2.3.3"> </A> 
Let M be the finite-state automaton whose transition diagram is given in Figure <A 
 HREF="#30003-12009r2.3.2">2.3.2</A>. The
transition diagram in Figure <A 
 HREF="#30003-13005r2.3.5">2.3.5</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30003-13005r2.3.5"> </A>
<A 
   NAME="30003-13005r2.3.5"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-3-5.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.3.5 </STRONG></NOBR></TD><TD  
>A  transition  diagram  of  an  <FONT FACE="SYMBOL">e</FONT>-free,  deterministic  finite-state  automaton  that  is
equivalent  to  the  finite-state  automaton  whose  transition  diagram  is  given  in
Figure <A 
 HREF="#30003-12009r2.3.2">2.3.2</A>.                                                                                                                  </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>represents an <FONT FACE="SYMBOL">e</FONT>-free, deterministic finite-state automaton that is equivalent to M. Using the
terminology of the proof of Theorem <A 
 HREF="#30003-13001t2.3.1">2.3.1</A> A<SUB><FONT FACE="SYMBOL">e</FONT></SUB> = {q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>4</SUB>}, A<SUB>0</SUB> = {q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>4</SUB>}, and
A<SUB>00</SUB> = A<SUB>000</SUB> = · · · = A<SUB>0···0</SUB> = {q<SUB>0</SUB>, q<SUB>1</SUB>, q<SUB>2</SUB>, q<SUB>3</SUB>, q<SUB>4</SUB>}.
   <P >A<SUB><FONT FACE="SYMBOL">e</FONT></SUB> is the set of all the states that M can reach without reading any input.
q<SUB>0</SUB> is in A<SUB><FONT FACE="SYMBOL">e</FONT></SUB> because it is the initial state of M. q<SUB>1</SUB> and q<SUB>2</SUB> are in A<SUB><FONT FACE="SYMBOL">e</FONT></SUB> because M
has <FONT FACE="SYMBOL">e</FONT> transition rules that leave the initial state q<SUB>0</SUB> and enter states q<SUB>1</SUB> and q<SUB>2</SUB>,
respectively.
   <P >A<SUB>0</SUB> is the set of all the states that M can reach just by reading 0 from those states that
are in A<SUB><FONT FACE="SYMBOL">e</FONT></SUB>. q<SUB>0</SUB> is in A<SUB>0</SUB> because q<SUB>0</SUB> is in A<SUB><FONT FACE="SYMBOL">e</FONT></SUB> and M has the transition rule (q<SUB>0</SUB>, 0, q<SUB>0</SUB>). q<SUB>1</SUB> is in
A<SUB>0</SUB> because q<SUB>0</SUB> is in A<SUB><FONT FACE="SYMBOL">e</FONT></SUB> and M can use the pair (q<SUB>0</SUB>, 0, q<SUB>0</SUB>) and (q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>1</SUB>) of transition rules
to reach q<SUB>1</SUB> from q<SUB>0</SUB> just by reading 0. q<SUB>2</SUB> is in A<SUB>0</SUB> because q<SUB>0</SUB> is in A<SUB><FONT FACE="SYMBOL">e</FONT></SUB> and M can use the
pair (q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>1</SUB>) and (q<SUB>1</SUB>, 0, q<SUB>2</SUB>) of transition rules to reach q<SUB>2</SUB> from q<SUB>0</SUB> just by reading 0. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P >The result of the last theorem cannot be generalized to finite-state transducers,
because deterministic finite-state transducers can only compute functions, whereas
nondeterministic finite-state transducers can also compute relations which are not
functions, for example, the relation {(a, b), (a, c)}. In fact, there are also functions that can
be computed by nondeterministic finite-state transducers but that cannot be computed by
deterministic finite-state transducers. R = { (x0, 0<SUP>|x|</SUP>) | x is a string in {0, 1}* } <FONT FACE="SYMBOL">È</FONT>
{ (x1, 1<SUP>|x|</SUP>) | x is a string in {0, 1}* } is an example of such a function. The
function cannot be computed by a deterministic finite-state transducer because
each deterministic finite-state transducer M satisfies the following condition,
which is not shared by the function: if x<SUB>1</SUB> is a prefix of x<SUB>2</SUB> and M accepts x<SUB>1</SUB> and
x<SUB>2</SUB>, then the output of M on input x<SUB>1</SUB> is a prefix of the output of M on input x<SUB>2</SUB>
(Exercise <A 
 HREF="theory-bk-twoli1.html#30007-23025r2.2.5">2.2.5</A>).
   <P ><EM><A 
   NAME="30003-14000"> </A><A 
 HREF="#Q2-30003-14"  NAME="Q1-30003-14">Finite-State Automata and Type 3 Grammars</A></EM>
<A NAME="30003-14001"> </A>
   <P >The following two results imply that a language is accepted by a finite-state automaton
if and only if it is a Type 3 language. The proof of the first result shows how Type 3
grammars can simulate the computations of finite-state automata.
   <P ><STRONG>Theorem 2.3.2</STRONG> <A 
   NAME="30003-14002t2.3.2"> </A> 
Finite-state automata accept only Type 3 languages.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30003-14003t"> </A> 
Consider any finite-state automaton M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt;. By Theorem <A 
 HREF="#30003-13001t2.3.1">2.3.1</A> it can be
assumed that M is an <FONT FACE="SYMBOL">e</FONT>-free, finite-state automaton. With no loss of generality, it can also
be assumed that no transition rule takes M to its initial state when that state is
an accepting one. (If such is not the case, then one can add a new state q'<SUB>0</SUB> to
Q, make the new state q'<SUB>0</SUB> both an initial and an accepting state, and add a new
transition rule (q'<SUB>0</SUB>, <FONT FACE="SYMBOL">a</FONT>, q) to <FONT FACE="SYMBOL">d</FONT> for each transition rule of the form (q<SUB>0</SUB>, <FONT FACE="SYMBOL">a</FONT>, q) that is in
<FONT FACE="SYMBOL">d</FONT>.)
   <P >Let G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, [q<SUB>0</SUB>]&gt; be a Type 3 grammar, where N has a nonterminal symbol
[q] for each state q in Q and P has the following production rules.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="30003-14004xa"> </A>A production rule of the form [q] <FONT FACE="SYMBOL">®</FONT> a[p] for each transition rule (q, a, p) in
     the transition table <FONT FACE="SYMBOL">d</FONT>.
     <LI><A 
   NAME="30003-14005xb"> </A>A production rule of the form [q] <FONT FACE="SYMBOL">®</FONT> a for each transition rule (q, a, p) in <FONT FACE="SYMBOL">d</FONT>
     such that p is an accepting state in F.
     <LI><A 
   NAME="30003-14006xc"> </A>A production rule of the form [q<SUB>0</SUB>] <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> if the initial state q<SUB>0</SUB> is an accepting
     state in F.</OL>
The grammar G is constructed to simulate the computations of the finite-state automaton
M. G records the states of M through the nonterminal symbols. In particular, G uses its
start symbol [q<SUB>0</SUB>] to initiate a simulation of M at state q<SUB>0</SUB>. G uses a production rule of the
form [q] <FONT FACE="SYMBOL">®</FONT> a[p] to simulate a move of M from state q to state p. In using such a
production rule, G generates the symbol a that M reads in the corresponding move. G
uses a production rule of the form [q] <FONT FACE="SYMBOL">®</FONT> a instead of the production rule of the
form [q] <FONT FACE="SYMBOL">®</FONT> a[p], when it wants to terminate a simulation at an accepting state
p.
   <P >By induction on n it follows that a string a<SUB>1</SUB>a<SUB>2</SUB> · · · a<SUB>n</SUB> has a derivation in G of the
form [q] <FONT FACE="SYMBOL">Þ</FONT> a<SUB>1</SUB>[q<SUB>1</SUB>] <FONT FACE="SYMBOL">Þ</FONT> a<SUB>1</SUB>a<SUB>2</SUB>[q<SUB>2</SUB>] <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> a<SUB>1</SUB>a<SUB>2</SUB> · · · a<SUB>n-1</SUB>[q<SUB>n-1</SUB>] <FONT FACE="SYMBOL">Þ</FONT> a<SUB>1</SUB>a<SUB>2</SUB> · · · a<SUB>n</SUB>
if and only if M has a sequence of moves of the form
qa<SUB>1</SUB>a<SUB>2</SUB> · · · a<SUB>n</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "> a<SUB>1</SUB>q<SUB>1</SUB>a<SUB>2</SUB> · · · a<SUB>n</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "> a<SUB>1</SUB>a<SUB>2</SUB>q<SUB>2</SUB>a<SUB>3</SUB> · · · a<SUB>n</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "> · · ·  <IMG
SRC="cmsy10-60.gif" ALT=" |- "> a<SUB>1</SUB> · · · a<SUB>n-1</SUB>q<SUB>n-1</SUB>a<SUB>n</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "> a<SUB>1</SUB>a<SUB>2</SUB> · · · a<SUB>n</SUB>q<SUB>n</SUB>
for some accepting state q<SUB>n</SUB>. In particular the correspondence above holds for q = q<SUB>0</SUB>.
Therefore L(G) = L(M). <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P ><STRONG>Example 2.3.4</STRONG> <A 
   NAME="30003-14007t2.3.4"> </A> 
The finite-state automaton M<SUB>1</SUB>, whose transition diagram is given in Figure <A 
 HREF="#30003-14008r2.3.6">2.3.6</A>(b),
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30003-14008r2.3.6"> </A>
<A 
   NAME="30003-14008r2.3.6"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-3-6.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.3.6 </STRONG></NOBR></TD><TD  
>Two equivalent finite-state automata.                                                                           </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>is an <FONT FACE="SYMBOL">e</FONT>-free, deterministic finite-state automaton. M<SUB>1</SUB> is not suitable for a direct simulation
by a Type 3 grammar because its initial state q<SUB>0</SUB> is both an accepting state and a
destination of a transition rule. Without modifications to M<SUB>1</SUB> the algorithm that
constructs the grammar G will produce the production rule [q<SUB>0</SUB>] <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> because
q<SUB>0</SUB> is an accepting state, and the production rule [q<SUB>1</SUB>] <FONT FACE="SYMBOL">®</FONT> b[q<SUB>0</SUB>] because of the
transition rule (q<SUB>1</SUB>, b, q<SUB>0</SUB>). Such a pair of production rules cannot coexist in a Type 3
grammar.
   <P >M<SUB>1</SUB> is equivalent to the finite-state automaton M<SUB>2</SUB>, whose transition diagram is given
in Figure <A 
 HREF="#30003-14008r2.3.6">2.3.6</A>(a). The Type 3 grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, [q'<SUB>0</SUB>]&gt; generates the language
L(M<SUB>2</SUB>), if N = {[q'<SUB>0</SUB>], [q<SUB>0</SUB>], [q<SUB>1</SUB>], [q<SUB>2</SUB>]}, <FONT FACE="SYMBOL">S</FONT> = {a, b}, and P consists of the following
production rules.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-two11x.gif" ALT="   '
[q0] ®   e
     ®   a[q1]
     ®   b[q1]
[q0] ®   a[q1]
     ®   b[q1]
[q1] ®   b[q0]
     ®   b
     ®   a[q2]
     ®   a"></PRE></CENTER>
   <P >The accepting computation q'<SUB>0</SUB>abaa <IMG
SRC="cmsy10-60.gif" ALT=" |- "> aq<SUB>1</SUB>baa <IMG
SRC="cmsy10-60.gif" ALT=" |- "> abq<SUB>0</SUB>aa <IMG
SRC="cmsy10-60.gif" ALT=" |- "> abaq<SUB>1</SUB>a <IMG
SRC="cmsy10-60.gif" ALT=" |- "> abaaq<SUB>2</SUB> of M<SUB>2</SUB>
on input abaa is simulated by the derivation [q'<SUB>0</SUB>] <FONT FACE="SYMBOL">Þ</FONT> a[q<SUB>1</SUB>] <FONT FACE="SYMBOL">Þ</FONT> ab[q<SUB>0</SUB>] <FONT FACE="SYMBOL">Þ</FONT> aba[q<SUB>1</SUB>] <FONT FACE="SYMBOL">Þ</FONT> abaa of
the grammar.
   <P >The production rule [q<SUB>1</SUB>] <FONT FACE="SYMBOL">®</FONT> a[q<SUB>2</SUB>] can be eliminated from the grammar without
affecting the generated language. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >The next theorem shows that the converse of Theorem <A 
 HREF="#30003-14002t2.3.2">2.3.2</A> also holds. The proof
shows how finite-state automata can trace the derivations of Type 3 grammars.
   <P ><STRONG>Theorem 2.3.3</STRONG> <A 
   NAME="30003-14009t2.3.3"> </A> 
Each Type 3 language is accepted by a finite-state automaton.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30003-14010t"> </A> 
Consider any Type 3 grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt;. The finite-state automaton
M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>S</SUB>, F&gt; accepts the language that G generates if Q, <FONT FACE="SYMBOL">d</FONT>, q<SUB>S</SUB>, and F are as
defined below.
   <P >M has a state q<SUB>A</SUB> in Q for each nonterminal symbol A in N. In addition, Q also has a
distinguished state named q<SUB>f</SUB>. The state q<SUB>S</SUB> of M, which corresponds to the start symbol S,
is designated as the initial state of M. The state q<SUB>f</SUB> of M is designated to be the only
accepting state of M, that is, F = {q<SUB>f</SUB>}.
   <P >M has a transition rule in <FONT FACE="SYMBOL">d</FONT> if and only if the transition rule corresponds to a
production rule of G. Each transition rule of the form (q<SUB>A</SUB>, a, q<SUB>B</SUB>) in <FONT FACE="SYMBOL">d</FONT> corresponds to a
production rule of the form A <FONT FACE="SYMBOL">®</FONT> aB in G. Each transition rule of the form (q<SUB>A</SUB>, a, q<SUB>f</SUB>) in <FONT FACE="SYMBOL">d</FONT>
corresponds to a production rule of the form A <FONT FACE="SYMBOL">®</FONT> a in G. Each transition rule of
the form (q<SUB>S</SUB>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>f</SUB>) in <FONT FACE="SYMBOL">d</FONT> corresponds to a production rule of the form S <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> in
G.
   <P >The finite-state automaton M is constructed so as to trace the derivations of the
grammar G in its computations. M uses its states to keep track of the nonterminal symbols
in use in the sentential forms of G. M uses its transition rules to consume the input
symbols that G generates in the direct derivations that use the corresponding production
rules.
   <P >By induction on n, the constructed finite-state automaton M has a sequence
q<SUB>A<SUB>0</SUB></SUB>x <IMG
SRC="cmsy10-60.gif" ALT=" |- "> u<SUB>1</SUB>q<SUB>A<SUB>1</SUB></SUB>v<SUB>1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "> u<SUB>2</SUB>q<SUB>A<SUB>2</SUB></SUB>v<SUB>2</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "> · · ·  <IMG
SRC="cmsy10-60.gif" ALT=" |- "> u<SUB>n-1</SUB>q<SUB>A<SUB>n-1</SUB></SUB>v<SUB>n-1</SUB> <IMG
SRC="cmsy10-60.gif" ALT=" |- "> xq<SUB>A<SUB>n</SUB></SUB>  of  n  moves
if and only if the grammar G has a derivation of length n of the form
A<SUB>0</SUB> <FONT FACE="SYMBOL">Þ</FONT> u<SUB>1</SUB>A<SUB>1</SUB> <FONT FACE="SYMBOL">Þ</FONT> u<SUB>2</SUB>A<SUB>2</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> u<SUB>n-1</SUB>A<SUB>n-1</SUB> <FONT FACE="SYMBOL">Þ</FONT> x. In particular, such correspondence
holds for A<SUB>0</SUB> = S. Consequently, x is in L(M) if and only if it is in L(G). <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P ><STRONG>Example 2.3.5</STRONG> <A 
   NAME="30003-14011t2.3.5"> </A> 
Consider the Type 3 grammar G = &lt;{S, A, B}, {a, b}, P, S&gt;, where P consists of the
following transition rules.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-two12x.gif" ALT=" S  ®   e
   ®   aA
   ®   bB
A  ®   aA
   ®   b
B  ®   bB
   ®   a"></PRE></CENTER>
   <P >The transition diagram in Figure <A 
 HREF="#30003-14012r2.3.7">2.3.7</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30003-14012r2.3.7"> </A>
<A 
   NAME="30003-14012r2.3.7"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-3-7.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.3.7 </STRONG></NOBR></TD><TD  
>A   finite-state   automaton   that   accepts   L(G),   where   G   is   the   grammar   of
Example <A 
 HREF="#30003-14011t2.3.5">2.3.5</A>.                                                                                                              </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>represents a finite-state automaton that accepts the language L(G). The derivation
S <FONT FACE="SYMBOL">Þ</FONT> aA <FONT FACE="SYMBOL">Þ</FONT> aaA <FONT FACE="SYMBOL">Þ</FONT> aab in G is traced by the computation q<SUB>S</SUB>aab <IMG
SRC="cmsy10-60.gif" ALT=" |- "> aq<SUB>A</SUB>ab <IMG
SRC="cmsy10-60.gif" ALT=" |- "> aaq<SUB>A</SUB>b <IMG
SRC="cmsy10-60.gif" ALT=" |- "> aabq<SUB>f</SUB>
of M. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >It turns out that finite-state automata and Type 3 grammars are quite similar
mathematical systems. The states in the automata play a role similar to the nonterminal
symbols in the grammars, and the transition rules in the automata play a role similar to the
production rules in the grammars.
   <P ><EM><A 
   NAME="30003-15000"> </A><A 
 HREF="#Q2-30003-15"  NAME="Q1-30003-15">Type 3 Grammars and Regular Grammars</A></EM>
   <P >Type 3 grammars seem to be minimal in the sense that placing further meaningful
restrictions on them results in grammars that cannot generate all the Type 3 languages. On
the other hand, some of the restrictions placed on Type 3 grammars can be relaxed without
increasing the class of languages that they can generate.
   <P >Specifically, a grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt; is said to be a <I>right-linear<A NAME="30003-15001"> </A> grammar</I> if
each of its production rules is either of the form A <FONT FACE="SYMBOL">®</FONT> xB or of the form A <FONT FACE="SYMBOL">®</FONT> x, where A
and B are nonterminal symbols in N and x is a string of terminal symbols in
<FONT FACE="SYMBOL">S</FONT>*.
   <P >The grammar is said to be a <I>left-linear<A NAME="30003-15002"> </A> grammar</I> if each of its production rules is either
of the form A <FONT FACE="SYMBOL">®</FONT> Bx or of the form A <FONT FACE="SYMBOL">®</FONT> x, where A and B are nonterminal symbols in N
and x is a string of terminal symbols in <FONT FACE="SYMBOL">S</FONT>*.
   <P >The grammar is said to be a <I>regular<A NAME="30003-15003"> </A> grammar</I> if it is either a right-linear grammar or a
left-linear grammar. A language is said to be a <I>regular language</I> if it is generated by a
regular grammar.
   <P >By Exercise <A 
 HREF="theory-bk-twoli1.html#30007-23044r2.3.5">2.3.5</A> a language is a Type 3 language if and only if it is regular.
   <P ><EM><A 
   NAME="30003-16000"> </A><A 
 HREF="#Q2-30003-16"  NAME="Q1-30003-16">Regular Languages and Regular Expressions</A></EM>
   <P >Regular languages can also be defined, from the empty set and from some finite
number of singleton sets, by the operations of union, composition, and Kleene closure.
Specifically, consider any alphabet <FONT FACE="SYMBOL">S</FONT>. Then a <I>regular<A NAME="30003-16001"> </A> set</I> over <FONT FACE="SYMBOL">S</FONT> is defined in the following
way.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="30003-16002xa"> </A>The empty set Ø, the set {<FONT FACE="SYMBOL">e</FONT>} containing only the empty string, and the set {a}
     for each symbol a in <FONT FACE="SYMBOL">S</FONT>, are regular sets.
     <LI><A 
   NAME="30003-16003xb"> </A>If L<SUB>1</SUB> and L<SUB>2</SUB> are regular sets, then so are the union L<SUB>1</SUB> <FONT FACE="SYMBOL">È</FONT> L<SUB>2</SUB>, the composition
     L<SUB>1</SUB>L<SUB>2</SUB>, and the Kleene closure L<SUB>1</SUB>*.
     <LI><A 
   NAME="30003-16004xc"> </A>No other set is regular.</OL>
By Exercise <A 
 HREF="theory-bk-twoli1.html#30007-23045r2.3.6">2.3.6</A> the following characterization holds.
   <P ><STRONG>Theorem 2.3.4</STRONG> <A 
   NAME="30003-16005t2.3.4"> </A> 
A set is a regular set if and only if it is accepted by a finite-state automaton.
   <P >
   <P >Regular sets of the form Ø, {<FONT FACE="SYMBOL">e</FONT>}, {a}, L<SUB><FONT FACE="SYMBOL">a</FONT></SUB> <FONT FACE="SYMBOL">È</FONT> L<SUB><FONT FACE="SYMBOL">b</FONT></SUB>, L<SUB><FONT FACE="SYMBOL">a</FONT></SUB>L<SUB><FONT FACE="SYMBOL">b</FONT></SUB>, and L<SUB><FONT FACE="SYMBOL">a</FONT></SUB>* are quite often denoted
by the expressions Ø, <FONT FACE="SYMBOL">e</FONT>, a, (<FONT FACE="SYMBOL">a</FONT>) + (<FONT FACE="SYMBOL">b</FONT>), (<FONT FACE="SYMBOL">a</FONT>)(<FONT FACE="SYMBOL">b</FONT>), and (<FONT FACE="SYMBOL">a</FONT>)*, respectively. <FONT FACE="SYMBOL">a</FONT> and <FONT FACE="SYMBOL">b</FONT> are assumed
to be the expressions that denote L<SUB><FONT FACE="SYMBOL">a</FONT></SUB> and L<SUB><FONT FACE="SYMBOL">b</FONT></SUB> in a similar manner, respectively. a is
assumed to be a symbol from the alphabet. Expressions that denote regular sets in this
manner are called <I>regular expressions</I>.
   <P >Some parentheses can be omitted from regular expressions, if a precedence relation
between the operations of Kleene closure, composition, and union in the given order is
assumed. The omission of parentheses in regular expressions is similar to that in
arithmetic expressions, where closure, composition, and union in regular expressions
play a role similar to exponentiation, multiplication, and addition in arithmetic
expressions.
   <P ><STRONG>Example 2.3.6</STRONG> <A 
   NAME="30003-16006t2.3.6"> </A> 
The regular expression 0*(1*01*00*(11*01*00*)* + 0*10*11*(00*10*11*)*) denotes
the language that is recognized by the finite-state automaton whose transition diagram is
given in Figure <A 
 HREF="#30003-12009r2.3.2">2.3.2</A>. The expression indicates that each string starts with an arbitrary
number of 0's. Then the string continues with a string in 1*01*00*(11*01*00*)* or with
a string in 10*11*(00*10*11*)*. In the first case, the string continues with an arbitrary
number of 1's, followed by 0, followed by an arbitrary number of 1's, followed by one
or more 0's, followed by an arbitrary number of strings in 11*01*00*. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
<A NAME="30003-16007"> </A>
   <P >By the previous discussion, nondeterministic finite-state automata, deterministic
finite-state automata, regular<A NAME="30003-16008"> </A> grammars, and regular expressions are all characterizations
of the languages that finite-memory programs accept. Moreover, there are effective
procedures for moving between the different characterizations. These procedures provide
the foundation for many systems that produce finite-memory-based programs from
characterizations of the previous nature. For instance, one of the best known systems,
called LEX<A NAME="30003-16009"> </A>, gets inputs that are generalizations of regular expressions and provides
outputs that are scanners. The advantage of such systems is obviously in the reduced effort
they require for obtaining the desired programs.
   <P >Figure <A 
 HREF="#30003-16010r2.3.8">2.3.8</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30003-16010r2.3.8"> </A>
<A 
   NAME="30003-16010r2.3.8"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-3-8.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.3.8 </STRONG></NOBR></TD><TD  
>The structural and functional relationships between some descriptive systems.         </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>illustrates the structural and functional hierarchies for some descriptive systems. The
structural hierarchies are shown by the directed acyclic graphs. The functional hierarchy is
shown by the Venn diagram.
   <P >
   <P >[<A 
 HREF="theory-bk-twose4.html" >next</A>] [<A 
 HREF="theory-bk-twose2.html" >prev</A>] [<A 
 HREF="theory-bk-twose2.html#tailtheory-bk-twose2.html" >prev-tail</A>] [<A 
 HREF="theory-bk-twose3.html" >front</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose3.html" >up</A>] <A 
   NAME="tailtheory-bk-twose3.html"> </A></BODY></HTML>