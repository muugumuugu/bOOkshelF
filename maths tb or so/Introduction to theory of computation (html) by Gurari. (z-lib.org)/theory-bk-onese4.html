
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-one.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-onese5.html" >next</A>] [<A 
 HREF="theory-bk-onese3.html" >prev</A>] [<A 
 HREF="theory-bk-onese3.html#tailtheory-bk-onese3.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-onese4.html">tail</A>] [<A 
 HREF="theory-bk-one.html#theory-bk-onese4.html" >up</A>]
<H3>1.4 <A 
   NAME="20004-200001.4"> </A><A 
 HREF="theory-bk.html#Q2-20004-20"  NAME="Q1-20004-20">Problems</A></H3>
   <P >
      <A 
 HREF="#Q1-20004-21"  NAME="Q2-20004-21">Partial Solvability and Solvability</A>
<BR>         <A 
 HREF="#Q1-20004-22"  NAME="Q2-20004-22">Problems concerning Programs</A>
<BR>         <A 
 HREF="#Q1-20004-23"  NAME="Q2-20004-23">Problems concerning Grammars</A>
   <P >The first two sections of this chapter treated different aspects of information. The third
section considered programs. The purpose of the rest of this chapter is to deal with
the motivation for writing programs for manipulating information, that is, with
problems.
   <P >Each <I>problem</I><A NAME="20004-20001"> </A> K is a pair consisting of a set and a question, where the question can be
applied to each element in the set. The set is called the <I>domain</I><A NAME="20004-20002"> </A> of the problem, and its
elements are called the <I>instances</I><A NAME="20004-20003"> </A> of the problem.
   <P ><STRONG>Example 1.4.1</STRONG> <A 
   NAME="20004-20004t1.4.1"> </A> 
Consider the problem K<SUB>1</SUB> defined by the following domain and question.
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ &lt;a, b&gt; | a and b are natural numbers }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>What  is  the  integer  part  y of  a  divided  by  b  for  the  given  instance
      x = &lt;a, b&gt;?</DL>
The domain of the problem contains the instances &lt;0, 0&gt;, &lt;5, 0&gt;, &lt;3, 8&gt;,
&lt;24, 6&gt;, and &lt;27, 8&gt;. On the other hand, &lt;-5, 3&gt; is not an instance of the
problem.
   <P >For the instance &lt;27, 8&gt; the problem asks what is the integer part of  27 divided by 8.
Similarly, for the instance &lt;0, 0&gt; the problem asks what is the integer part of 0 divided by
0. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >An answer to the question that the problem K poses for a given instance is said to be a
<I>solution</I><A NAME="20004-20005"> </A> for the problem at the given instance. The <I>relation<A NAME="20004-20006"> </A> induced by the problem</I>,
denoted R(K), is the set { (x, y) | x is an instance of the problem, and y is a solution for
the problem at x }. The problem is said to be a <I>decision<A NAME="20004-20007"> </A> problem</I> if for each instance the
problem has either a yes or a no solution.
   <P ><STRONG>Example 1.4.2</STRONG> <A 
   NAME="20004-20008t1.4.2"> </A> 
Consider the problem K<SUB>1</SUB> in Example <A 
 HREF="#20004-20004t1.4.1">1.4.1</A>. The problem has the solution 3 at instance
&lt;27, 8&gt;, and an undefined solution at instance &lt;0, 0&gt;. K<SUB>1</SUB> induces the relation
R(K<SUB>1</SUB>) = {(&lt;0, 1&gt;, 0), (&lt;0, 2&gt;, 0), (&lt;1, 1&gt;, 1), (&lt;0, 3&gt;, 0), (&lt;1, 2&gt;, 0), (&lt;2, 1&gt;, 2), (&lt;0, 3&gt;, 0),<FONT FACE="SYMBOL"> ¼</FONT> }.
   <P >The problem K<SUB>1</SUB> is not a decision problem. But the problem K<SUB>2</SUB> defined by the
following pair is.
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ &lt;a, b&gt; | a and b are natural numbers }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Does b divide a, for the given instance &lt;a, b&gt;?<IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 ></DL>
   <P >
   <P ><EM><A 
   NAME="20004-21000"> </A><A 
 HREF="#Q2-20004-21"  NAME="Q1-20004-21">Partial Solvability and Solvability</A></EM>
   <P >A program<A NAME="20004-21001"> </A> P is said to <I>partially<A NAME="20004-21002"> </A> solve</I> a given problem K if it provides the answer for
each instance of the problem, that is, if R(P) = R(K). If, in addition, all the
computations of the program are halting computations, then the program is said to <I>solve</I><A NAME="20004-21003"> </A>
the problem.
   <P ><STRONG>Example 1.4.3</STRONG> <A 
   NAME="20004-21004t1.4.3"> </A> 
Consider the program P<SUB>1</SUB> in Figure <A 
 HREF="#20004-21005r1.4.1">1.4.1</A>(a). The domain of the variables is assumed to
equal the set of natural numbers. The program partially solves the problem K<SUB>1</SUB> of
Example <A 
 HREF="#20004-20004t1.4.1">1.4.1</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20004-21005r1.4.1"> </A>
<TABLE WIDTH="100%"> <TR VALIGN="BOTTOM"><TD NOWRAP><TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>read</B> <TT>a</TT>
<B>read</B> <TT>b</TT>
<TT>ans</TT> := 0
<B>if</B> <TT>a</TT> <FONT FACE="SYMBOL">³</FONT> <TT>b</TT> <B>then</B>
    <B>do</B>
        <TT>a</TT> := <TT>a</TT> - <TT>b</TT>
        <TT>ans</TT> := <TT>ans</TT> + 1
   <B>until</B> <TT>a</TT>&lt;<TT>b</TT>
<B>write</B> <TT>ans</TT>
<B>if</B> <I>eof</I> <B>then accept</B>    </PRE></TD></TR></TABLE></TD><TD> </TD><TD NOWRAP><TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>read</B> <TT>a</TT>
<B>read</B> <TT>b</TT>
<B>do</B>
    <B>if</B> <TT>a</TT> = <TT>b</TT> <B>then</B>
        <B>if</B> <I>eof</I> <B>then accept</B>
    <TT>a</TT> := <TT>a</TT> - <TT>b</TT>
<B>until</B> false               </PRE></TD></TR></TABLE></TD></TR><TR><TD ALIGN="CENTER">(a) </TD><TD> </TD><TD ALIGN="CENTER">(b) </TD></TR></TABLE>  <A 
   NAME="20004-21005r1.4.1"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.4.1 </STRONG></NOBR></TD><TD  
>(a) A program that partially solves the problem of dividing natural numbers. (b) A
program that partially decides the problem of divisibility of natural numbers.           </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >On input &#34;27, 8&#34; the program halts in an accepting configuration with the answer 3 in
the output. On input &#34;0, 0&#34; the program never halts, and so the program has undefined
output on such an input. On input &#34;27&#34; and input &#34;27, 8, 2&#34; the program halts in rejecting
configurations and does not define an output.
   <P >The program P<SUB>1</SUB> does not solve K<SUB>1</SUB> because it does not halt when the input value for <TT>b</TT>
is 0. P<SUB>1</SUB> can be modified to a program P that solves K<SUB>1</SUB> by letting P check for a 0
assignment to <TT>b</TT>. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >A program is said to <I>partially decide</I> a problem if the following two conditions are
satisfied.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="20004-21006xa"> </A>The problem is a decision problem; and
     <LI><A 
   NAME="20004-21007xb"> </A>The program accepts a given input if and only if the problem has an answer
     yes for  the  input,  that  is,  the  program  accepts  the  language  { x  |  x is an
     instance of the problem, and the problem has the answer yes at x }.</OL>
A program is said to <I>decide</I> a problem if it partially decides the problem and all its
computations are halting computations.
   <P ><STRONG>Example 1.4.4</STRONG> <A 
   NAME="20004-21008t1.4.4"> </A> 
It is meaningless to talk about the partial decidability or decidability of the problem K<SUB>1</SUB> of
Example <A 
 HREF="#20004-20004t1.4.1">1.4.1</A> by a program, because the problem is not a decision problem.
On the other hand, the problem K<SUB>2</SUB> of Example <A 
 HREF="#20004-20008t1.4.2">1.4.2</A> is a decision problem. The
latter problem is partially decidable by the program P<SUB>2</SUB> in Figure <A 
 HREF="#20004-21005r1.4.1">1.4.1</A>(b). <IMG 
SRC="theory-bk-one0x.gif" ALT=" ***
" 
 >
   <P >
   <P >The main difference between a program P<SUB>1</SUB> that partially solves (partially
decides) a problem, and a program P<SUB>2</SUB> that solves (decides) the same problem,
is that P<SUB>1</SUB> might reject an input by a nonhalting computation, whereas P<SUB>2</SUB> can
reject the input only by a halting computation. (Recall that on an input that is
accepted by a program, the program has only accepting computations, and all
these computations are halting computations. But on an input that is not accepted
the program might have more than one computation, of which some may never
halt.)<A NAME="20004-21009"> </A>
   <P >The notions of partial solvability, solvability, partial decidability, and decidability of a
problem by a program can be intuitively generalized in a straightforward manner by
considering effective (i.e., strictly mechanical) procedures instead of programs. However,
formalizing the generalizations requires that the intuitive notion of effective procedure be
formalized. In any case, under such intuitively understood generalizations a problem is
said to be <I>partially solvable</I>, <I>solvable</I>, <I>partially decidable</I>, and <I>decidable</I> if it can be
partially solved, solved, partially decided, and decided by an effective procedure,
respectively.
   <P >In what follows effective procedures will also be called <I>algorithms</I><A NAME="20004-21010"> </A>.
   <P ><STRONG>Example 1.4.5</STRONG> <A 
   NAME="20004-21011t1.4.5"> </A> 
The program P<SUB>1</SUB> of Example <A 
 HREF="#20004-21004t1.4.3">1.4.3</A> describes how the problem K<SUB>1</SUB> of Example <A 
 HREF="#20004-20004t1.4.1">1.4.1</A> can be
solved. The program P<SUB>2</SUB> of Example <A 
 HREF="#20004-21008t1.4.4">1.4.4</A> describes how the problem K<SUB>2</SUB> of Example <A 
 HREF="#20004-20008t1.4.2">1.4.2</A>
can be solved. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >A problem is said to be <I>unsolvable</I> if no algorithm can solve it. The problem is said to
be <I>undecidable</I> if it is a decision problem and no algorithm can decide it. The relationship
between the different classes of problems is illustrated in the Venn diagram of
Figure <A 
 HREF="#20004-21012r1.4.2">1.4.2</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="20004-21012r1.4.2"> </A>
<A 
   NAME="20004-21012r1.4.2"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-one-1-4-2.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 1.4.2 </STRONG></NOBR></TD><TD  
>Classification of the set of problems.                                                                           </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >It should be noted that an unsolvable problem might be partially solvable by an
algorithm that makes an exhaustive search for a solution. In such a case the solution is
eventually found whenever it is defined, but the search might continue forever whenever
the solution is undefined. Similarly, an undecidable problem might also be partially
decidable by an algorithm that makes an exhaustive search. However, here the solution is
eventually found whenever it has the value yes, but the search might continue forever
whenever it has the value no.<A NAME="20004-21013"> </A>
   <P ><STRONG>Example 1.4.6</STRONG> <A 
   NAME="20004-21014t1.4.6"> </A> 
The empty-word membership problem<A NAME="20004-21015"> </A> for grammars is the problem consisting of the
following domain and question.
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ G | G is a grammar }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Is the empty word <FONT FACE="SYMBOL">e</FONT> in L(G) for the given grammar G?</DL>
It is possible to show that the problem is undecidable (e.g., see Theorem <A 
 HREF="theory-bk-fourse6.html#50006-21007t4.6.2">4.6.2</A> and
Exercise <A 
 HREF="theory-bk-fourli1.html#50008-25066r4.5.7">4.5.7</A>). On the other hand, the problem is partially decidable because given an
instance G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt; one can exhaustively search for a derivation of the form
S = <FONT FACE="SYMBOL">g</FONT><SUB>0</SUB> <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">g</FONT><SUB>1</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">g</FONT><SUB>n-1</SUB> <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">g</FONT><SUB>n</SUB> = <FONT FACE="SYMBOL">e</FONT>, by considering all derivations of length n
for n = 1, 2, <FONT FACE="SYMBOL">¼</FONT>  With such an algorithm the desired derivation will eventually be
found if <FONT FACE="SYMBOL">e</FONT> is in L(G). However, if <FONT FACE="SYMBOL">e</FONT> is not in L(G), then the search might never
terminate.
   <P >For the grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt;, whose production rules are listed below, the
algorithm will proceed in the following manner.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-one50x.gif" ALT="   S  ®   aBS
     ®   Ba
 aB  ®   SB
BS   ®   e"></PRE></CENTER>
   <P >The algorithm will start by determining the set of all the derivations
<FONT FACE="SYMBOL">Y</FONT><SUB>1</SUB> = {S <FONT FACE="SYMBOL">Þ</FONT> aBS, S <FONT FACE="SYMBOL">Þ</FONT> Ba} of length n = 1. After determining that none of the derivations
in <FONT FACE="SYMBOL">Y</FONT><SUB>1</SUB> provides the empty string <FONT FACE="SYMBOL">e</FONT>, the algorithm determines the set of all the derivations
<FONT FACE="SYMBOL">Y</FONT><SUB>2</SUB> = {S <FONT FACE="SYMBOL">Þ</FONT> aBS <FONT FACE="SYMBOL">Þ</FONT> aBaBS, S <FONT FACE="SYMBOL">Þ</FONT> aBS <FONT FACE="SYMBOL">Þ</FONT> aBBa, S <FONT FACE="SYMBOL">Þ</FONT> aBS <FONT FACE="SYMBOL">Þ</FONT> SBS, S <FONT FACE="SYMBOL">Þ</FONT> aBS, S <FONT FACE="SYMBOL">Þ</FONT> a}
of length n = 2. Then the algorithm continues by determining the set <FONT FACE="SYMBOL">Y</FONT><SUB>3</SUB> of all the
derivations of length 3, the set <FONT FACE="SYMBOL">Y</FONT><SUB>4</SUB> of all the derivations of length 4, and so forth. The
algorithm stops (with the answer yes) when, and only when, it finds a set <FONT FACE="SYMBOL">Y</FONT><SUB>n</SUB> of
derivations of length n that includes a derivation for <FONT FACE="SYMBOL">e</FONT>. Such a set <FONT FACE="SYMBOL">Y</FONT><SUB>n</SUB> exists for n = 5
because of the derivation S <FONT FACE="SYMBOL">Þ</FONT> aBS <FONT FACE="SYMBOL">Þ</FONT> SBS <FONT FACE="SYMBOL">Þ</FONT> BaBS <FONT FACE="SYMBOL">Þ</FONT> BSBS <FONT FACE="SYMBOL">Þ</FONT> BS <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">e</FONT>.
   <P >On the other hand, for the grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt;, whose production rules are
listed below, the algorithm never stops.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-one51x.gif" ALT="  S  ®   aSb
    ®   aAb
A   ®   e"></PRE></CENTER>
   <P >                                                                                              <IMG 
SRC="theory-bk-one52x.gif" ALT="PICT" >
   <P >
   <P >The unsolvability of a problem does not mean that a solution cannot be found at some
of its instances. It just means that no algorithm can uniformly find a solution for every
given instance. Consequently, an unsolvable problem might have simplified versions that
are solvable. The simplifications can be in the question being asked and in the domain
being considered.
   <P ><STRONG>Example 1.4.7</STRONG> <A 
   NAME="20004-21016t1.4.7"> </A> 
The empty-word<A NAME="20004-21017"> </A> membership problem for Type 1 grammars is the problem consisting of
the following domain and question.
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ G | G is a Type 1 grammar }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Is the empty word <FONT FACE="SYMBOL">e</FONT> in L(G) for the given grammar G?</DL>
The problem is decidable because <FONT FACE="SYMBOL">e</FONT> is in L(G) for a given Type 1 grammar
G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt; if and only if S <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> is a production rule of G. <A NAME="20004-21018"> </A><IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >A function f is said to be <I>computable</I><A NAME="20004-21019"> </A> (respectively, <I>partially<A NAME="20004-21020"> </A> computable</I>,
<I>noncomputable</I><A NAME="20004-21021"> </A>) if the problem defined by the following domain and question is solvable
(respectively, partially solvable, unsolvable).
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>The domain of f.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>What is the value of f(x) at the given instance x?</DL>
   <P ><EM><A 
   NAME="20004-22000"> </A><A 
 HREF="#Q2-20004-22"  NAME="Q1-20004-22">Problems concerning Programs</A></EM>
   <P >Although programs are written to solve problems, there are also interesting problems
that are concerned with programs. The following are some examples of such decision
problems.
<DL><DT><STRONG>
 </STRONG><DD 
>Uniform halting problem for programs<A NAME="20004-22001"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>Set of all programs.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Does the given program halt on each of its inputs, that is, are all the
      computations of the program halting computations?</DL>
<DT><STRONG>
 </STRONG><DD 
>Halting problem for programs<A NAME="20004-22002"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ (P, x) | P is a program and x is an input for P }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>For  the  given  instance  (P, x)  does  P halt  on  x,  that  is,  are  all  the
      computations of P on input x halting computations? </DL>
<DT><STRONG>
 </STRONG><DD 
>Recognition / acceptance problem for programs<A NAME="20004-22003"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ (P, x) | P is a program and x is an input for P }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>For the given instance (P, x) does P accept x? </DL>
<DT><STRONG>
 </STRONG><DD 
>Membership problem for programs<A NAME="20004-22004"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ (P, x, y) | P is a program, and x and y are sequences of values from
      the domain of the variables of P }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Is (x, y) in the relation R(P) for the given instance (P, x, y), that is,
      does P have an accepting computation on x with output y?</DL>
<DT><STRONG>
 </STRONG><DD 
>Emptiness problem for programs<A NAME="20004-22005"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>Set of all programs.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Does the given program accept an empty language, that is, does the
      program accept no input?</DL>
<DT><STRONG>
 </STRONG><DD 
>Ambiguity problem for programs<A NAME="20004-22006"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>Set of all programs.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Does the given program have two or more accepting computations that
      define the same output for some input?</DL>
<DT><STRONG>
 </STRONG><DD 
>Single-valuedness problem for programs<A NAME="20004-22007"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>Set of all programs.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Does  the  given  program  define  a  function,  that  is,  does  the  given
      program for each input have at most one output?</DL>
<DT><STRONG>
 </STRONG><DD 
>Equivalence problem for programs<A NAME="20004-22008"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ (P<SUB>1</SUB>, P<SUB>2</SUB>) | P<SUB>1</SUB> and P<SUB>2</SUB> are programs }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Does the given pair (P<SUB>1</SUB>, P<SUB>2</SUB>) of programs define the same relation, that
      is, does R(P<SUB>1</SUB>) = R(P<SUB>2</SUB>)? </DL>
</DL>
   <P >
<STRONG>Example 1.4.8</STRONG> <A 
   NAME="20004-22009t1.4.8"> </A> 
The two programs P<SUB>1</SUB> and P of Example <A 
 HREF="#20004-21004t1.4.3">1.4.3</A> are equivalent, but only P<SUB>2</SUB> halts on all
inputs. <IMG 
SRC="theory-bk-one0x.gif" ALT=" *** " 
 >
   <P >
   <P >The nonuniform halting problem, the unambiguity problem, the inequivalence<A NAME="20004-22010"> </A>
problem, and so forth are defined similarly for programs as the uniform halting problem,
the ambiguity problem, the equivalence problem, and so forth, respectively. The only
difference is that the questions are phrased so that the solutions to the new problems are
the complementation of the old ones, that is, yes becomes no and no becomes
yes.
   <P >It turns out that nontrivial questions about programs are difficult, if not impossible, to
answer. It is natural to expect these problems to become easier when the programs under
consideration are &#34;appropriately&#34; restricted. The extent to which the programs have to be
restricted, as well as the loss in their expressibility power, and the increase in the
resources they require due to such restrictions, are interesting questions on their
own.
   <P ><EM><A 
   NAME="20004-23000"> </A><A 
 HREF="#Q2-20004-23"  NAME="Q1-20004-23">Problems concerning Grammars</A></EM>
   <P >Some of the problems concerned with programs can in a similar way be defined also
for grammars. The following are some examples of such problems.
<DL><DT><STRONG>
 </STRONG><DD 
>Membership problem for grammars<A NAME="20004-23001"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ (G, x) | G is a grammar &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt; and x is a string in <FONT FACE="SYMBOL">S</FONT>* }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Is x in L(G) for the given instance (G, x)?</DL>
<DT><STRONG>
 </STRONG><DD 
>Emptiness problem for grammars<A NAME="20004-23002"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ G | G is a grammar }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Does the given grammar define an empty language?</DL>
<DT><STRONG>
 </STRONG><DD 
>Ambiguity problem for grammars<A NAME="20004-23003"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ G | G is a grammar }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Does  the  given  grammar  G  have  two  or  more  different  derivation
      graphs for some string in L(G)?</DL>
<DT><STRONG>
 </STRONG><DD 
>Equivalence problem for grammars, <A NAME="20004-23004"> </A>
      <DL><DT><STRONG>
  <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ (G<SUB>1</SUB>, G<SUB>2</SUB>) | G<SUB>1</SUB> and G<SUB>2</SUB> are grammars }.
      <DT><STRONG>
  <STRONG>Question:</STRONG> </STRONG><DD 
>Does the given pair of grammars generate the same language?</DL>
</DL>
   <P >
   <P >
   <P >[<A 
 HREF="theory-bk-onese5.html" >next</A>] [<A 
 HREF="theory-bk-onese3.html" >prev</A>] [<A 
 HREF="theory-bk-onese3.html#tailtheory-bk-onese3.html" >prev-tail</A>] [<A 
 HREF="theory-bk-onese4.html" >front</A>] [<A 
 HREF="theory-bk-one.html#theory-bk-onese4.html" >up</A>] <A 
   NAME="tailtheory-bk-onese4.html"> </A></BODY></HTML>