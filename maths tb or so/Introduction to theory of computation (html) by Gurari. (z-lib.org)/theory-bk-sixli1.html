
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-six.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-sixli2.html" >next</A>] [<A 
 HREF="theory-bk-sixse4.html" >prev</A>] [<A 
 HREF="theory-bk-sixse4.html#tailtheory-bk-sixse4.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-sixli1.html">tail</A>] [<A 
 HREF="theory-bk-six.html#theory-bk-sixli1.html" >up</A>]
<H3><A 
   NAME="70005-11000"> </A><A 
 HREF="theory-bk.html#Q2-70005-11"  NAME="Q1-70005-11">Exercises</A></H3>
<A 
   NAME="70005-11001r6.1"> </A><A 
   NAME="70005-11002r6.1.1"> </A>
     <DL><DT><STRONG>
6.1.1 </STRONG><DD 
> The recursive program in Figure <A 
 HREF="#70005-11005r6.E.1">6.E.1</A> sorts any given sequence A of natural
     numbers. The program requires time T(n) = T(m - 1) + T(n - m) + O(n)
     under the uniform cost criteria for some 1 <FONT FACE="SYMBOL">£</FONT> m <FONT FACE="SYMBOL">£</FONT> n. The recurrence equation
     in T(n) implies that T(n) <FONT FACE="SYMBOL">£</FONT> O(n<SUP>2</SUP>). That is, the program is of O(n<SUP>2</SUP>) time
     complexity.
     <P >Find a probabilistic variation of the program that has O(n log n) expected time
     complexity.
     <P ><I>Hint</I>:  A proof by induction can be used to show that T(n) = O(n log n) if
     T(n) <FONT FACE="SYMBOL">£</FONT> cn + 2/n <FONT FACE="SYMBOL">å</FONT>
    <SUB> i=0</SUB><SUP>n-1</SUP> T(i).
     <HR><CENTER><TABLE><TR><TD ><A 
   NAME="70005-11005r6.E.1"> </A>
             <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>call</B> <TT>QuickSort</TT>(A)<A NAME="70005-11004"> </A>
<B>procedure</B> <TT>QuickSort</TT>(<TT>A</TT>)
   <B>if</B> <TT>A</TT> has cardinality 1 <B>then</B> <B>return</B>
    <TT>A</TT><SUB>1</SUB> := elements in <TT>A</TT> that are smaller than <TT>A</TT>(1)
   <TT>A</TT><SUB>2</SUB> := elements in <TT>A</TT> that are greater than <TT>A</TT>(1)
   <B>call</B> QuickSort(<TT>A</TT><SUB>1</SUB>)
   <B>call</B> QuickSort(<TT>A</TT><SUB>2</SUB>)
   <TT>A</TT> := concatenation of (<TT>A</TT><SUB>1</SUB>, <TT>A</TT> - <TT>A</TT><SUB>1</SUB> - <TT>A</TT><SUB>2</SUB>, <TT>A</TT><SUB>2</SUB>)
   <B>return</B>
<B>end</B>                                                                           </PRE></TD></TR></TABLE>
<A 
   NAME="70005-11005r6.E.1"> </A>
                          <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 6.E.1  </STRONG></NOBR></TD><TD  
></TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR><A 
   NAME="70005-11006r6.2"> </A><A 
   NAME="70005-11007r6.2.1"> </A>
     <DT><STRONG>
6.2.1 </STRONG><DD 
>Let K be the problem in Example <A 
 HREF="theory-bk-sixse2.html#70002-3012t6.2.2">6.2.2</A> of deciding the inequality AB<IMG 
SRC="theory-bk-six176x.gif" ALT="/="ALIGN="MIDDLE" > C for
     matrices. Consider the following algorithm.
         <DL><DT><STRONG>
      <STRONG>Step 1</STRONG> </STRONG><DD 
>Randomly choose an entry (i, j) in matrix C for the given instance
         (A, B, C) of K, and let d<SUB>1</SUB> denote the element at this entry.
         <DT><STRONG>
      <STRONG>Step 2</STRONG> </STRONG><DD 
>Use the <I>i</I>th row of A and the <I>j</I>th column of B to compute the value
         d<SUB>2</SUB> at entry (i, j) of AB.
         <DT><STRONG>
      <STRONG>Step 3</STRONG> </STRONG><DD 
>Declare that the inequality AB<IMG 
SRC="theory-bk-six177x.gif" ALT="/="ALIGN="MIDDLE" > C holds if d<SUB>1</SUB><IMG 
SRC="theory-bk-six178x.gif" ALT="/="ALIGN="MIDDLE" >  d<SUB>2</SUB>. Otherwise,
         declare that AB = C.</DL>
     What are the time complexity and the error probability of the algorithm?
<A 
   NAME="70005-11008r6.2.2"> </A>
     <DT><STRONG>
6.2.2 </STRONG><DD 
> A univariate polynomial s(x) in variable x of degree N has the form
     a<SUB>0</SUB>x<SUP>N </SUP> + a<SUB>1</SUB>x<SUP>N-1</SUP> + · · · + a<SUB>N-1</SUB>x + a<SUB>N </SUB>. A brute-force algorithm for deciding the
     equality p(x) · q(x) = t(x) takes O(N<SUP>2</SUP>) time under the uniform cost criteria, if
     p(x), q(x), and t(x) are univariate polynomials of degree N, at most, and the
     coefficients are natural numbers. Show that a probabilistic program can decide the
     problem in O(N) time, with an error probability smaller than some constant
     <FONT FACE="SYMBOL">e</FONT> &lt; 1/2.
     <P ><I>Hint</I>:  Note that a univariate polynomial s(x) of degree N has at most N roots, that
     is, N values x<SUB>0</SUB> such that s(x<SUB>0</SUB>) = 0. <A 
   NAME="70005-11009r6.2.3"> </A>
     <DT><STRONG>
6.2.3 </STRONG><DD 
> Let K be the problem defined by the following pair. (See page 83 for the definitions
     of polynomial expressions and Diophantine polynomials.)
          <DL><DT><STRONG>
       <STRONG>Domain:  </STRONG> </STRONG><DD 
>{ E(x<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, x<SUB>m</SUB>)  |  E(x<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, x<SUB>m</SUB>) is a polynomial expression with
          variables x<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , x<SUB>n</SUB> }.
          <DT><STRONG>
       <STRONG>Question:</STRONG> </STRONG><DD 
>Does the given instance represent a Diophantine polynomial that
          is identically equal to zero? </DL>
     Show that K is solvable
         <OL TYPE="a" 
>
         <LI><A 
   NAME="70005-11010xa"> </A>Deterministically in exponential time.
         <LI><A 
   NAME="70005-11011xb"> </A>Probabilistically in polynomial time.</OL>
     <I>Hint</I>:  Show that each Diophantine polynomial E(x<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, x<SUB>m</SUB>) of degree d that is
     not identically equal to 0 has at most N<SUP>m</SUP>/c roots (<IMG 
SRC="theory-bk-six179x.gif" ALT="^x"><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <IMG 
SRC="theory-bk-six180x.gif" ALT="^x"><SUB>m</SUB>) that satisfy
     1 <FONT FACE="SYMBOL">£</FONT> <IMG 
SRC="theory-bk-six181x.gif" ALT="^x"><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <IMG 
SRC="theory-bk-six182x.gif" ALT="^x"><SUB>m</SUB> <FONT FACE="SYMBOL">£</FONT> N, if N <FONT FACE="SYMBOL">³</FONT> cd and c <FONT FACE="SYMBOL">³</FONT> 1.
<A 
   NAME="70005-11012r6.3"> </A><A 
   NAME="70005-11013r6.3.1"> </A>
     <DT><STRONG>
6.3.1 </STRONG><DD 
>Let M<SUB>1</SUB> be a probabilistic Turing machine with error probability e(x) &lt; 1/3. Find a
     probabilistic Turing machine M<SUB>2</SUB> that accepts L(M<SUB>1</SUB>) with error probability
     e(x) &lt; 7/27.
<A 
   NAME="70005-11014r6.3.2"> </A>
     <DT><STRONG>
6.3.2 </STRONG><DD 
>Show that an error-bounded probabilistic<A NAME="70005-11015"> </A> pushdown automaton can accept the
     language { a<SUP>i</SUP>b<SUP>i</SUP>c<SUP>i</SUP> | i <FONT FACE="SYMBOL">³</FONT> 0 }. <A 
   NAME="70005-11016r6.3.3"> </A>
     <DT><STRONG>
6.3.3 </STRONG><DD 
>
         <OL TYPE="a" 
>
         <LI><A 
   NAME="70005-11017xa"> </A>Show that if (v<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, v<SUB>m</SUB>) is a nonzero vector of integers and d<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , d<SUB>m</SUB> are
         chosen  randomly  from  {1,<FONT FACE="SYMBOL"> ¼</FONT>, r} then d<SUB>1</SUB>v<SUB>1</SUB> + · · · + d<SUB>m</SUB>v<SUB>m</SUB>   =   0 with
         probability no greater than 1/r.
         <LI><A 
   NAME="70005-11018xb"> </A>Show  that  L = { a<SUP>1</SUP>b<SUP>m</SUP>a<SUP>2</SUP>b<SUP>m-1</SUP> · · · a<SUP>m</SUP>b<SUP>1</SUP>  |  m  <FONT FACE="SYMBOL">³</FONT>  0 } is accepted by a
         bounded-error probabilistic pushdown<A NAME="70005-11019"> </A> automaton.
         <P ><I>Hint</I>:  Use part (a) of the problem to check that the inputs have the form
         a<SUP>i<SUB>1</SUB></SUP>b<SUP>j<SUB>1</SUB></SUP>a<SUP>i<SUB>2</SUB></SUP>b<SUP>j<SUB>2</SUB></SUP> · · · a<SUP>i<SUB>m</SUB></SUP>b<SUP>j<SUB>m</SUB></SUP>  with  i<SUB>2</SUB> - i<SUB>1</SUB> - 1 = 0, i<SUB>3</SUB> - i<SUB>2</SUB> - 1 = 0, <FONT FACE="SYMBOL">¼</FONT>   and
          j<SUB>1</SUB> - j<SUB>2</SUB> - 1 = 0, j<SUB>2</SUB> - j<SUB>3</SUB> - 1 = 0, <FONT FACE="SYMBOL">¼</FONT></OL>
<A 
   NAME="70005-11020r6.3.4"> </A>
     <DT><STRONG>
6.3.4 </STRONG><DD 
>Show that a language accepted by an n-states, nondeterministic finite-state
     automaton M<SUB>1</SUB> is also accepted by an (n + d)-states, bounded-error, two-way,
     probabilistic finite-state automaton M<SUB>2</SUB>, that is, an (n + d)-states, bounded-error, 0
     auxiliary-work-tape, probabilistic Turing machine M<SUB>2</SUB>. d is assumed to be a constant
     independent of M<SUB>1</SUB>.
     <P ><I>Hint</I>:  Allow M<SUB>2</SUB> to halt in a rejecting configuration with probability (1/2)<SUP>n</SUP> and to
     start a new simulation of M<SUB>1</SUB> with probability 1 - (1/2)<SUP>n</SUP>, after simulating a
     nonaccepting computation of M<SUB>1</SUB>. <A 
   NAME="70005-11021r6.4"> </A><A 
   NAME="70005-11022r6.4.1"> </A>
     <DT><STRONG>
6.4.1 </STRONG><DD 
> Show that <I>ZPP</I><A NAME="70005-11023"> </A> and <I>BPP</I><A NAME="70005-11024"> </A> are each closed under union.<A NAME="70005-11025"> </A> <A 
   NAME="70005-11026r6.4.2"> </A>
     <DT><STRONG>
6.4.2 </STRONG><DD 
> Show that each function computable by a bounded-error probabilistic Turing
     transducer with polynomially time-bounded complexity, is also computable by a
     polynomially space-bounded, deterministic Turing transducer.</DL>
   <P >
   <P >[<A 
 HREF="theory-bk-sixli2.html" >next</A>] [<A 
 HREF="theory-bk-sixse4.html" >prev</A>] [<A 
 HREF="theory-bk-sixse4.html#tailtheory-bk-sixse4.html" >prev-tail</A>] [<A 
 HREF="theory-bk-sixli1.html" >front</A>] [<A 
 HREF="theory-bk-six.html#theory-bk-sixli1.html" >up</A>] <A 
   NAME="tailtheory-bk-sixli1.html"> </A></BODY></HTML>