
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-four.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-fourse5.html" >next</A>] [<A 
 HREF="theory-bk-fourse3.html" >prev</A>] [<A 
 HREF="theory-bk-fourse3.html#tailtheory-bk-fourse3.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-fourse4.html">tail</A>] [<A 
 HREF="theory-bk-four.html#theory-bk-fourse4.html" >up</A>]
<H3>4.4 <A 
   NAME="50004-150004.4"> </A><A 
 HREF="theory-bk.html#Q2-50004-15"  NAME="Q1-50004-15">Universal Turing Transducers</A></H3>
   <P >
      <A 
 HREF="#Q1-50004-16"  NAME="Q2-50004-16">A Representation for Turing Transducers</A>
<BR>         <A 
 HREF="#Q1-50004-17"  NAME="Q2-50004-17">A Universal Turing Transducer</A>
   <P >Programs are written to instruct computing machines on how to solve given
problems. A program P is considered to be executable by a computing machine A if
A can, when given P and any x for P, simulate any computation of P on input
x.
   <P >In many cases, a single computing machine can execute more than one program, and
thus can be programmed to compute different functions. However, it is not clear from the
previous discussion just how general a computing machine can be. Theorem <A 
 HREF="#50004-17001t4.4.1">4.4.1</A> below,
together with Church's thesis, imply that there are machines that can be programmed to
compute any computable function. One such example is the computing machine D, which
consists of a &#34;universal&#34; Turing transducer U and of a translator T, which have the
following characteristics (see Figure <A 
 HREF="#50004-15001r4.4.1">4.4.1</A>).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50004-15001r4.4.1"> </A>
<A 
   NAME="50004-15001r4.4.1"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-four-4-4-1.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.4.1 </STRONG></NOBR></TD><TD  
>A programmable computing machine D.                                                                    </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>
   <P >U is a deterministic Turing transducer that can execute any given deterministic Turing
transducer M. That is, U on any given (M, x) simulates the computation of M on input x
(see the proof of Theorem <A 
 HREF="#50004-17001t4.4.1">4.4.1</A>).
   <P >T is a deterministic Turing transducer whose inputs are pairs (P, x) of programs P
written in some fixed programming language, and inputs x for P. T on a given input (P, x)
outputs x together with a deterministic Turing transducer M that is equivalent to P. In
particular, if P is a deterministic Turing transducer (i.e., a program written in the
&#34;machine&#34; language), then T is a trivial translator that just outputs its input. On the other
hand, if P is a program written in a higher level programming language, then T is
a compiler that provides a deterministic Turing transducer M for simulating
P.
   <P >When given an input (P, x), the computing machine D provides the pair to T, and then
it feeds the output (M, x) of T to U, to obtain the desired output of P on input
x.
   <P ><STRONG>Definitions </STRONG> <A 
   NAME="50004-15002t4.4"> </A> 
A <I>universal<A NAME="50004-15003"> </A> Turing transducer</I> U is a deterministic Turing transducer that on any given
pair (M, x), of a deterministic Turing transducer M and of an input x for M, simulates the
behavior of M on x. Inputs that do not have the form (M, x) are rejected by U. <I>Universal
Turing machines</I> are defined similarly.
   <P >It should be noted that a pair (M, x) is presented to a universal Turing transducer in
encoded form, and that the output of the universal Turing transducer is the encoding of the
output of M on input x. For convenience, the mentioning of the encoding is omitted when
no confusion arises. Moreover, unless otherwise stated, a &#34;standard&#34; binary representation
is implicitly assumed for the encodings.
   <P ><EM><A 
   NAME="50004-16000"> </A><A 
 HREF="#Q2-50004-16"  NAME="Q1-50004-16">A Representation for Turing Transducers</A></EM>
   <P >In what follows, a string is said to be a <I>standard<A NAME="50004-16001"> </A> binary representation</I> of a Turing
transducer M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">G</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, B, F&gt; if it is equal to E(M), where E is defined
recursively in the following way.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="50004-16002xa"> </A>E(M) = E(F)01E(<FONT FACE="SYMBOL">d</FONT>).
     <LI><A 
   NAME="50004-16003xb"> </A>E(F) = E(p<SUB>1</SUB>) · · · E(p<SUB>k</SUB>) for some ordering {p<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, p<SUB>k</SUB>} of the states of F.
     <LI><A 
   NAME="50004-16004xc"> </A>E(B) = 0 is the binary representation of the blank symbol.
     <LI><A 
   NAME="50004-16005xd"> </A>E(<FONT FACE="SYMBOL">d</FONT>) = E(<FONT FACE="SYMBOL">t</FONT><SUB>1</SUB>)01E(<FONT FACE="SYMBOL">t</FONT><SUB>2</SUB>)01 · · · 01E(<FONT FACE="SYMBOL">t</FONT><SUB>r</SUB>)01 for some ordering {<FONT FACE="SYMBOL">t</FONT><SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, <FONT FACE="SYMBOL">t</FONT><SUB>r</SUB>} of the
     transition rules of <FONT FACE="SYMBOL">d</FONT>.
     <LI><A 
   NAME="50004-16006xe"> </A>E(<FONT FACE="SYMBOL">t</FONT>)     =     E(q)E(a)E(b<SUB>1</SUB>) · · · E(b<SUB>m</SUB>)E(p)E(d<SUB>0</SUB>)E(c<SUB>1</SUB>)E(d<SUB>1</SUB>) · · · E(c<SUB>m</SUB>)
     E(d<SUB>m</SUB>)E(<FONT FACE="SYMBOL">r</FONT>) for each <FONT FACE="SYMBOL">t</FONT> = (q, a, b<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, b<SUB>m</SUB>, p, d<SUB>0</SUB>, c<SUB>1</SUB>, d<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, c<SUB>m</SUB>, d<SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT>) in <FONT FACE="SYMBOL">d</FONT>.
     <LI><A 
   NAME="50004-16007xf"> </A>E(d) = 011 for d = -1, E(d) = 0111 for d = 0, E(d) = 01111 for d = +1,
     and E(<FONT FACE="SYMBOL">r</FONT>) = 0 for an output <FONT FACE="SYMBOL">r</FONT> = <FONT FACE="SYMBOL">e</FONT>.
     <LI><A 
   NAME="50004-16008xg"> </A>E(q<SUB>i</SUB>) = 01<SUP>i+2</SUP> for each state q<SUB>i</SUB> in Q, and some ordering q<SUB>0</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, q<SUB>s</SUB> of the states
     of Q. Note that the order assumes the initial state q<SUB>0</SUB> to be the first.
     <LI><A 
   NAME="50004-16009xh"> </A>E(e<SUB>i</SUB>) = 01<SUP>i+1</SUP> for each symbol e<SUB>i</SUB> in (<FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">G</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">D</FONT> <FONT FACE="SYMBOL">È</FONT> {¢, $}) - {B} and some
     order {e<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, e<SUB>t</SUB>} in which e<SUB>1</SUB> = ¢ and e<SUB>2</SUB> = $.
     </OL>
   <P >
Intuitively, we see that E provides a binary representation for the symbols in the
alphabets of the Turing transducer, a binary representation for the states of the Turing
transducer, and a binary representation for the possible heads movements. Then it
provides a representation for a sequence of such entities, by concatenating the
representations of the entities. The string 01 is used as separator for avoiding
ambiguity.
   <P >By definition, a given Turing transducer can have some finite number of standard
binary representations. Each of these representations depends on the order chosen for the
states in Q, the order chosen for the symbols in (<FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">G</FONT> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">D</FONT> <FONT FACE="SYMBOL">È</FONT> {¢, $}) - {B}, the order
chosen for the states in F, and the order chosen for the transition rules in <FONT FACE="SYMBOL">d</FONT>. On the other
hand, different Turing transducers can have identical standard binary representations if
they are <I>isomorphic</I>, that is, if they are equal except for the names of their states and the
symbols in their alphabets.
   <P ><STRONG>Example 4.4.1</STRONG> <A 
   NAME="50004-16010t4.4.1"> </A> 
If M is the Turing transducer whose transition diagram is given in Figure <A 
 HREF="theory-bk-fourse1.html#50001-3025r4.1.3">4.1.3</A>, then
E(M) can be the standard binary representation
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-four19x.gif" ALT="   E(q4)01E(q0,a,B, q1,+1, a,+1, a)01 ··· 01E(q3,$,B,q4,0,B,0,e)01 =
E(q4)01E(q0)E(a)E(B)E(q1) ···E(q3)E($)E(B)E(q4)E(0)E(B)E(0)E(e)01"></PRE></CENTER>
   <P >where E(q<SUB>0</SUB>) = 011, E(q<SUB>1</SUB>) = 0111, E(q<SUB>2</SUB>) = 01111, E(q<SUB>3</SUB>) = 011111,
E(q<SUB>4</SUB>) = 0111111, E(B) = 0, E(¢) = 011, E($) = 0111, E(a) = 01111, <FONT FACE="SYMBOL">¼</FONT>
   <P >0 and 00 are examples of binary strings that are not standard binary representations of
any Turing transducer.
   <P >The string
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-four20x.gif" ALT="      4    2  4  2  4  4  4 6    2  5   3 3
a = 01 0101 01 001 021 01301401041013 014 002101 03 3  4  4   3
               01 0010101 01 01 01001 00101 01001 01 001 001"></PRE></CENTER>
   <P >represents a Turing transducer with one accepting state and four transition rules. Only
the first transition rule has a nonempty output. The Turing transducer has one auxiliary
work tape. <IMG 
SRC="theory-bk-four0x.gif" ALT=" *** " 
 >
   <P >
   <P >E(M)01E(¢x$) is assumed to be the standard binary representation of (M, x), with
E(¢x$) = E(¢)E(a<SUB>1</SUB>) · · · E(a<SUB>n</SUB>)E($) when x = a<SUB>1</SUB> · · · a<SUB>n</SUB>.<A NAME="50004-16011"> </A>
   <P ><EM><A 
   NAME="50004-17000"> </A><A 
 HREF="#Q2-50004-17"  NAME="Q1-50004-17">A Universal Turing Transducer</A></EM>
   <P >The proof of the following result provides an example of a universal Turing
transducer.
   <P ><STRONG>Theorem 4.4.1</STRONG> <A 
   NAME="50004-17001t4.4.1"> </A> 
There exists a universal Turing transducer U.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="50004-17002t"> </A> 
U can be a two auxiliary-work-tape Turing transducer similar to M<SUB>2</SUB> in the proof of
Proposition <A 
 HREF="theory-bk-fourse3.html#50003-14001t4.3.1">4.3.1</A>. Specifically, U starts each computation by checking that its input is a
pair (M, x) of some deterministic Turing transducer M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">G</FONT>, <FONT FACE="SYMBOL">D</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, B, F&gt; and
of some input x for M (given in standard binary representation). If the input is not of such
a form, then U halts in a nonaccepting configuration. However, if the input is of such a
form, U simulates a computation of M on x.
   <P >U, like M<SUB>2</SUB>, uses two auxiliary work tapes for keeping track of the content
of the auxiliary work tapes of M. However, U also uses the auxiliary work tapes for
keeping track of the states and the input head locations of M. Specifically, the universal
Turing transducer U records a configuration (uqv, u<SUB>1</SUB>qv<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, u<SUB>m</SUB>qv<SUB>m</SUB>, w) of M by storing
#E(q)#|u|#E(u<SUB>1</SUB>)#E(v<SUB>1</SUB>)# · · · #E(u<SUB>m</SUB>)#E(v<SUB>m</SUB>)# in an auxiliary work tape, and
storing E(w) in the output tape.
   <P >To determine the transition rule (q, a, b<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, b<SUB>m</SUB>, p, d<SUB>0</SUB>, c<SUB>1</SUB>, d<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, c<SUB>m</SUB>, d<SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT>) that M uses in
a simulated move, U extracts the state q and the symbols a, b<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , b<SUB>m</SUB>. U records the string
E(q)E(a)E(b<SUB>1</SUB>) · · · E(b<SUB>m</SUB>) in the auxiliary work tape that does not keep the configuration
of M that is in effect. Then U determines p, d<SUB>0</SUB>, c<SUB>1</SUB>, d<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , c<SUB>m</SUB>, d<SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT> by searching E(M) for
the substring that follows a substring of the form 01E(q)E(a)E(b<SUB>1</SUB>) · · · E(b<SUB>m</SUB>). <A NAME="50004-17003"> </A><IMG 
SRC="theory-bk-four0x.gif" ALT=" ***
" 
 >
   <P >
   <P >
   <P >[<A 
 HREF="theory-bk-fourse5.html" >next</A>] [<A 
 HREF="theory-bk-fourse3.html" >prev</A>] [<A 
 HREF="theory-bk-fourse3.html#tailtheory-bk-fourse3.html" >prev-tail</A>] [<A 
 HREF="theory-bk-fourse4.html" >front</A>] [<A 
 HREF="theory-bk-four.html#theory-bk-fourse4.html" >up</A>] <A 
   NAME="tailtheory-bk-fourse4.html"> </A></BODY></HTML>