<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-seven.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-sevense2.html" >next</A>] [<A 
 HREF="#tailtheory-bk-sevense1.html">tail</A>] [<A 
 HREF="theory-bk-seven.html#theory-bk-sevense1.html" >up</A>]
<H3>7.1 <A 
   NAME="80001-20007.1"> </A><A 
 HREF="theory-bk.html#Q2-80001-2"  NAME="Q1-80001-2">Parallel Programs</A></H3>
   <P >
<A NAME="80001-2001"> </A>
   <P >A parallel program <IMG 
SRC="theory-bk-seven0x.gif" ALT="^P"> is a system &lt;P, <TT>X</TT>, <TT>Y</TT>&gt; of infinitely many deterministic
sequential programs P<SUB>1</SUB>, P<SUB>2</SUB>, <FONT FACE="SYMBOL">¼</FONT> , infinitely many input variables <TT>X</TT>(1), <TT>X</TT>(2), <FONT FACE="SYMBOL">¼</FONT> , and
infinitely many output variables <TT>Y</TT>(1), <TT>Y</TT>(2), <FONT FACE="SYMBOL">¼</FONT>  The sequential programs P<SUB>1</SUB>, P<SUB>2</SUB>, <FONT FACE="SYMBOL">¼</FONT>
are assumed to be identical, except for the ability of each P<SUB>i</SUB> to refer to its own index i. That
is, for each pair of indices i and j the sequential program P<SUB>j</SUB> can be obtained from the
sequential program P<SUB>i</SUB> by replacing each reference to i in P<SUB>i</SUB> with a reference to
j.
   <P >At the start of a computation, the input of <IMG 
SRC="theory-bk-seven1x.gif" ALT="^P"> is stored in its input variables. An input
that consists of N values is stored in <TT>X</TT>(1), <FONT FACE="SYMBOL">¼</FONT> , <TT>X</TT>(N), where each of the variables holds one
of the input values. During the computation, <IMG 
SRC="theory-bk-seven2x.gif" ALT="^P"> employs P<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , P<SUB>m</SUB> for some m dependent on
the input. Each P<SUB>i</SUB> is assumed to know the value of N and the value of m. Upon halting,
the output of <IMG 
SRC="theory-bk-seven3x.gif" ALT="^P"> is assumed to be in its output variables. An output that consists of K values
is assumed to be in <TT>Y</TT>(1), <FONT FACE="SYMBOL">¼</FONT> , <TT>Y</TT>(K), where each of the variables holds one output
value.
   <P >Each step in a computation of <IMG 
SRC="theory-bk-seven4x.gif" ALT="^P"> consists of four phases as follows.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="80001-2002xa"> </A>Each P<SUB>i</SUB> reads an input value from one of the input variables <TT>X</TT>(1), <FONT FACE="SYMBOL">¼</FONT> , <TT>X</TT>(N).
     <LI><A 
   NAME="80001-2003xb"> </A>Each P<SUB>i</SUB> performs some internal computation.
     <LI><A 
   NAME="80001-2004xc"> </A>Each P<SUB>i</SUB> may write into one of the output variables <TT>Y</TT>(1), <TT>Y</TT>(2), <FONT FACE="SYMBOL">¼</FONT>
     <LI><A 
   NAME="80001-2005xd"> </A>P<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , P<SUB>m</SUB> communicate any desirable information among themselves.</OL>
Each of the phases is synchronized to be carried in parallel by all the sequential programs
P<SUB>
1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , P<SUB>m</SUB>.
   <P >Although two or more sequential programs may read simultaneously from the same
input variable, at no step may they write into the same output variable.
   <P >The <I>depth<A NAME="80001-2006"> </A> of a computation</I> of a parallel program <IMG 
SRC="theory-bk-seven5x.gif" ALT="^P"> = &lt;P, <TT>X</TT>, <TT>Y</TT>&gt; is the number of
steps executed during the computation. The parallel program is said to have <I>depth<A NAME="80001-2007"> </A>
complexity</I> D(N) if for each N all its computations, over the inputs that consist of N
values, have at most depth D(N). The parallel program <IMG 
SRC="theory-bk-seven6x.gif" ALT="^P"> is said to have <I>size<A NAME="80001-2008"> </A> complexity</I>
Z(N) if it employs no sequential programs other than P<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , P<SUB>Z(N)</SUB> on each input that
consists of N values.
   <P >The time required by a computation of a parallel program and that program's time
complexity can be defined in a similar way. However, such notions are unmeasurable here
because we have not yet specified how sequential programs communicate.
   <P ><STRONG>Example 7.1.1</STRONG> <A 
   NAME="80001-2009t7.1.1"> </A> 
Consider the problem Q of selecting the smallest value in a given set S. Restrict your
attention to parallel programs that in each step allow each sequential program to receive
information from no more than one sequential program.
   <P >The problem is solvable by a parallel program <IMG 
SRC="theory-bk-seven7x.gif" ALT="^P"><SUB>1</SUB> = &lt;P, <TT>X</TT>, <TT>Y</TT>&gt; of size complexity
Z(N) <FONT FACE="SYMBOL">³</FONT> N(N - 1)/2 and a constant depth complexity, where N denotes the cardinality
of the given set S. The parallel program can use a brute-force approach for such a
purpose.
   <P >Specifically, let each pair (i<SUB>1</SUB>, i<SUB>2</SUB>), such that 1 <FONT FACE="SYMBOL">£</FONT> i<SUB>1</SUB> &lt; i<SUB>2</SUB> <FONT FACE="SYMBOL">£</FONT> N, correspond to a
different i, such that 1 <FONT FACE="SYMBOL">£</FONT> i <FONT FACE="SYMBOL">£</FONT> N(N - 1)/2. For instance, the correspondence can be
of the form i = 1 + 2 + · · · + (i<SUB>2</SUB> - 2) + i<SUB>1</SUB> = (i<SUB>2</SUB> - 2)(i<SUB>2</SUB> - 1)/2 + i<SUB>1</SUB> (see
Figure <A 
 HREF="#80001-2010r7.1.1">7.1.1</A>).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="80001-2010r7.1.1"> </A>
<A 
   NAME="80001-2010r7.1.1"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-seven-7-1-1.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 7.1.1 </STRONG></NOBR></TD><TD  
>An ordering i on the pairs (i<SUB>1</SUB>, i<SUB>2</SUB>), such that 1 <FONT FACE="SYMBOL">£</FONT> i<SUB>1</SUB> &lt; i<SUB>2</SUB>.                                           </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Let P<SUB>(i<SUB>1</SUB>,i<SUB>2</SUB>)</SUB> denote the sequential program P<SUB>i</SUB>, where (i<SUB>1</SUB>, i<SUB>2</SUB>) is the pair that corresponds to
i.
   <P >Each computation of <IMG 
SRC="theory-bk-seven8x.gif" ALT="P^"> starts with a step in which each P<SUB>i</SUB> derives the pair (i<SUB>1</SUB>, i<SUB>2</SUB>) that
corresponds to i, 1 <FONT FACE="SYMBOL">£</FONT> i <FONT FACE="SYMBOL">£</FONT> N(N - 1)/2. The computation continues with two steps in
which each P<SUB>(i<SUB>1</SUB>,i<SUB>2</SUB>)</SUB> reads the elements of S that are stored in <TT>X</TT>(i<SUB>1</SUB>) and <TT>X</TT>(i<SUB>2</SUB>). In
addition, in the third step each P<SUB>(i<SUB>1</SUB>,i<SUB>2</SUB>)</SUB> compares the values read from <TT>X</TT>(i<SUB>1</SUB>) and
<TT>X</TT>(i<SUB>2</SUB>), and communicates a &#34;negative&#34; outcome to P<SUB>i<SUB>1</SUB></SUB> or P<SUB>i<SUB>2</SUB></SUB>. This outcome is
communicated to P<SUB>i<SUB>1</SUB></SUB> if  <TT>X</TT>(i<SUB>1</SUB>) <FONT FACE="SYMBOL">³</FONT> <TT>X</TT>(i<SUB>2</SUB>). Otherwise, the outcome is communicated to P<SUB>i<SUB>2</SUB></SUB>.
During the fourth step, the only active sequential program is P<SUB>j</SUB>, 1 <FONT FACE="SYMBOL">£</FONT> j <FONT FACE="SYMBOL">£</FONT> N,
which did not receive a negative outcome. During that step P<SUB>j</SUB> reads the value of
<TT>X</TT>(j) and writes it out into <TT>Y</TT>(1). The computation terminates after the fourth
step.
   <P >The problem Q can be solved also by a parallel program <IMG 
SRC="theory-bk-seven9x.gif" ALT="P^"><SUB>2</SUB> = &lt;P, <TT>X</TT>, <TT>Y</TT>&gt; of size
complexity Z(N) = <FONT FACE="SYMBOL">é</FONT>N/2<FONT FACE="SYMBOL">ù</FONT> and depth complexity D(N) = O(log N). In this case the
program simply repeatedly eliminates about half of the elements from S, until S is left
with a single element.
   <P >At the first stage of each computation each P<SUB>i</SUB>, 1 <FONT FACE="SYMBOL">£</FONT> i <FONT FACE="SYMBOL">£</FONT> <FONT FACE="SYMBOL">é</FONT>N/2<FONT FACE="SYMBOL">ù</FONT>, reads the
values stored in <TT>X</TT>(2i - 1) and <TT>X</TT>(2i). In addition, each P<SUB>i</SUB> compares the values
that it read. If <TT>X</TT>(2i - 1) &lt; <TT>X</TT>(2i), then P<SUB>i</SUB> communicates to P<SUB><FONT FACE="SYMBOL">é</FONT>i/2<FONT FACE="SYMBOL">ù</FONT></SUB> the value of
<TT>X</TT>(2i - 1). Otherwise, P<SUB>i</SUB> communicates to P<SUB><FONT FACE="SYMBOL">é</FONT>i/2<FONT FACE="SYMBOL">ù</FONT></SUB> the value of <TT>X</TT>(2i). At the end of the
first stage P<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , P<SUB><FONT FACE="SYMBOL">é</FONT><FONT FACE="SYMBOL">é</FONT>n/2<FONT FACE="SYMBOL">ù</FONT>/2<FONT FACE="SYMBOL">ù</FONT></SUB> hold the elements of S that have not been eliminated
yet.
   <P >At the start of each consecutive stage of the computation, a sequential program P<SUB>i</SUB>
determines itself active if and only if it has been communicated some values of S in the
previous stage. During a given stage, each active P<SUB>i</SUB> compares the values a<SUB>1</SUB> and a<SUB>2</SUB> that
were communicated to it in the previous stage. If the values satisfy the relation
a<SUB>1</SUB> &lt; a<SUB>2</SUB>, then P<SUB>i</SUB> communicates a<SUB>1</SUB> to P<SUB><FONT FACE="SYMBOL">é</FONT>i/2<FONT FACE="SYMBOL">ù</FONT></SUB>. Otherwise, P<SUB>i</SUB> communicates a<SUB>2</SUB> to
P<SUB>
<FONT FACE="SYMBOL">é</FONT>i/2<FONT FACE="SYMBOL">ù</FONT></SUB>.
   <P >After O(log N) stages only P<SUB>1</SUB> is active, and it holds a single value of S. Then P<SUB>1</SUB>
writes the value into <TT>Y</TT>(1) and the computation terminates.
   <P >Figure <A 
 HREF="#80001-2011r7.1.2">7.1.2</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="80001-2011r7.1.2"> </A>
<A 
   NAME="80001-2011r7.1.2"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-seven-7-1-2.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 7.1.2 </STRONG></NOBR></TD><TD  
>Flow of information.                                                                                                    </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>illustrates the flow of information in <IMG 
SRC="theory-bk-seven10x.gif" ALT="^P"><SUB>2</SUB> during a computation of the parallel
program.
   <P >Similarly, the problem Q can be solved by a parallel program <IMG 
SRC="theory-bk-seven11x.gif" ALT="^
P"><SUB>3</SUB> = &lt;P, <TT>X</TT>, <TT>Y</TT>&gt; of size
complexity Z(N) &lt; <FONT FACE="SYMBOL">é</FONT>N/2<FONT FACE="SYMBOL">ù</FONT> and depth complexity O(N/Z(N) + log Z(N)). At the start
of each computation each P<SUB>i</SUB> computes m = Z(N) and finds independently in O(N/m)
steps the smallest value in <TT>X</TT>(<FONT FACE="SYMBOL">é</FONT><IMG 
SRC="theory-bk-seven12x.gif" ALT="N-
m"ALIGN="MIDDLE" ><FONT FACE="SYMBOL">ù</FONT>(i - 1) + 1), <FONT FACE="SYMBOL">¼</FONT> , <TT>X</TT>(<FONT FACE="SYMBOL">é</FONT><IMG 
SRC="theory-bk-seven13x.gif" ALT="N-
m"ALIGN="MIDDLE" ><FONT FACE="SYMBOL">ù</FONT>i). Then, as in the previous case of
<IMG 
SRC="theory-bk-seven14x.gif" ALT="^P"><SUB>
2</SUB>,  P<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , P<SUB>m</SUB> proceed in parallel to determine in O(log m) steps the smallest value among
the m values that they hold. <IMG 
SRC="theory-bk-seven15x.gif" ALT=" *** ">
   <P >
<A NAME="80001-2012"> </A>
   <P >
   <P >[<A 
 HREF="theory-bk-sevense2.html" >next</A>] [<A 
 HREF="theory-bk-sevense1.html" >front</A>] [<A 
 HREF="theory-bk-seven.html#theory-bk-sevense1.html" >up</A>] <A 
   NAME="tailtheory-bk-sevense1.html"> </A></BODY></HTML>