
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-three.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-threese4.html" >next</A>] [<A 
 HREF="theory-bk-threese2.html" >prev</A>] [<A 
 HREF="theory-bk-threese2.html#tailtheory-bk-threese2.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-threese3.html">tail</A>] [<A 
 HREF="theory-bk-three.html#theory-bk-threese3.html" >up</A>]
<H3>3.3 <A 
   NAME="40003-110003.3"> </A><A 
 HREF="theory-bk.html#Q2-40003-11"  NAME="Q1-40003-11">Context-Free Languages</A></H3>
   <P >
      <A 
 HREF="#Q1-40003-12"  NAME="Q2-40003-12">From Context-Free Grammars to Type 2 Grammars</A>
<BR>         <A 
 HREF="#Q1-40003-13"  NAME="Q2-40003-13">From Context-Free Grammars to Pushdown Automata</A>
<BR>         <A 
 HREF="#Q1-40003-14"  NAME="Q2-40003-14">From Context-Free Grammars to Recursive Finite-Domain Programs</A>
<BR>         <A 
 HREF="#Q1-40003-15"  NAME="Q2-40003-15">From Recursive Finite-Domain Programs to Context-FreeGrammars</A>
<BR>         <A 
 HREF="#Q1-40003-16"  NAME="Q2-40003-16">The Nonterminal Symbols of G</A>
<BR>         <A 
 HREF="#Q1-40003-17"  NAME="Q2-40003-17">The Production Rules of G</A>
<BR>         <A 
 HREF="#Q1-40003-18"  NAME="Q2-40003-18">L(G) is Contained in L(P)</A>
<BR>         <A 
 HREF="#Q1-40003-19"  NAME="Q2-40003-19">L(P) is Contained in L(G)</A>
<A NAME="40003-11001"> </A>
   <P >Pushdown automata can be characterized by Type 2<A NAME="40003-11002"> </A> grammars or, equivalently, by
context-free grammars.
   <P >Specifically, a Type 0 grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt; is said to be <I>context-free</I> if each of
its production rules has exactly one nonterminal symbol on its left hand side, that is, if
each of its production rules is of the form A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT>.
   <P >The grammar is called context-free because it provides no mechanism to restrict the
usage of a production rule A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT> within some specific context. However, in a Type 0
grammar such a restriction can be achieved by using a production rule of the form
<FONT FACE="SYMBOL">b</FONT>A<FONT FACE="SYMBOL">g</FONT> <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">b</FONT><FONT FACE="SYMBOL">a</FONT><FONT FACE="SYMBOL">g</FONT> to specify that A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT> is to be used only within the context of <FONT FACE="SYMBOL">b</FONT> and
<FONT FACE="SYMBOL">g</FONT>.
   <P >The languages that context-free grammars generate are called <I>context-free
languages</I>.
   <P ><STRONG>Example 3.3.1</STRONG> <A 
   NAME="40003-11003t3.3.1"> </A> 
The language { a<SUP>i<SUB>1</SUB></SUP>b<SUP>i<SUB>1</SUB></SUP>a<SUP>i<SUB>2</SUB></SUP>b<SUP>i<SUB>2</SUB></SUP> · · · a<SUP>i<SUB>n</SUB></SUP>b<SUP>i<SUB>n</SUB></SUP>  |  n, i<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , i<SUB>n</SUB>  <FONT FACE="SYMBOL">³</FONT>  0 } is generated by the context-free
grammar &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt;, whose production rules are given below.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-three16x.gif" ALT="  S  ®   SS
    ®   A
    ®   e
A   ®   aAb
    ®   ab"></PRE></CENTER>
   <P >                                                                                              <IMG 
SRC="theory-bk-three17x.gif" ALT="PICT" >
   <P >
   <P ><EM><A 
   NAME="40003-12000"> </A><A 
 HREF="#Q2-40003-12"  NAME="Q1-40003-12">From Context-Free Grammars to Type 2 Grammars</A></EM>
   <P >Recall that a Type 2 grammar is a context-free grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt; in which
A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> in P implies that A = S and that no right-hand side of the production rules
contains S. By the following theorem it follows that context-free grammars and Type
2 grammars act as &#34;maximal&#34; and &#34;minimal&#34; grammars for the same class of
languages.
   <P ><STRONG>Theorem 3.3.1</STRONG> <A 
   NAME="40003-12001t3.3.1"> </A> 
Each context-free language is also a Type 2 language.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="40003-12002t"> </A> 
Consider any context-free grammar G<SUB>1</SUB> = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P<SUB>1</SUB>, S<SUB>1</SUB>&gt;. A Type 2 grammar
G<SUB>2</SUB> = &lt;N <FONT FACE="SYMBOL">È</FONT> {S<SUB>2</SUB>}, <FONT FACE="SYMBOL">S</FONT>, P<SUB>2</SUB>, S<SUB>2</SUB>&gt; satisfies L(G<SUB>2</SUB>) = L(G<SUB>1</SUB>), if S<SUB>2</SUB> is a new symbol and P<SUB>2</SUB> is
obtained from P<SUB>1</SUB> in the following way.
   <P >Initialize P<SUB>2</SUB> to equal P<SUB>1</SUB> <FONT FACE="SYMBOL">È</FONT> {S<SUB>2</SUB> <FONT FACE="SYMBOL">®</FONT> S<SUB>1</SUB>}. Then, as long as P<SUB>2</SUB> contains a production
rule of the form A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> for some A<IMG 
SRC="theory-bk-three18x.gif" ALT="/="ALIGN="MIDDLE" > S<SUB>2</SUB>, modify P<SUB>2</SUB> as follows.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="40003-12003xa"> </A>Delete the production rule A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> from P<SUB>2</SUB>.
     <LI><A 
   NAME="40003-12004xb"> </A>Add  a  production  rule  to  P<SUB>2</SUB>  of  the  form  B <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT><SUB>A</SUB>  as  long  as  such  new
     production rules can be formed. <FONT FACE="SYMBOL">a</FONT><SUB>A</SUB> is assumed to be the string <FONT FACE="SYMBOL">a</FONT> with one
     appearance of A omitted in it, and <FONT FACE="SYMBOL">a</FONT> is assumed to be the right-hand side of
     a production rule of the form B <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT> that is already in P<SUB>2</SUB>. If <FONT FACE="SYMBOL">a</FONT><SUB>A</SUB> = <FONT FACE="SYMBOL">e</FONT> and the
     production rule B <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> has been removed earlier from P<SUB>2</SUB>, then the production
     rule is not reinserted to P<SUB>2</SUB>.</OL>
No addition of a production rule of the form B <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT><SUB>A</SUB> to P<SUB>2</SUB> changes the generated
language, because any usage of the production rule can be simulated by the pair B <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT>
and A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> of production rules.
   <P >Similarly, no deletion of a production rule A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> from P<SUB>2</SUB> affects the generated
language, because each subderivation C <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">b</FONT><SUB>1</SUB>A<FONT FACE="SYMBOL">b</FONT><SUB>2</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">g</FONT><SUB>1</SUB>A<FONT FACE="SYMBOL">g</FONT><SUB>2</SUB> <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">g</FONT><SUB>1</SUB><FONT FACE="SYMBOL">g</FONT><SUB>2</SUB> which uses
A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> can be replaced with an equivalent subderivation of the form C <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">b</FONT><SUB>1</SUB><FONT FACE="SYMBOL">b</FONT><SUB>2</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">g</FONT><SUB>1</SUB><FONT FACE="SYMBOL">g</FONT><SUB>2</SUB>.
<IMG 
SRC="theory-bk-three1x.gif" ALT=" *** " 
 >
   <P >
   <P ><STRONG>Example 3.3.2</STRONG> <A 
   NAME="40003-12005t3.3.2"> </A> 
Let G<SUB>1</SUB> be the context-free grammar whose production rules are listed below.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-three19x.gif" ALT=" S   ®  e
 1  ®  S aCC
C   ®  e 1
    ®  Dab
D   ®  S
         1"></PRE></CENTER>
   <P >The construction in the proof of Theorem <A 
 HREF="#40003-12001t3.3.1">3.3.1</A> implies the following equivalent
grammars, where G<SUB>2</SUB> is a Type 2 grammar.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-three20x.gif" ALT="            '               '               '
          G 1             G2              G3              G2
 Added-S2-®-S1-    RemovedS1®-e-    RemovedC-®-e-    RemovedD-®-e-
S2  ®  S1       S2  ®  S1       S2 ®   S1       S2 ®   S1
S1  ®  e            ®  e           ®   e           ®   e
    ®  S1aCC    S1  ®  S1aCC    S1 ®   S1aCC    S1 ®   S1aCC
 C  ®  e            ®  aCC         ®   S1aC        ®   S1aC
    ®  Dab       C  ®  e           ®   S1a         ®   S1a
 D  ®  S1           ®  Dab         ®   aCC         ®   aCC
                 D  ®  S1          ®   aC          ®   aC
                    ®  e           ®   a           ®   a
                                 C ®   Dab       C ®   Dab
                                 D ®   S1          ®   ab
                                   ®   e        D  ®   S1"></PRE></CENTER>
   <P >                                                                                                                   <IMG 
SRC="theory-bk-three21x.gif" ALT="PICT" >
   <P >
   <P ><EM><A 
   NAME="40003-13000"> </A><A 
 HREF="#Q2-40003-13"  NAME="Q1-40003-13">From Context-Free Grammars to Pushdown Automata</A></EM>
   <P >Pushdown automata and recursive finite-domain programs process their inputs from
left to right. To enable such entities to trace derivations of context-free grammars, the
following lemma considers a similar property in the derivations of context-free
grammars.
   <P ><STRONG>Lemma 3.3.1</STRONG> <A 
   NAME="40003-13001t3.3.1"> </A> 
If a nonterminal symbol A derives a string <FONT FACE="SYMBOL">r</FONT> of terminal symbols in a context-free
grammar G, then <FONT FACE="SYMBOL">r</FONT> has a leftmost<A NAME="40003-13002"> </A> derivation from A in G.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="40003-13003t"> </A> 
The proof is by contradiction. Recall that in context-free grammars the leftmost
derivations <FONT FACE="SYMBOL">r</FONT><SUB>1</SUB> <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>2</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>n</SUB> replace the leftmost nonterminal symbol in each
sentential form <FONT FACE="SYMBOL">r</FONT><SUB>i</SUB>, i = 1, 2,<FONT FACE="SYMBOL"> ¼</FONT>, n - 1.
   <P >The proof relies on the observation that the ordering in which the nonterminal symbols
are replaced in the sentential forms is of no importance for the derivations in context-free
grammars. Each nonterminal symbol in each sentential form is expanded without any
correlation to its context in the sentential form.
   <P >Consider any context-free grammar G. For the purpose of the proof assume that a
string <FONT FACE="SYMBOL">r</FONT> of terminal symbols has a derivation of length n from a nonterminal symbol A. In
addition, assume that <FONT FACE="SYMBOL">r</FONT> has no leftmost derivation from A.
   <P >Let A <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>1</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>m</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>n</SUB> = <FONT FACE="SYMBOL">r</FONT> be a derivation of length n in which
A <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>1</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>m</SUB> is a leftmost subderivation. In addition, assume that m is maximized
over the derivations A <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">r</FONT> of length n. By the assumption that <FONT FACE="SYMBOL">r</FONT> has no leftmost
derivation from A, it follows that m &lt; n - 1.
   <P >The derivation in question satisfies <FONT FACE="SYMBOL">r</FONT><SUB>m</SUB> = wB<IMG 
SRC="theory-bk-three22x.gif" ALT="^r"><SUB>m</SUB>, <FONT FACE="SYMBOL">r</FONT><SUB>m+1</SUB> = wB<IMG 
SRC="theory-bk-three23x.gif" ALT="^r"><SUB>m+1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <FONT FACE="SYMBOL">r</FONT><SUB>k</SUB> = wB<IMG 
SRC="theory-bk-three24x.gif" ALT="^r"><SUB>k</SUB>, <FONT FACE="SYMBOL">r</FONT><SUB>k+1</SUB> = w<FONT FACE="SYMBOL">b</FONT><IMG 
SRC="theory-bk-three25x.gif" ALT="^r"><SUB>k</SUB>
for some string w of terminal symbols, production rule B <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">b</FONT>, m &lt; k &lt; n, and <IMG 
SRC="theory-bk-three26x.gif" ALT="^r"><SUB>m</SUB>, <FONT FACE="SYMBOL">¼</FONT> , <IMG 
SRC="theory-bk-three27x.gif" ALT="^r"><SUB>k</SUB>. Thus
A <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>1</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>m-1</SUB> <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>m</SUB> = wB<IMG 
SRC="theory-bk-three28x.gif" ALT="^r"><SUB>m</SUB> <FONT FACE="SYMBOL">Þ</FONT> w<FONT FACE="SYMBOL">b</FONT><IMG 
SRC="theory-bk-three29x.gif" ALT="^r"><SUB>m</SUB> <FONT FACE="SYMBOL">Þ</FONT> w<FONT FACE="SYMBOL">b</FONT><IMG 
SRC="theory-bk-three30x.gif" ALT="^r"><SUB>m+1</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> w<FONT FACE="SYMBOL">b</FONT><IMG 
SRC="theory-bk-three31x.gif" ALT="^r"><SUB>k</SUB> = <FONT FACE="SYMBOL">r</FONT><SUB>k+1</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>n</SUB> = <FONT FACE="SYMBOL">r</FONT>
is also a derivation of <FONT FACE="SYMBOL">r</FONT> from A of length n.
   <P >However, in this new derivation A <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>1</SUB> <FONT FACE="SYMBOL">Þ</FONT> · · · <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">r</FONT><SUB>m</SUB> <FONT FACE="SYMBOL">Þ</FONT> w<FONT FACE="SYMBOL">b</FONT><IMG 
SRC="theory-bk-three32x.gif" ALT="r^"><SUB>m</SUB> is a leftmost
subderivation of length m + 1. Consequently, contradicting the existence of a maximal m
as implied above, from the assumption that <FONT FACE="SYMBOL">r</FONT> has only nonleftmost derivations from
A.
   <P >As a result, the assumption that <FONT FACE="SYMBOL">r</FONT> has no leftmost derivation from A is also
contradicted. <IMG 
SRC="theory-bk-three1x.gif" ALT=" *** " 
 >
   <P >
   <P >The proof of the following theorem shows how pushdown automata can trace the
derivations of context-free grammars.
   <P ><STRONG>Theorem 3.3.2</STRONG> <A 
   NAME="40003-13004t3.3.2"> </A> 
Each context-free language is accepted by a pushdown automaton.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="40003-13005t"> </A> 
Consider any context-free grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt;. With no loss of generality
assume that Z<SUB>0</SUB> is not in N <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT>. L(G) is accepted by the pushdown automaton
M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, N <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT> <FONT FACE="SYMBOL">È</FONT> {Z<SUB>0</SUB>}, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, Z<SUB>0</SUB>, {q<SUB>f</SUB>}&gt; whose transition table <FONT FACE="SYMBOL">d</FONT> consists of the
following derivation rules.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="40003-13006xa"> </A>A transition rule of the form (q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>1</SUB>, S).
     <LI><A 
   NAME="40003-13007xb"> </A>A sequence of transition rules for each A <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT> in P. Each such sequence
     starts and ends at state q<SUB>1</SUB>, and replaces a nonterminal symbol A on top of the
     pushdown store with the string <FONT FACE="SYMBOL">a</FONT> in reverse order.
     <LI><A 
   NAME="40003-13008xc"> </A>A transition rule of the form (q<SUB>1</SUB>, a, a, q<SUB>1</SUB>, <FONT FACE="SYMBOL">e</FONT>), for each terminal symbol a in the
     alphabet <FONT FACE="SYMBOL">S</FONT>.
     <LI><A 
   NAME="40003-13009xd"> </A>A transition rule of the form (q<SUB>1</SUB>, <FONT FACE="SYMBOL">e</FONT>, Z<SUB>0</SUB>, q<SUB>f</SUB>, Z<SUB>0</SUB>).</OL>
Intuitively, we know that on a given input x the pushdown automaton M nondeterministically
traces a leftmost derivation in G that starts at S and ends at x. At each stage of the tracing,
the portion of the input that has already been read together with the content of the
pushdown store in reverse order, record the sentential form in the corresponding stage of
the derivation.
   <P >The transition rule in (a) is used for pushing the first sentential form S into the
pushdown store. The transition rules in (b) are used for replacing the leftmost nonterminal
symbol in a given sentential form with the right-hand side of an appropriate production
rule. The transition rules in (c) are used for matching the leading terminal symbols in the
sentential forms with the corresponding symbols in the given input x. The purpose of the
production rule in (d) is to move the pushdown automaton into an accepting state upon
reaching the end of a derivation.
   <P >By induction on n it can be verified that x has a leftmost derivation in G if and only if
M has an accepting computation on x, where the derivation and the computation have the
following forms with u<SUB>i</SUB>v<SUB>i</SUB> = x for 1 <FONT FACE="SYMBOL">£</FONT> i &lt; n.
   <P ><CENTER>
<PRE><IMG 
SRC="theory-bk-three33x.gif" ALT=" S                         (q0x,Z0) |-  (q1x,Z0S)
Þ  u1A1r1                  |- * (u1q1v1,Z0rrevA1)
Þ  u2A2r2                  |- * (u2q1v2,Z0r1revA2)
Þ  ···                      |- * ···       2
Þ  un-1An-1rn-1            |- * (un- 1q1vn-1,Z0rrevAn- 1)
Þ  x                       |- * (xq1,Z0)  |- (xqf,Zn0-)1"></PRE></CENTER>
   <P >                                                                                             <IMG 
SRC="theory-bk-three34x.gif" ALT="PICT" >
   <P >
   <P ><STRONG>Example 3.3.3</STRONG> <A 
   NAME="40003-13010t3.3.3"> </A> 
If G is the context-free grammar of Example <A 
 HREF="#40003-11003t3.3.1">3.3.1</A>, then the language L(G) is
accepted by the pushdown automaton M, whose transition diagram is given in
Figure <A 
 HREF="#40003-13011r3.3.1">3.3.1</A>(a).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="40003-13011r3.3.1"> </A>

<IMG 
SRC="draw-pic/theory-bk-three-3-3-1-a.jpg" ALT="[PICT]" 
>
                               (a)
                                                          <IMG 
SRC="draw-pic/theory-bk-three-3-3-1-b.jpg" ALT="[PICT]" 
>
                               (b)
<A 
   NAME="40003-13011r3.3.1"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 3.3.1 </STRONG></NOBR></TD><TD  
>(a)  A  pushdown  automaton  that  accepts  the  language  generated  by  the  grammar
of Example <A 
 HREF="#40003-13010t3.3.3">3.3.3</A>. (b) A leftmost derivation in the grammar and the corresponding
computation by the pushdown automaton.                                                                   </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >aabbab has the leftmost derivation S <FONT FACE="SYMBOL">Þ</FONT> SS <FONT FACE="SYMBOL">Þ</FONT> AS <FONT FACE="SYMBOL">Þ</FONT> aAbS <FONT FACE="SYMBOL">Þ</FONT> aabbS <FONT FACE="SYMBOL">Þ</FONT> aabbA <FONT FACE="SYMBOL">Þ</FONT> aabbab
in G. Figure <A 
 HREF="#40003-13011r3.3.1">3.3.1</A>(b) shows the corresponding configurations of M in its computation on
such an input. <IMG 
SRC="theory-bk-three1x.gif" ALT=" *** " 
 >
   <P >
   <P ><EM><A 
   NAME="40003-14000"> </A><A 
 HREF="#Q2-40003-14"  NAME="Q1-40003-14">From Context-Free Grammars to Recursive Finite-Domain
<BR>Programs</A></EM>
   <P >By Theorems <A 
 HREF="theory-bk-threese2.html#40002-9005t3.2.1">3.2.1</A> and <A 
 HREF="#40003-13004t3.3.2">3.3.2</A> each context-free language is accepted by a recursive
finite-domain program. For a given context-free grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt;, the
recursive finite-domain program T that accepts L(G) can be of the following
form.
   <P >T on a given input x nondeterministically traces a leftmost derivation that starts at S. If
the leftmost derivation provides the string x, then T accepts its input. Otherwise, T rejects
the input.
   <P >T has one procedure for each nonterminal symbol in N, and one procedure for each
terminal symbol in <FONT FACE="SYMBOL">S</FONT>. A procedure that corresponds to a nonterminal symbol A is
responsible for initiating a tracing of a leftmost subderivation that starts at A. The
procedure does so by nondeterministically choosing a production rule of the form
A <FONT FACE="SYMBOL">®</FONT> X<SUB>1</SUB> · · · X<SUB>m</SUB>, and then calling the procedures that correspond to X<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , X<SUB>m</SUB> in the given
order. On the other hand, each procedure that corresponds to a terminal symbol is
responsible for reading an input symbol and verifying that the symbol is equal to its
corresponding terminal symbol.
   <P >Each of the procedures above returns the control to the point of invocation, upon
successfully completing the given responsibilities. However, each of the procedures
terminates the computation at a nonaccepting configuration upon determining that the
given responsibility cannot be carried out.
   <P >The main program starts a computation by invoking the procedure that corresponds to
the start symbol S. Upon the return of control the main program terminates the
computation, where the termination is in an accepting configuration if and only if the
remainder of the input is empty.
   <P >The recursive finite-domain program T can be as depicted in Figure <A 
 HREF="#40003-14001r3.3.2">3.3.2</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="40003-14001r3.3.2"> </A>
          <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>call</B> S()
<B>if</B> <I>eof</I> <B>then accept</B>
<B>reject</B>
<B>procedure</B> A()         /* For each nonterminal symbol A. */
    <B>do</B>
        <IMG 
SRC="theory-bk-three35x.gif" ALT=".
..">
    <B>or</B>                   /* For each production rule of the form
                           A <FONT FACE="SYMBOL">®</FONT> X<SUB>1</SUB> · · · X<SUB>m</SUB>.                            */
        <B>call</B> X<SUB>1</SUB>() · · · <B>call</B> X<SUB>m</SUB>()
      <B>return</B>
    <B>or</B>
        <IMG 
SRC="theory-bk-three36x.gif" ALT=".
..">
    <B>until</B> true
<B>end</B>
<B>procedure</B> a()                /* For each terminal symbol a. */
    <B>read</B> <TT>symbol</TT>
    <B>if</B> <TT>symbol</TT> = a <B>then return</B>
    <B>reject</B>
<B>end</B>                                                                                     </PRE></TD></TR></TABLE>
<A 
   NAME="40003-14001r3.3.2"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 3.3.2 </STRONG></NOBR></TD><TD  
>A scheme of recursive finite-domain programs that simulate context-free grammars.</TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P ><STRONG>Example 3.3.4</STRONG> <A 
   NAME="40003-14002t3.3.4"> </A> 
If G is the context-free grammar of Example <A 
 HREF="#40003-11003t3.3.1">3.3.1</A>, then L(G) is accepted by the recursive
finite-domain program in Figure <A 
 HREF="#40003-14003r3.3.3">3.3.3</A>.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="40003-14003r3.3.3"> </A>
          <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>call</B> S()
<B>if</B> <I>eof</I> <B>then accept</B>
<B>reject</B>
<B>procedure</B> S()
    <B>do</B>                                                           /* S <FONT FACE="SYMBOL">®</FONT> SS   */
        <B>call</B> S() <B>call</B> S() <B>return</B>
    <B>or</B>                                                           /* S <FONT FACE="SYMBOL">®</FONT> A    */
        <B>call</B> A() <B>return</B>
    <B>or</B>                                                           /* S <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT>     */
        <B>return</B>
    <B>until</B> true
<B>end</B>
<B>procedure</B> A()
    <B>do</B>                                                           /* A <FONT FACE="SYMBOL">®</FONT> aAb */
        <B>call</B> a() <B>call</B> A() <B>call</B> b() <B>return</B>
    <B>or</B>                                                           /* A <FONT FACE="SYMBOL">®</FONT> ab   */
        <B>call</B> a() <B>call</B> b() <B>return</B>
    <B>until</B> true
<B>end</B>
<B>procedure</B> a()
    <B>read</B> <TT>symbol</TT>
    <B>if</B> <TT>symbol</TT> = a <B>then return</B>
    <B>reject</B>
<B>end</B>
<B>procedure</B> b()
    <B>read</B> <TT>symbol</TT>
    <B>if</B> <TT>symbol</TT> = b <B>then return</B>
    <B>reject</B>
<B>end</B>                                                                                     </PRE></TD></TR></TABLE>
<A 
   NAME="40003-14003r3.3.3"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 3.3.3 </STRONG></NOBR></TD><TD  
>A recursive finite-domain program for the grammar of Example <A 
 HREF="#40003-11003t3.3.1">3.3.1</A>.                       </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >On input aabbab the recursive finite-domain program traces the derivation
S <FONT FACE="SYMBOL">Þ</FONT> SS <FONT FACE="SYMBOL">Þ</FONT> AS <FONT FACE="SYMBOL">Þ</FONT> aAbS <FONT FACE="SYMBOL">Þ</FONT> aabbS <FONT FACE="SYMBOL">Þ</FONT> aabbA <FONT FACE="SYMBOL">Þ</FONT> aabbab by calling its procedures in the
order indicated in Figure <A 
 HREF="#40003-14004r3.3.4">3.3.4</A>. <IMG 
SRC="theory-bk-three1x.gif" ALT=" *** " 
 >
   <P >
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="40003-14004r3.3.4"> </A>
<A 
   NAME="40003-14004r3.3.4"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-three-3-3-4.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 3.3.4 </STRONG></NOBR></TD><TD  
>The calls to procedures that the program of Figure <A 
 HREF="#40003-14003r3.3.3">3.3.3</A> makes on input aabbab.      </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P ><EM><A 
   NAME="40003-15000"> </A><A 
 HREF="#Q2-40003-15"  NAME="Q1-40003-15">From Recursive Finite-Domain Programs to Context-Free
<BR>Grammars</A></EM>
   <P >A close look at the proof of Theorem <A 
 HREF="theory-bk-twose3.html#30003-14002t2.3.2">2.3.2</A> indicates how a given finite-memory
program P can be simulated by a Type 3 grammar G = &lt;N, <FONT FACE="SYMBOL">S</FONT>, P, S&gt;.
   <P >The grammar uses its nonterminal symbols to record the states of P. Each production
rule of the form A <FONT FACE="SYMBOL">®</FONT> aB in the grammar is used to simulate a subcomputation of P
that starts at the state recorded by A, ends at the state recorded by B, and reads
an input symbol a. However, each production rule of the form A <FONT FACE="SYMBOL">®</FONT> a in the
grammar is used to simulate a subcomputation of P that starts at the state that is
recorded by A, ends at an accepting state, and reads an input symbol a. The start
symbol S of G is used to record the initial state of P. The production rule S <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT>
is used to simulate an accepting computation of P in which no input value is
read.
   <P >The proof of the following theorem relies on a similar approach.
   <P ><STRONG>Theorem 3.3.3</STRONG> <A 
   NAME="40003-15001t3.3.3"> </A> 
Every language that is accepted by a recursive finite-domain program is a context-free
language.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="40003-15002t"> </A> 
Consider any recursive finite-domain program P. With no loss of generality it can be
assumed that the program has no write instructions. The language that is accepted by P can
be generated by a context-free grammar G that simulates the computations of P. The
nonterminal symbols of G are used to indicate the start and end states of subcomputations
of P that have to be simulated, and the production rules of G are used for simulating
transitions between states of P.
   <P ><EM><A 
   NAME="40003-16000"> </A><A 
 HREF="#Q2-40003-16"  NAME="Q1-40003-16">The Nonterminal Symbols of G</A></EM>
   <P >Specifically, the nonterminal symbols of G consist of
     <OL TYPE="a" 
>
     <LI><A 
   NAME="40003-16001xa"> </A>A  nonterminal  symbol  A<SUB>q</SUB>,  for  each  state  q of  P.  Each  such  nonterminal
     symbol A<SUB>q</SUB> is used for indicating that a subcomputation of P, which starts at
     state q and ends at an accepting state, has to be simulated. Moreover, each
     execution of a return instruction in the subcomputation must be for a call that
     is made previously during the subcomputation.
     <P >The start symbol of G is the nonterminal symbol A<SUB>q<SUB>0</SUB></SUB> that corresponds to the
     initial state q<SUB>0</SUB> of P.
     <LI><A 
   NAME="40003-16002xb"> </A>A  nonterminal  symbol  A<SUB>q,p</SUB>,  for  each  pair  of  states  q and  p  corresponding
     to  instruction  segments  that  are  in  the  same  procedure  of  P.  Each  such
     nonterminal symbol A<SUB>q,p</SUB> is introduced for indicating that a subcomputation,
     which  starts  at  state  q  and  ends  at  state  p,  has  to  be  simulated.  In  the
     subcomputation the number of executions of return instructions has to equal
     the number of executions of call instructions. Moreover, each execution of
     a  return  instruction  in  the  subcomputation  must  be  for  a  call  that  is  made
     previously during the subcomputation.
     </OL>
   <P >
   <P ><EM><A 
   NAME="40003-17000"> </A><A 
 HREF="#Q2-40003-17"  NAME="Q1-40003-17">The Production Rules of G</A></EM>
   <P >The production rules of G consist of
     <OL TYPE="a" 
>
     <LI><A 
   NAME="40003-17001xa"> </A>A production rule of the form A<SUB>q</SUB> <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT>A<SUB>r</SUB>, and a production rule of the form
     A<SUB>q,p</SUB>  <FONT FACE="SYMBOL">®</FONT>  <FONT FACE="SYMBOL">a</FONT>A<SUB>r,p</SUB>, for each q, r, p, and <FONT FACE="SYMBOL">a</FONT> that satisfy the following condition.
     The instruction segment that corresponds to state q is neither a call instruction
     nor a return instruction, and its execution can take the program from state q to
     state r while reading <FONT FACE="SYMBOL">a</FONT>.
     <P >A production rule of the form A<SUB>q</SUB>  <FONT FACE="SYMBOL">®</FONT>  <FONT FACE="SYMBOL">a</FONT>A<SUB>r</SUB> replaces the objective of reaching
     an accepting state from state q with the objective of reaching an accepting
     state from state r.
     <P >A  production  rule  of  the  form  A<SUB>q,p</SUB>   <FONT FACE="SYMBOL">®</FONT>   <FONT FACE="SYMBOL">a</FONT>A<SUB>r,p</SUB>  replaces  the  objective  of
     reaching state p from state q with the objective of reaching state p from state
     r.
     <LI><A 
   NAME="40003-17002xb"> </A>A production rule of the form A<SUB>q</SUB> <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT>, for each state q that corresponds to an
     <B>if</B> <I>eof</I> <B>then accept</B> instruction.
     <LI><A 
   NAME="40003-17003xc"> </A>A production rule of the form A<SUB>q</SUB> <FONT FACE="SYMBOL">®</FONT> A<SUB>r</SUB>, for each state q that corresponds to
     a call instruction, where r is the state reached from q. Each such production
     rule simulates an execution of a <B>call</B> which is not matched by an execution of
     a <B>return</B>.
     <LI><A 
   NAME="40003-17004xd"> </A>A production rule of the form A<SUB>q</SUB> <FONT FACE="SYMBOL">®</FONT> A<SUB>r,s</SUB>A<SUB>t</SUB>, and a production rule of the form
     A<SUB>q,p</SUB> <FONT FACE="SYMBOL">®</FONT> A<SUB>r,s</SUB>A<SUB>t,p</SUB>, for each q, r, s, t, and p such that the following conditions
     hold.
         <OL TYPE="1" 
>
         <LI><A 
   NAME="40003-17005xd1"> </A>State q corresponds to a call instruction whose execution at such a state
         causes the program to enter state r.
         <LI><A 
   NAME="40003-17006xd2"> </A>State s corresponds to a return instruction in the called procedure, and
         the execution of the return instruction at such a state takes the program
         to state t that is compatible with r.</OL>
     That  is,  the  subcomputation  that  starts  at  state  q is  decomposed  into  two
     subcomputations. One is to be performed by an invoked procedure, starting at
     state r and ending at state s; the other takes on from the instant that the control
     returns from the invoked procedure, starting at state t.
     <LI><A 
   NAME="40003-17007xe"> </A>A production rule of the form A<SUB>q,q</SUB> <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">e</FONT> for each state q that corresponds to a
     <B>return</B> instruction.
     <P >Each  of  the  production  rules  above  is  used  for  terminating  a  successful
     simulation of a subcomputation performed by an invoked procedure.</OL>
   <P ><EM><A 
   NAME="40003-18000"> </A><A 
 HREF="#Q2-40003-18"  NAME="Q1-40003-18">L(G) is Contained in L(P)</A></EM>
   <P >A proof by induction can be used to show that the construction above implies
L(G) = L(P).
   <P >To show that L(G), is contained in L(P) it is sufficient to show that the following two
conditions hold for each string <FONT FACE="SYMBOL">a</FONT> of terminal symbols.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="40003-18001xa"> </A>If  A<SUB>q</SUB>  <FONT FACE="SYMBOL">Þ</FONT>*  <FONT FACE="SYMBOL">a</FONT> in  G  then  P can  reach  from  state  q an  accepting  state  while
     reading  <FONT FACE="SYMBOL">a</FONT>,  and  in  any  prefix  of  the  subexecution  sequence  there  must  be
     at  least  as  many  executions  of  call  instructions  as  executions  of  return
     instructions.
     <LI><A 
   NAME="40003-18002xb"> </A>If A<SUB>q,p</SUB>  <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT> in G, then P can reach state p from state q while reading <FONT FACE="SYMBOL">a</FONT>.
     In the subexecution sequence the number of executions of return instructions
     must equal the number of executions of call instructions, and in any prefix of
     the subexecution sequence there must be at least as many executions of call
     instructions as executions of return instructions.
     </OL>
   <P >
The proof can be by induction on the number of steps i in the derivations. For i = 1, the
only feasible derivations are those that have either the form A<SUB>q</SUB> <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">e</FONT> or the form A<SUB>p,p</SUB> <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">e</FONT>.
In the first case q corresponds to an accept instruction, and in the second case p
corresponds to a return instruction. In both cases the subexecution sequences of the
program are empty.
   <P >For i &gt; 1 the derivations must have either of the following forms.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="40003-18003xa"> </A>A<SUB>q</SUB>   <FONT FACE="SYMBOL">Þ</FONT>   <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>A<SUB>r</SUB>   <FONT FACE="SYMBOL">Þ</FONT>*  <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB><FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>  =  <FONT FACE="SYMBOL">a</FONT>,  or  A<SUB>q,p</SUB>   <FONT FACE="SYMBOL">Þ</FONT>   <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>A<SUB>r,p</SUB>   <FONT FACE="SYMBOL">Þ</FONT>*  <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB><FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>  =  <FONT FACE="SYMBOL">a</FONT>.  In
     either case, by definition A<SUB>q</SUB>  <FONT FACE="SYMBOL">Þ</FONT>  <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>A<SUB>r</SUB>  and  A<SUB>q,p</SUB>  <FONT FACE="SYMBOL">Þ</FONT>  <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>A<SUB>r,p</SUB>  correspond  to
     subexecution sequences that start at state q, end at state r, consume the input
     <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>, and execute neither a call instruction nor a return instruction. However,
     by  the  induction  hypothesis  A<SUB>r</SUB>   <FONT FACE="SYMBOL">Þ</FONT>*  <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>  and  A<SUB>r,p</SUB>   <FONT FACE="SYMBOL">Þ</FONT>*  <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>  correspond
     to  subexecution  sequences  that  have  the  desired  properties.  Consequently,
     A<SUB>q</SUB>  <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT> and A<SUB>q,p</SUB>  <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT> also correspond to subexecution sequences that
     have the desired properties.
     <LI><A 
   NAME="40003-18004xb"> </A>A<SUB>q</SUB> <FONT FACE="SYMBOL">Þ</FONT> A<SUB>r,s</SUB>A<SUB>t</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB><FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>, or A<SUB>q,p</SUB> <FONT FACE="SYMBOL">Þ</FONT> A<SUB>r,s</SUB>A<SUB>t,p</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB><FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>, where A<SUB>r,s</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>.
     In either case, by definition q corresponds to a call instruction, r is the state
     that  P reaches  from  state  q,  s  corresponds  to  a  return  instruction,  and  t  is
     the state that P reaches from state s. However, by the induction hypothesis
     A<SUB>r,s</SUB>   <FONT FACE="SYMBOL">Þ</FONT>*  <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>,  A<SUB>t</SUB>   <FONT FACE="SYMBOL">Þ</FONT>*  <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>,  and  A<SUB>t,p</SUB>   <FONT FACE="SYMBOL">Þ</FONT>*  <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>  correspond  to  subexecution
     sequences that have the desired properties. Consequently, A<SUB>q</SUB>  <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB><FONT FACE="SYMBOL">a</FONT><SUB>2</SUB> and
     A<SUB>q,p</SUB>   <FONT FACE="SYMBOL">Þ</FONT>*  <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB><FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>  also  correspond  to  subexecution  sequences  that  have  the
     desired properties.</OL>
   <P ><EM><A 
   NAME="40003-19000"> </A><A 
 HREF="#Q2-40003-19"  NAME="Q1-40003-19">L(P) is Contained in L(G)</A></EM>
   <P >To show that L(P) is contained in L(G) it is sufficient to show that either of the
following conditions holds for each subexecution sequence that reads <FONT FACE="SYMBOL">a</FONT>, starts at state q,
ends at state p, and has at least as many executions of return instructions as of call
instructions in each of the prefixes.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="40003-19001xa"> </A>If p corresponds to an accepting state, then G has a derivation of the form
     A<SUB>q</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT>.
     <LI><A 
   NAME="40003-19002xb"> </A>If p corresponds to a return instruction and the subexecution sequence has as
     many executions of call instructions as of return instructions, then G has a
     derivation of the form A<SUB>q,p</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT>.</OL>
The proof is by induction on the number of moves i in the subexecution sequences. For
i = 0 the subexecution sequences consume no input, and for them G has the
corresponding derivations A<SUB>p</SUB> <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">e</FONT> and A<SUB>p,p</SUB> <FONT FACE="SYMBOL">Þ</FONT> <FONT FACE="SYMBOL">e</FONT>, respectively.
   <P >For i &gt; 0 either of the following cases must hold.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="40003-19003xa"> </A>q  does  not  correspond  to  a  call  instruction,  or  q  corresponds  to  a  call
     instruction  that  is  not  matched  in  the  subexecution  sequence  by  a  return
     instruction.  In  such  a  case,  by  executing  a  single  instruction  segment  the
     subexecution  sequences  in  question  enter  some  state  r from  state  q while
     consuming some input <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>.
     <P >Consequently, by definition, the grammar G has a production rule of the form
     A<SUB>q</SUB>  <FONT FACE="SYMBOL">®</FONT>  <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>A<SUB>r</SUB>  if  p  is  an  accepting  state,  and  a  production  rule  of  the  form
     A<SUB>q,p</SUB> <FONT FACE="SYMBOL">®</FONT> <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB>A<SUB>r,p</SUB> if p corresponds to a return instruction.
     <P >However, by the induction hypothesis the i-1 moves that start in state r have
     in G a corresponding derivation of the form A<SUB>r</SUB>  <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB> if p is an accepting
     state, and of the form A<SUB>r,p</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB> if p corresponds to a return instruction. <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>
     is assumed to satisfy <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB><FONT FACE="SYMBOL">a</FONT><SUB>2</SUB> = <FONT FACE="SYMBOL">a</FONT>.
     <LI><A 
   NAME="40003-19004xb"> </A>q  corresponds  to  a  call  instruction  that  is  matched  in  the  subexecution
     sequence by a return instruction. In such a case the subexecution sequence
     from   state   q  enters   some   state   r  by   executing   the   call   instruction
     that  corresponds  to  state  q.  Moreover,  the  subexecution  sequence  has  a
     corresponding  execution  of  a  return  instruction  that  takes  the  subexecution
     sequence from some state s to some state t.
     <P >Consequently, by definition, the grammar G has a production rule of the form
     A<SUB>q</SUB>  <FONT FACE="SYMBOL">®</FONT>  A<SUB>r,s</SUB>A<SUB>t</SUB>  if  p  is  an  accepting  state,  and  a  production  rule  of  the  form
     A<SUB>q,p</SUB> <FONT FACE="SYMBOL">®</FONT> A<SUB>r,s</SUB>A<SUB>t,p</SUB> if p corresponds to a return instruction.
     <P >However, by the induction hypothesis, the grammar G has a derivation of the
     form A<SUB>r,s</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB> for the input <FONT FACE="SYMBOL">a</FONT><SUB>1</SUB> that the subexecution sequence consumes
     between  states  r and  s.  In  addition,  G  has  either  a  derivation  of  the  form
     A<SUB>t</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB> or a derivation of the form A<SUB>t,p</SUB> <FONT FACE="SYMBOL">Þ</FONT>* <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB>, respectively, for the input
     <FONT FACE="SYMBOL">a</FONT><SUB>2</SUB> that the subexecution sequence consumes between states t and p, depending
     on whether p is an accepting state or not. <IMG 
SRC="theory-bk-three1x.gif" ALT=" *** " 
 ></OL>
   <P >
   <P ><STRONG>Example 3.3.5</STRONG> <A 
   NAME="40003-19005t3.3.5"> </A> 
Let P be the recursive finite-domain program in Figure <A 
 HREF="#40003-19006r3.3.5">3.3.5</A>(a), with {a, b} as a domain of
the variables and a as initial value.
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="40003-19006r3.3.5"> </A>
                  <TABLE  
CELLPADDING="0" BORDER="0" CELLSPACING="0" 
WIDTH="100%"><TR><TD 
><PRE><B>call</B> f(<TT>x</TT>)                               /* I<SUB>1</SUB> */
<B>if</B> <I>eof</I> <B>then accept</B>                /* I<SUB>2</SUB> */
<B>reject</B>                                    /* I<SUB>3</SUB> */
<B>procedure</B> f(<TT>x</TT>)
    <B>do</B>                                     /* I<SUB>4</SUB> */
        <B>return</B>                           /* I<SUB>5</SUB> */
    <B>or</B>
        <B>read</B> <TT>x</TT>                           /* I<SUB>6</SUB> */
        <B>call</B> f(<TT>x</TT>)                       /* I<SUB>7</SUB> */
    <B>until</B> <TT>x</TT> = a                  /* I<SUB>8</SUB> */
<B>end</B>                                                   </PRE></TD></TR></TABLE>
                               (a)
<DIV ALIGN="CENTER">
<IMG 
SRC="theory-bk-three37x.gif" ALT="A[1,a]     ®   A[4,a]                A[4,b],[5,a]  ®   A[5,b],[5,a]
          ®   A[4,a],[5,a]A[2,a]                   ®   A[6,b],[5,a]
          ®   A[4,a],[5,b]A[2,b]         A[4,b],[5,b]  ®   A[5,b],[5,b]
A[2,a]     ®   e                              ®   A[6,b],[5,b]
          ®   A[3,a]                A[5,a],[5,a]  ®   e
A[2,b]     ®   e                    A[5,b],[5,b]  ®   e
          ®   A[3,b]                 A[6,a],[5,a]  ®   aA[7,a],[5,a]
A[4,a]     ®   A[5,a]                          ®   bA[7,b],[5,a]
          ®   A[6,a]                A[6,a],[5,b]  ®   aA[7,a],[5,b]
A[4,b]     ®   A[5,b]                           ®   bA[7,b],[5,b]
          ®   A[6,b]                 A[6,b],[5,a]  ®   aA[7,a],[5,a]
A[6,a]     ®   aA[7,a]                         ®   bA[7,b],[5,a]
          ®   bA[7,b]                A[6,b],[5,b]  ®   aA[7,a],[5,b]
A[6,b]     ®   aA[7,a]                         ®   bA[7,b],[5,b]
          ®   bA[7,b]                A[7,a],[5,a]  ®   A[4,a],[5,a]A[8,a],[5,a]
A[7,a]     ®   A[4,a],[5,a]A[8,a]                   ®   A[4,a],[5,b]A[8,b],[5,a]
          ®   A[4,a],[5,b]A[8,b]         A[7,a],[5,b]  ®   A[4,a],[5,a]A[8,a],[5,b]
A[7,b]     ®   A[4,b],[5,a]A[8,a]                   ®   A[4,a],[5,b]A[8,b],[5,b]
          ®   A[4,b],[5,b]A[8,b]         A[7,b],[5,a]  ®   A[4,b],[5,a]A[8,a],[5,a]
A[8,b]     ®   A[4,b]                           ®   A[4,b],[5,b]A[8,b],[5,a]
A[4,a],[5,a] ®   A[5,a],[5,a]             A[7,b],[5,b]  ®   A[4,b],[5,a]A[8,a],[5,b]
          ®   A[6,a],[5,a]                       ®   A[4,b],[5,b]A[8,b],[5,b]
A[4,a],[5,b]  ®   A[5,a],[5,b]             A[8,b],[5,a]  ®   A[4,b],[5,a]
          ®   A[6,a],[5,b]             A[8,b],[5,b]  ®   A[4,b],[5,b]">
</DIV>
                               (b)
<A 
   NAME="40003-19006r3.3.5"> </A>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 3.3.5 </STRONG></NOBR></TD><TD  
>The grammar in (b) generates the language accepted by the program in (a).              </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >L(P) is generated by the grammar G, which has the production rules in Figure <A 
 HREF="#40003-19006r3.3.5">3.3.5</A>(b).
[i, x] denotes a state of P that corresponds to the instruction segment I<SUB>i</SUB>, and value x in
<TT>x</TT>.
   <P >The derivation tree for the string abb in the grammar G, and the corresponding
transitions between the states of the program P on input &#34;a, b, b&#34;, are shown in Figure <A 
 HREF="#40003-19007r3.3.6">3.3.6</A>.
The symbol A<SUB>[1,a]</SUB> states that the computation of P has to start at state [1, a] and end at an
accepting state. The production rule A<SUB>[1,a]</SUB> <FONT FACE="SYMBOL">®</FONT> A<SUB>[4,a][5,b]</SUB>A<SUB>[2,b]</SUB> corresponds to a call to f
which returns the value b. <IMG 
SRC="theory-bk-three1x.gif" ALT=" *** " 
 >
   <P >
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="40003-19007r3.3.6"> </A>
<A 
   NAME="40003-19007r3.3.6"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-three-3-3-6.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 3.3.6 </STRONG></NOBR></TD><TD  
>A  correspondence  between  a  derivation  tree  and  a  computation  of  a  recursive
finite-domain program.                                                                                                 </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >Context-free grammars do not resemble pushdown automata, the way Type 3
grammars resemble finite-state automata. The difference arises because derivations in
context-free grammars are recursive in nature, whereas computations of pushdown
automata are iterative.
   <P >Consequently, some context-free languages can be more easily characterized by
context-free grammars, and other context-free languages can be more easily characterized
by pushdown automata.<A NAME="40003-19008"> </A>
   <P >
   <P >[<A 
 HREF="theory-bk-threese4.html" >next</A>] [<A 
 HREF="theory-bk-threese2.html" >prev</A>] [<A 
 HREF="theory-bk-threese2.html#tailtheory-bk-threese2.html" >prev-tail</A>] [<A 
 HREF="theory-bk-threese3.html" >front</A>] [<A 
 HREF="theory-bk-three.html#theory-bk-threese3.html" >up</A>] <A 
   NAME="tailtheory-bk-threese3.html"> </A></BODY></HTML>