
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-two.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-twose6.html" >next</A>] [<A 
 HREF="theory-bk-twose4.html" >prev</A>] [<A 
 HREF="theory-bk-twose4.html#tailtheory-bk-twose4.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-twose5.html">tail</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose5.html" >up</A>]
<H3>2.5 <A 
   NAME="30005-210002.5"> </A><A 
 HREF="theory-bk.html#Q2-30005-21"  NAME="Q1-30005-21">Closure Properties for Finite-Memory Programs</A></H3>
   <P >
<A NAME="30005-21001"> </A>
   <P >A helpful approach in simplifying the task of programming is to divide the given
problem into subproblems, design subprograms to solve the subproblems, and then
combine the subprograms into a program that solves the original problem. To allow
for a similar approach in designing finite-state transducers (and finite-memory
programs), it is useful to determine those operations that preserve the set of relations
that are computable by finite-state transducers. Such knowledge can then be
used in deciding how to decompose given problems to simpler subproblems, as
well as in preparing tools for automating the combining of subprograms into
programs.
   <P >In general, a set is said to be <I>closed</I><A NAME="30005-21002"> </A> under a particular operation if each application of
the operation on elements of the set results in an element of the set.
   <P ><STRONG>Example 2.5.1</STRONG> <A 
   NAME="30005-21003t2.5.1"> </A> 
The set of natural numbers is closed under addition, but it is not closed under subtraction.
The set of integers is closed under addition and subtraction, but not under division. The set
{ S | S is a set of five or more integers } is closed under union, but not under
intersection or complementation. The set { S | S is a set of at most five integer
numbers } is closed under intersection, but not under union or complementation. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P >The first theorem in this section is concerned with closure under the operation of
union.
   <P ><STRONG>Theorem 2.5.1</STRONG> <A 
   NAME="30005-21004t2.5.1"> </A> 
The class of relations computable by finite-state transducers is closed under union.<A NAME="30005-21005"> </A>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30005-21006t"> </A> 
Consider any two finite-state transducers M<SUB>1</SUB> = &lt;Q<SUB>1</SUB>, <FONT FACE="SYMBOL">S</FONT><SUB>1</SUB>, <FONT FACE="SYMBOL">D</FONT><SUB>1</SUB>, <FONT FACE="SYMBOL">d</FONT><SUB>1</SUB>, q<SUB>01</SUB>, F<SUB>1</SUB>&gt; and
M<SUB>2</SUB> = &lt;Q<SUB>2</SUB>, <FONT FACE="SYMBOL">S</FONT><SUB>2</SUB>, <FONT FACE="SYMBOL">D</FONT><SUB>2</SUB>, <FONT FACE="SYMBOL">d</FONT><SUB>2</SUB>, q<SUB>02</SUB>, F<SUB>2</SUB>&gt;. With no loss of generality assume that the
sets q<SUB>1</SUB> and q<SUB>2</SUB> of states are mutually disjoint, and that neither of them contains
q<SUB>0</SUB>.
   <P >Let M<SUB>3</SUB> be the finite-state transducer &lt;Q<SUB>3</SUB>, <FONT FACE="SYMBOL">S</FONT><SUB>3</SUB>, <FONT FACE="SYMBOL">D</FONT><SUB>3</SUB>, <FONT FACE="SYMBOL">d</FONT><SUB>3</SUB>, q<SUB>0</SUB>, F<SUB>3</SUB>&gt;, where
Q<SUB>3</SUB> = Q<SUB>1</SUB> <FONT FACE="SYMBOL">È</FONT> Q<SUB>2</SUB> <FONT FACE="SYMBOL">È</FONT> {q<SUB>0</SUB>}, <FONT FACE="SYMBOL">S</FONT><SUB>3</SUB> = <FONT FACE="SYMBOL">S</FONT><SUB>1</SUB> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">S</FONT><SUB>2</SUB>, <FONT FACE="SYMBOL">d</FONT><SUB>3</SUB> = <FONT FACE="SYMBOL">d</FONT><SUB>1</SUB> <FONT FACE="SYMBOL">È</FONT> <FONT FACE="SYMBOL">d</FONT><SUB>2</SUB> <FONT FACE="SYMBOL">È</FONT> {(q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>01</SUB>, <FONT FACE="SYMBOL">e</FONT>), (q<SUB>0</SUB>, <FONT FACE="SYMBOL">e</FONT>, q<SUB>02</SUB>, <FONT FACE="SYMBOL">e</FONT>)}, and
F<SUB>3</SUB> = F<SUB>1</SUB> <FONT FACE="SYMBOL">È</FONT> F<SUB>2</SUB> (see Figure <A 
 HREF="#30005-21007r2.5.1">2.5.1</A>).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30005-21007r2.5.1"> </A>
<A 
   NAME="30005-21007r2.5.1"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-5-1.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.5.1 </STRONG></NOBR></TD><TD  
>A schema of a finite-state transducer M<SUB>3</SUB> that computes R(M<SUB>1</SUB>) <FONT FACE="SYMBOL">È</FONT> R(M<SUB>2</SUB>).              </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >Intuitively, M<SUB>3</SUB> is a finite-state transducer that at the start of each computation
nondeterministically chooses to trace either a computation of M<SUB>1</SUB> or a computation of
M<SUB>2</SUB>.
   <P >By construction, R(M<SUB>3</SUB>) = R(M<SUB>1</SUB>) <FONT FACE="SYMBOL">È</FONT> R(M<SUB>2</SUB>). <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >Besides their usefulness in simplifying the task of programming, closure properties
can also be used to identify relations that cannot be computed by finite-state
transducers.
   <P ><STRONG>Example 2.5.2</STRONG> <A 
   NAME="30005-21008t2.5.2"> </A> 
The union of the languages L<SUB>1</SUB> = {<FONT FACE="SYMBOL">e</FONT>} and L<SUB>2</SUB> = { 0<SUP>i</SUP>1<SUP>i</SUP> | i <FONT FACE="SYMBOL">³</FONT> 1 } is equal to the language
L<SUB>3</SUB> = { 0<SUP>i</SUP>1<SUP>i</SUP> | i <FONT FACE="SYMBOL">³</FONT> 0 }. By Theorem <A 
 HREF="#30005-21004t2.5.1">2.5.1</A> the union L<SUB>3</SUB> = L<SUB>1</SUB> <FONT FACE="SYMBOL">È</FONT> L<SUB>2</SUB> of L<SUB>1</SUB> and L<SUB>2</SUB> is a regular
language if L<SUB>1</SUB> and L<SUB>2</SUB> are regular languages. Since L<SUB>1</SUB> = {<FONT FACE="SYMBOL">e</FONT>} is a regular language, it
follows that L<SUB>3</SUB> is a regular language if L<SUB>2</SUB> is a regular language. However, by
Example <A 
 HREF="theory-bk-twose4.html#30004-19006t2.4.2">2.4.2</A> the language L<SUB>3</SUB> = { 0<SUP>i</SUP>1<SUP>i</SUP> | i <FONT FACE="SYMBOL">³</FONT> 0 } is not regular. Consequently, is also
L<SUB>2</SUB> = { 0<SUP>i</SUP>1<SUP>i</SUP> | i <FONT FACE="SYMBOL">³</FONT> 1 } not regular. <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >The relations R<SUB>1</SUB> = { (0<SUP>i</SUP>1<SUP>j</SUP>, c<SUP>i</SUP>) | i, j <FONT FACE="SYMBOL">³</FONT> 1 } and R<SUB>2</SUB> = { (0<SUP>i</SUP>1<SUP>j</SUP>, c<SUP>j</SUP>) | i, j <FONT FACE="SYMBOL">³</FONT> 1 } are
computable by deterministic finite-state transducers. The pair (0<SUP>i</SUP>1<SUP>j</SUP>, c<SUP>k</SUP>) is in R<SUB>1</SUB> if and
only if k = i, and it is in R<SUB>2</SUB> if and only if k = j. The intersection R<SUB>1</SUB> <FONT FACE="SYMBOL">Ç</FONT> R<SUB>2</SUB> contains
all the pairs (0<SUP>i</SUP>1<SUP>j</SUP>, c<SUP>k</SUP>) that satisfy k = i = j, that is, R<SUB>1</SUB> <FONT FACE="SYMBOL">Ç</FONT> R<SUB>2</SUB> is the relation
{ (0<SUP>n</SUP>1<SUP>n</SUP>, c<SUP>n</SUP>) | n <FONT FACE="SYMBOL">³</FONT> 1 }.
   <P >If R<SUB>1</SUB> <FONT FACE="SYMBOL">Ç</FONT> R<SUB>2</SUB> is computable by a finite-state transducer then the language { 0<SUP>n</SUP>1<SUP>n</SUP> | n <FONT FACE="SYMBOL">³</FONT> 1 }
must be regular. However, by Example <A 
 HREF="theory-bk-twose4.html#30004-19006t2.4.2">2.4.2</A> the language is not regular. Therefore, the
class of the relations that are computable by finite-state transducers is not closed under
intersection.<A NAME="30005-21009"> </A>
   <P >The class of the relations computable by the finite-state transducers is also not closed
under complementation. An assumption to the contrary would imply that the<A NAME="30005-21010"> </A> nonregular
language R<SUB>1</SUB> <FONT FACE="SYMBOL">Ç</FONT> R<SUB>2</SUB> is regular, because by DeMorgan's<A NAME="30005-21011"> </A> law R<SUB>1</SUB> <FONT FACE="SYMBOL">Ç</FONT> R<SUB>2</SUB> = <IMG 
SRC="theory-bk-two16x.gif" ALT="---------
(R1È R2)">. That is,
an assumed closure under complementation would imply that <IMG 
SRC="theory-bk-two17x.gif" ALT="---
R1"> and <IMG 
SRC="theory-bk-two18x.gif" ALT="---
R2"> are computable
by finite-state transducers. Theorem <A 
 HREF="#30005-21004t2.5.1">2.5.1</A> would then imply that the union <IMG 
SRC="theory-bk-two19x.gif" ALT="---
R1"> <FONT FACE="SYMBOL">È</FONT> <IMG 
SRC="theory-bk-two20x.gif" ALT="---
R2"> is
computable by finite-state transducers. Finally, another application of the assumption
would imply that <IMG 
SRC="theory-bk-two21x.gif" ALT="---------
(R1È R2)"> = <IMG 
SRC="theory-bk-two22x.gif" ALT="---
R1"> <FONT FACE="SYMBOL">Ç</FONT> <IMG 
SRC="theory-bk-two23x.gif" ALT="---
R2"> is also computable by a finite-state
transducer.
   <P >The choice of R<SUB>1</SUB> and R<SUB>2</SUB> also implies the nonclosure, under intersection, of the class
of relations computable by deterministic finite-state transducers. The nonclosure under
union<A NAME="30005-21012"> </A> and complementation, of the class of relations computable by deterministic
finite-state transducers, is implied by the choice of the relations {(1, 1)} and
{(1, 11)}.
   <P >For regular languages the following theorem holds.
   <P ><STRONG>Theorem 2.5.2</STRONG> <A 
   NAME="30005-21013t2.5.2"> </A> 
Regular languages are closed under union<A NAME="30005-21014"> </A>, intersection, and complementation.
<A NAME="30005-21015"> </A>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="30005-21016t"> </A> 
By DeMorgan's law and the closure of regular languages under union (see Theorem <A 
 HREF="#30005-21004t2.5.1">2.5.1</A>),
it is sufficient to show that regular languages are closed under complementation.
   <P >For the purpose of this proof consider any finite-state automaton M = &lt;Q, <FONT FACE="SYMBOL">S</FONT>, <FONT FACE="SYMBOL">d</FONT>, q<SUB>0</SUB>, F&gt;.
By Theorem <A 
 HREF="theory-bk-twose3.html#30003-13001t2.3.1">2.3.1</A> it can be assumed that M is deterministic, and contains no <FONT FACE="SYMBOL">e</FONT> transition
rules.
   <P >Let M<SUB>eof</SUB> be M with a newly added, nonaccepting &#34;trap&#34; state, say, q<SUB>trap</SUB> and the
following newly added transition rules.
     <OL TYPE="a" 
>
     <LI><A 
   NAME="30005-21017xa"> </A>(q, a, q<SUB>trap</SUB>) for each pair (q, a) -- of a state q in Q and of an input symbol a
     in <FONT FACE="SYMBOL">S</FONT> -- for which no move is defined in M. That is, for each (q, a) for which
     no p exists in Q such that (q, a, p) is in <FONT FACE="SYMBOL">d</FONT>.
     <LI><A 
   NAME="30005-21018xb"> </A>(q<SUB>trap</SUB>, a, q<SUB>trap</SUB>) for each input symbol a in <FONT FACE="SYMBOL">S</FONT>.</OL>
By construction M<SUB>eof</SUB> is a deterministic finite-state automaton equivalent to M.
Moreover, M<SUB>eof</SUB> consumes all the inputs until their end, and it has no <FONT FACE="SYMBOL">e</FONT> transition
rules.
   <P >The complementation of the language L(M) is accepted by the finite-state automaton
M<SUB>complement</SUB> that is obtained from M<SUB>eof</SUB> by interchanging the roles of the accepting and
nonaccepting states.
   <P >For each given input a<SUB>1</SUB> · · · a<SUB>n</SUB> the finite-state automaton M<SUB>complement</SUB> has a unique
path that consumes a<SUB>1</SUB> · · · a<SUB>n</SUB> until its end. The path corresponds to the sequence of moves
that M<SUB>eof</SUB> takes on such an input. Therefore, M<SUB>complement</SUB> reaches an accepting state on a
given input if and only if M<SUB>eof</SUB> does not reach an accepting state on the the input. <IMG 
SRC="theory-bk-two2x.gif" ALT=" ***
" 
 >
   <P >
   <P ><STRONG>Example 2.5.3</STRONG> <A 
   NAME="30005-21019t2.5.3"> </A> 
Let M be the finite-state automaton whose transition diagram is given in Figure <A 
 HREF="#30005-21020r2.5.2">2.5.2</A>(a).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="30005-21020r2.5.2"> </A>
<A 
   NAME="30005-21020r2.5.2"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-two-2-5-2.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 2.5.2 </STRONG></NOBR></TD><TD  
>The finite-state automaton in (b) accepts the complementation of the language that
the finite-state automaton in (a) accepts.                                                                      </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>The complementation of L(M) is accepted by the finite-state automaton whose transition
diagram is given in Figure <A 
 HREF="#30005-21020r2.5.2">2.5.2</A>(b).
   <P >Without the trap state q<SUB>trap</SUB>, neither M nor M<SUB>complement</SUB> would be able to
accept the input 011, because none of them would be able to consume the whole
input.
   <P >Without the requirement that the algorithm has to be applied only on deterministic
finite-state automata, M<SUB>complement</SUB> could end up accepting an input that M also accepts.
For instance, by adding the transition rule (q<SUB>1</SUB>, 1, q<SUB>1</SUB>) to M and M<SUB>complement</SUB>, on input 01
each of the finite-state automata can end up either in state q<SUB>0</SUB> or in state q<SUB>1</SUB>. In such a case,
M would accept 01 because it can reach state q<SUB>1</SUB>, and M<SUB>complement</SUB> would accept 01
because it can reach state q<SUB>0</SUB>.<A NAME="30005-21021"> </A> <IMG 
SRC="theory-bk-two2x.gif" ALT=" *** " 
 >
   <P >
   <P >
   <P >[<A 
 HREF="theory-bk-twose6.html" >next</A>] [<A 
 HREF="theory-bk-twose4.html" >prev</A>] [<A 
 HREF="theory-bk-twose4.html#tailtheory-bk-twose4.html" >prev-tail</A>] [<A 
 HREF="theory-bk-twose5.html" >front</A>] [<A 
 HREF="theory-bk-two.html#theory-bk-twose5.html" >up</A>] <A 
   NAME="tailtheory-bk-twose5.html"> </A></BODY></HTML>