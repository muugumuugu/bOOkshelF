
<HTML  
><HEAD> <!--Created by TeX4ht from theory-bk-four.tex--><TITLE></TITLE></HEAD><BODY 
 BGCOLOR="ffffff">[<A 
 HREF="theory-bk-fourse6.html" >next</A>] [<A 
 HREF="theory-bk-fourse4.html" >prev</A>] [<A 
 HREF="theory-bk-fourse4.html#tailtheory-bk-fourse4.html" >prev-tail</A>] [<A 
 HREF="#tailtheory-bk-fourse5.html">tail</A>] [<A 
 HREF="theory-bk-four.html#theory-bk-fourse5.html" >up</A>]
<H3>4.5 <A 
   NAME="50005-180004.5"> </A><A 
 HREF="theory-bk.html#Q2-50005-18"  NAME="Q1-50005-18">Undecidability</A></H3>
   <P >
      <A 
 HREF="#Q1-50005-19"  NAME="Q2-50005-19">A Proof by a Generic Approach</A>
<BR>         <A 
 HREF="#Q1-50005-20"  NAME="Q2-50005-20">Proofs by Reduction</A>
<A NAME="50005-18001"> </A>
   <P >The finiteness of memory and the restricted access to it, respectively, constrain the
capabilities of finite-state transducers and pushdown transducers. In the case of Turing
transducers, however, none of the constraints made on memory is significant, because they
can all be removed and still the transducers acquire no more definition power. Yet there are
languages that Turing transducers cannot decide or even accept. The intuitive explanation
for this phenomenon is that each Turing transducer is a description of a language (i.e., a set
of strings), which itself has a description by a string. Consequently, there are more
languages than Turing transducers.
   <P >Specifically, each language over an alphabet <FONT FACE="SYMBOL">S</FONT> is a subset of <FONT FACE="SYMBOL">S</FONT>*. The set of all the
languages over <FONT FACE="SYMBOL">S</FONT> is the power set <IMG 
SRC="theory-bk-four21x.gif" ALT="">, which is uncountably infinite. On the other hand,
the number of Turing transducers that specify languages over <FONT FACE="SYMBOL">S</FONT> is countably<A NAME="50005-18002"> </A> infinite,
because they are all representable by strings from <FONT FACE="SYMBOL">S</FONT>*.
   <P ><EM><A 
   NAME="50005-19000"> </A><A 
 HREF="#Q2-50005-19"  NAME="Q1-50005-19">A Proof by a Generic Approach</A></EM>
   <P >The proof of the following theorem implicitly uses the previous observation. As with
the limitations of the finite-memory programs in Section 2.4 and the limitations of the
recursive finite-domain programs in Section 3.4, we here use a proof by reduction to
contradiction. The variant of the technique used here is called a proof by diagonalization<A NAME="50005-19001"> </A>,
owing to the employment of the diagonal of a table for choosing the language that
provides the contradiction.
   <P ><STRONG>Convention </STRONG> <A 
   NAME="50005-19002t"> </A> 
In this chapter x<SUB>i</SUB> will denote the <I>i</I>th string in the canonically ordered set of binary strings.
Similarly, M<SUB>i</SUB> will denote the Turing machine that has a standard binary<A NAME="50005-19003"> </A> representation
equal to the <I>i</I>th string, in the canonically ordered set of the standard binary representations
of Turing machines. (With no loss of generality it is assumed that isomorphic Turing
machines are equal.)
   <P ><STRONG>Theorem 4.5.1</STRONG> <A 
   NAME="50005-19004t4.5.1"> </A> 
There are nonrecursively enumerable languages, that is,<A NAME="50005-19005"> </A> languages that cannot be accepted
by any Turing machine.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="50005-19006t"> </A> 
Let L<SUB>accept</SUB> be the language { (M, x) | The turing machine M accepts the string x }. The
language L<SUB>accept</SUB> has a table representation T<SUB>accept</SUB> in which the rows are indexed by M<SUB>1</SUB>,
M<SUB>2</SUB>, M<SUB>3</SUB>, <FONT FACE="SYMBOL">¼</FONT>  the columns are indexed by x<SUB>1</SUB>, x<SUB>2</SUB>, x<SUB>3</SUB>, <FONT FACE="SYMBOL">¼</FONT>  and each entry at row M<SUB>i</SUB> and
column x<SUB>j</SUB> holds either 1 or 0, depending on whether M<SUB>i</SUB> accepts x<SUB>j</SUB> or not (see
Figure <A 
 HREF="#50005-19007r4.5.1">4.5.1</A>(a)).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50005-19007r4.5.1"> </A>
<A 
   NAME="50005-19007r4.5.1"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-four-4-5-1.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.5.1 </STRONG></NOBR></TD><TD  
>(a) Hypothetical table T<SUB>accept</SUB> indicating acceptance of word x<SUB>j</SUB> by Turing machine
M<SUB>i</SUB>. (b) Representations of L<SUB>diagonal_accept</SUB> and L<SUB>diagonal_reject</SUB> in T<SUB>accept</SUB>.              </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >Each language L can be represented by a vector that holds 1 at its <I>j</I>th entry if x<SUB>j</SUB> is in
L, and holds 0 at its <I>j</I>th entry if x<SUB>j</SUB> is not in L. In particular, the language L(M<SUB>i</SUB>) is
represented by the <I>i</I>th row in T<SUB>accept</SUB>.
   <P >The approach of the proof is to find a language that corresponds to no row in T<SUB>accept</SUB>,
and so cannot be accepted by any Turing machine. One such option is to construct the
language from the diagonal of T<SUB>accept</SUB>.
   <P >The diagonal of the table T<SUB>accept</SUB> is a representation of L<SUB>diagonal_accept</SUB> = { x | x = x<SUB>i</SUB>
and M<SUB>i</SUB> accepts x<SUB>i</SUB> }. Let L<SUB>diagonal_reject</SUB> denote the complementation { x | x = x<SUB>i</SUB> and M<SUB>i</SUB>
does not accept x<SUB>i</SUB> } of L<SUB>diagonal_accept</SUB>. Each Turing machine that accepts L<SUB>diagonal_reject</SUB>
implies some row M<SUB>k</SUB> in T<SUB>accept</SUB> that holds values complementing those in the diagonal at
similar locations (see Figure <A 
 HREF="#50005-19007r4.5.1">4.5.1</A>(b)). In particular, the kth digit in row M<SUB>k</SUB> must be the
complementation of the kth digit in the diagonal. However, the kth digit in row M<SUB>k</SUB> is also
the kth digit in the diagonal, consequently implying that no Turing machine can accept the
language L<SUB>diagonal_reject</SUB>.
   <P >The discussion above can be formalized in the following way. For the sake of the proof
assume that L<SUB>diagonal_reject</SUB> is accepted by some Turing machine M. Then there exists an
index k such that M = M<SUB>k</SUB>. Now consider the string x<SUB>k</SUB>. For x<SUB>k</SUB> either of the following
cases must hold.
    <DL><DT><STRONG>
 <STRONG>Case 1</STRONG> </STRONG><DD 
>x<SUB>k</SUB> is in L<SUB>diagonal_reject</SUB>. In Case 1, the assumption that the Turing machine
    M<SUB>k</SUB> accepts the language L<SUB>diagonal_reject</SUB> implies that M<SUB>k</SUB> accepts the string x<SUB>k</SUB>.
    Alternatively, the definition of L<SUB>diagonal_reject</SUB> implies that M<SUB>k</SUB> does not accept
    x<SUB>k</SUB>. Thus Case 1 cannot hold.
    <DT><STRONG>
 <STRONG>Case 2</STRONG> </STRONG><DD 
>x<SUB>k</SUB> is not in L<SUB>diagonal_reject</SUB>. Similarly, in Case 2, the assumption that M<SUB>k</SUB>
    accepts L<SUB>diagonal_reject</SUB> implies that M<SUB>k</SUB> does not accept x<SUB>k</SUB>. And alternatively,
    the definition of L<SUB>diagonal_reject</SUB> implies that M<SUB>k</SUB> accepts x<SUB>k</SUB>. Hence, implying
    that Case 2 cannot hold either.</DL>
The result follows because for the assumption that there is a Turing machine M
that accepts L<SUB>diagonal_reject</SUB> to hold, either Case 1 or Case 2 must hold. <IMG 
SRC="theory-bk-four0x.gif" ALT=" ***
" 
 >
   <P >
   <P >By Church's thesis a decision problem is partially decidable if and only if there is a
Turing machine that accepts exactly those instances of the problem that have the answer
yes. Similarly, the problem is decidable if and only if there is a Turing machine that
accepts exactly those instances that have the answer yes and that also halts on all instances
of answer no.
   <P >The proof of Theorem <A 
 HREF="#50005-19004t4.5.1">4.5.1</A> together with Church's thesis imply the following theorem.
The importance of this theorem stems from its exhibiting the existence of an undecidable
problem, and from its usefulness for showing the undecidability of other problems by
means of reducibility.
   <P ><STRONG>Theorem 4.5.2</STRONG> <A 
   NAME="50005-19008t4.5.2"> </A> 
The membership problem is undecidable, and, in fact, not even<A NAME="50005-19009"> </A> partially decidable for
L<SUB>diagonal_reject</SUB>.
   <P >
   <P ><EM><A 
   NAME="50005-20000"> </A><A 
 HREF="#Q2-50005-20"  NAME="Q1-50005-20">Proofs by Reduction</A></EM>
   <P >A proof of the undecidability of a given problem by means of reducibility<A NAME="50005-20001"> </A> runs as
follows (see Figure <A 
 HREF="#50005-20002r4.5.2">4.5.2</A>
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50005-20002r4.5.2"> </A>
<A 
   NAME="50005-20002r4.5.2"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-four-4-5-2.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.5.2 </STRONG></NOBR></TD><TD  
>Reduction of K<SUB>B</SUB> to K<SUB>A</SUB>.                                                                                             </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>and recall Section 1.5). For the purpose of the proof assume that the given problem K<SUB>A</SUB> is
decidable by some algorithm A. Find algorithms T<SUB>f </SUB> and T<SUB>g</SUB> that together with A provide an
algorithm B, for solving a known undecidable problem K<SUB>B</SUB> in the following manner. B,
when given an instance I, uses T<SUB>f </SUB> to obtain an instance I' of K<SUB>A</SUB>, employs A on I' to
obtain the output S' that A provides for I', and then introduces S' to T<SUB>g</SUB> to obtain the
output S of B. The undecidability of K<SUB>A</SUB> then follows, because otherwise the
decidability of a problem K<SUB>B</SUB> that is known to be undecidable would have been
implied.
   <P >The proof of the following theorem is an example of a proof that uses reduction
between undecidable problems.
   <P ><STRONG>Theorem 4.5.3</STRONG> <A 
   NAME="50005-20003t4.5.3"> </A> 
The membership problem for Turing machines or, equivalently, for L<SUB>accept</SUB> is undecidable.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="50005-20004t"> </A> 
For the purpose of the proof assume that the given problem is decidable by a hypothetical
algorithm A (see Figure <A 
 HREF="#50005-20005r4.5.3">4.5.3</A>).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50005-20005r4.5.3"> </A>
<A 
   NAME="50005-20005r4.5.3"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-four-4-5-3.jpg" ALT="[PICT]" 
>
   <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.5.3 </STRONG></NOBR></TD><TD  
>Reduction  of  the  membership  problem  for  L<SUB>diagonal_reject</SUB>  to  the  membership
problem for L<SUB>accept</SUB>.                                                                                                     </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Then the membership problem for L<SUB>diagonal_reject</SUB> can be decided by an algorithm B of the
following form.
   <P >The algorithm B on a given input x uses a converter T<SUB>f </SUB> to obtain a pair (M<SUB>i</SUB>, x<SUB>i</SUB>) such
that x = x<SUB>i</SUB>. T<SUB>f </SUB> can find the index i for x by listing the binary strings <FONT FACE="SYMBOL">e</FONT>, 0, 00, <FONT FACE="SYMBOL">¼</FONT> , x in
canonical order, and determining the index of x in the list. T<SUB>f </SUB> can find M<SUB>i</SUB> by listing the
binary strings <FONT FACE="SYMBOL">e</FONT>, 0, 1, 00, <FONT FACE="SYMBOL">¼</FONT>  in canonical order until the <I>i</I>th standard binary representation of a
Turing machine is reached.
   <P >The output (M<SUB>i</SUB>, x<SUB>i</SUB>) of T<SUB>f </SUB> is provided by B to A. Finally B employs T<SUB>g</SUB> for determining
that x is in L<SUB>diagonal_reject</SUB> if A determines that x is not in L<SUB>accept</SUB>, and that x is not in
L<SUB>diagonal_reject</SUB> if A determines that x is in L<SUB>accept</SUB>.
   <P >The result follows from the undecidability of the membership problem for the
language L<SUB>diagonal_reject</SUB> (see Theorem <A 
 HREF="#50005-19008t4.5.2">4.5.2</A>). <IMG 
SRC="theory-bk-four0x.gif" ALT=" *** " 
 >
   <P >
   <P >The previous theorem and the next one imply that there are nonrecursive languages
that are recursively enumerable.<A NAME="50005-20006"> </A>
   <P ><STRONG>Theorem 4.5.4</STRONG> <A 
   NAME="50005-20007t4.5.4"> </A> 
The membership problem for Turing machines or, equivalently, for L<SUB>accept</SUB> is partially
decidable.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="50005-20008t"> </A> 
L<SUB>accept</SUB> is accepted by a nondeterministic Turing machine similar to the universal Turing
machine M<SUB>2</SUB> in the proof of Theorem <A 
 HREF="theory-bk-fourse4.html#50004-17001t4.4.1">4.4.1</A>. <IMG 
SRC="theory-bk-four0x.gif" ALT=" *** " 
 >
   <P >
   <P >Many problems, including the one in the following theorem, can be shown to be
undecidable by reduction from the membership problem for Turing machines.
<A NAME="50005-20009"> </A>
   <P ><STRONG>Theorem 4.5.5</STRONG> <A 
   NAME="50005-20010t4.5.5"> </A> 
The halting problem for Turing machines is undecidable.<A NAME="50005-20011"> </A>
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="50005-20012t"> </A> 
A Turing machine M does not halt on a given input x if and only if M does not accept x
and on such an input M can have an infinite sequence of moves.
   <P >An answer no to the halting problem for an instance (M, x) implies the same answer
to the membership problem for the instance (M, x). However, an answer yes to the halting
problem for an instance (M, x) can correspond to either an answer yes or an answer no to
the membership problem for the instance (M, x). The proof of the theorem relies on the
observation that each Turing machine M can be modified to avoid the rejection of an input
in a halting configuration. With such a modification, an answer yes to the halting
problem at (M, x) also implies the same answer to the membership problem at
(M, x).
   <P >For the purpose of the proof assume that the halting problem for Turing machines is
decidable by a hypothetical algorithm A. Then an algorithm B, which decides
the membership problem for Turing machines, can be constructed employing
a translator T<SUB>f </SUB> and the hypothetical algorithm A in the following manner (see
Figure <A 
 HREF="#50005-20013r4.5.4">4.5.4</A>).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50005-20013r4.5.4"> </A>
<A 
   NAME="50005-20013r4.5.4"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-four-4-5-4.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.5.4 </STRONG></NOBR></TD><TD  
>Reduction of the membership problem for Turing machines to the halting problem
for Turing machines.                                                                                                    </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>   <P >B provides any given instance (M, x) to T<SUB>f </SUB>. T<SUB>f </SUB> constructs from the given m
auxiliary-work-tape Turing machine M an equivalent Turing machine M<SUB><FONT FACE="SYMBOL">¥</FONT></SUB>, that halts on a
given input if and only if M accepts the input. Specifically, M<SUB><FONT FACE="SYMBOL">¥</FONT></SUB> is just the Turing
machine M with a &#34;looping&#34; transition rule of the form (q, a, b<SUB>1</SUB>,<FONT FACE="SYMBOL"> ¼</FONT>, b<SUB>m</SUB>, q, 0, b<SUB>1</SUB>, 0,<FONT FACE="SYMBOL"> ¼</FONT>, b<SUB>m</SUB>, 0)
added for each nonaccepting state q, each input symbol a, and each combination of
auxiliary work-tape symbols b<SUB>1</SUB>, <FONT FACE="SYMBOL">¼</FONT> , b<SUB>m</SUB> on which M has no next move. B feeds (M<SUB><FONT FACE="SYMBOL">¥</FONT></SUB>, x) to A
and assumes the output of A.
   <P >The result follows from Theorem <A 
 HREF="#50005-20003t4.5.3">4.5.3</A>, showing that the membership problem is
undecidable for L<SUB>accept</SUB>. <IMG 
SRC="theory-bk-four0x.gif" ALT=" *** " 
 >
   <P >
   <P ><STRONG>Example 4.5.1</STRONG> <A 
   NAME="50005-20014t4.5.1"> </A> 
Let M be the Turing machine in Figure <A 
 HREF="#50005-20015r4.5.5">4.5.5</A>(a).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50005-20015r4.5.5"> </A>
<A 
   NAME="50005-20015r4.5.5"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-four-4-5-5.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.5.5 </STRONG></NOBR></TD><TD  
>(a) A Turing machine M. (b) A Turing machine M<SUB><FONT FACE="SYMBOL">¥</FONT></SUB> that is equivalent to M.           </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Upon reaching state q<SUB>0</SUB> the Turing machine M enters a nonaccepting halting configuration
if both the input head and the auxiliary work-tape head scan the symbol a. M can be
modified to enter an infinite loop in such a configuration by forcing the Turing machine to
make a move that does not change the configuration, that is, by introducing a transition
rule of the form (q<SUB>0</SUB>, a, a, q<SUB>0</SUB>, 0, a, 0).
   <P >Using the notations in the proof of Theorem <A 
 HREF="#50005-20010t4.5.5">4.5.5</A>, M<SUB><FONT FACE="SYMBOL">¥</FONT></SUB> is the Turing machine in
Figure <A 
 HREF="#50005-20015r4.5.5">4.5.5</A>(b). <IMG 
SRC="theory-bk-four0x.gif" ALT=" *** " 
 >
   <P >
   <P >The next theorem provides another example of a proof of undecidability by means of
reduction.
   <P ><STRONG>Theorem 4.5.6</STRONG> <A 
   NAME="50005-20016t4.5.6"> </A> 
The problem of deciding for any given Turing machine whether the machine accepts a
regular language<A NAME="50005-20017"> </A> is undecidable.
   <P >
   <P ><STRONG>Proof </STRONG> <A 
   NAME="50005-20018t"> </A> 
Consider any instance (M, x) of the membership problem for Turing machines. From
(M, x) construct a Turing machine M<SUB>x</SUB> that accepts { a<SUP>i</SUP>b<SUP>i</SUP> | i <FONT FACE="SYMBOL">³</FONT> 0 } if M accepts x, and
that accepts the empty set if M does not accept x.
   <P >Specifically, M<SUB>x</SUB> on any given input w starts the computation by checking whether
w = a<SUP>i</SUP>b<SUP>i</SUP> for some i <FONT FACE="SYMBOL">³</FONT> 0. If the equality w = a<SUP>i</SUP>b<SUP>i</SUP> holds for no i <FONT FACE="SYMBOL">³</FONT> 0, then M<SUB>x</SUB> rejects w.
Otherwise, M<SUB>x</SUB> simulates the computation of M on input x. In the latter case, M<SUB>x</SUB> accepts
w if it determines that M accepts x, and M<SUB>x</SUB> rejects w if it determines that M rejects
x.
   <P >Consequently, M<SUB>x</SUB> accepts a regular language (which is the empty set) if and only if
M does not accept x. The result follows from the undecidability of the membership
problem for Turing machines (see Theorem <A 
 HREF="#50005-20003t4.5.3">4.5.3</A>). <IMG 
SRC="theory-bk-four0x.gif" ALT=" *** " 
 >
   <P >
   <P ><STRONG>Example 4.5.2</STRONG> <A 
   NAME="50005-20019t4.5.2"> </A> 
Let M be the Turing machine given in Figure <A 
 HREF="#50005-20020r4.5.6">4.5.6</A>(a).
   <HR><CENTER><TABLE><TR><TD ><A 
   NAME="50005-20020r4.5.6"> </A>
<A 
   NAME="50005-20020r4.5.6"> </A>
<BR><IMG 
SRC="draw-pic/theory-bk-four-4-5-6.jpg" ALT="[PICT]" 
>
    <BR><TABLE  
><TR VALIGN="BASELINE"><TD><NOBR><STRONG>Figure 4.5.6 </STRONG></NOBR></TD><TD  
>(a) A Turing machine M. (b) A corresponding Turing machine M<SUB>ababc</SUB> that accepts
{ a<SUP>i</SUP>b<SUP>i</SUP> | i <FONT FACE="SYMBOL">³</FONT> 0 } if and only if M accepts ababc.                                                           </TD></TR></TABLE></CENTER>
</TD></TR></TABLE></CENTER><HR>Let x = ababc. Then M<SUB>x</SUB> in the proof of Theorem <A 
 HREF="#50005-20016t4.5.6">4.5.6</A> can be as in Figure <A 
 HREF="#50005-20020r4.5.6">4.5.6</A>(b). M<SUB>x</SUB>
has one more auxiliary work tape than M and consists of three subcomponents M<SUB>1</SUB>, M<SUB>2</SUB>,
and M<SUB>3</SUB>.
   <P >M<SUB>1</SUB> checks that the given input is of the form a<SUP>i</SUP>b<SUP>i</SUP> for some i <FONT FACE="SYMBOL">³</FONT> 0. M<SUB>2</SUB> stores the string
<IMG 
SRC="theory-bk-four22x.gif" ALT="PICT" >
x<IMG 
SRC="theory-bk-four23x.gif" ALT="PICT" > in the first auxiliary work tape. M<SUB>3</SUB> is just M modified to read its input from the first
auxiliary work tape. <IMG 
SRC="theory-bk-four24x.gif" ALT="PICT" >
and <IMG 
SRC="theory-bk-four25x.gif" ALT="PICT" > are the symbols used in the first auxiliary work tape representing the endmarkers ¢
and $, respectively. <IMG 
SRC="theory-bk-four0x.gif" ALT=" *** " 
 >
   <P >
   <P >The universe of the undecidable problems includes numerous examples. For many of
these problems the proof of undecidability is quite involved. The selection that has been
made here should be appreciated at least for the simplification that it allows in introducing
the concepts under consideration.<A NAME="50005-20021"> </A>
   <P >
   <P >[<A 
 HREF="theory-bk-fourse6.html" >next</A>] [<A 
 HREF="theory-bk-fourse4.html" >prev</A>] [<A 
 HREF="theory-bk-fourse4.html#tailtheory-bk-fourse4.html" >prev-tail</A>] [<A 
 HREF="theory-bk-fourse5.html" >front</A>] [<A 
 HREF="theory-bk-four.html#theory-bk-fourse5.html" >up</A>] <A 
   NAME="tailtheory-bk-fourse5.html"> </A></BODY></HTML>